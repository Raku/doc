=begin pod

=TITLE class Whatever

=SUBTITLE Placeholder for an unspecified value/argument

    class Whatever { }

C<Whatever> is a class whose objects don't really do much; it gets
its semantic from other routines that accept C<Whatever>-objects as markers
to do something special. The C<*> literal in term position creates a
C<Whatever> object.

Much of C<*>'s charm comes from I<Whatever-currying>. When C<*> is used in term
position in combination with most operators, the compiler will transform the
expression into a closure of type L<WhateverCode>.

    my $c = * + 2;          # same as   -> $x { $x + 2 };
    say $c(4);              # 6

Multiple C<*> in one expression generate closures with as many arguments:

    my $c = * + *;          # same as   -> $x, $y { $x + $y }

Using C<*> in complex expressions will also generate closures:

    my $c = 4 * * + 5;      # same as   -> $x { 4 * $x + 5 }

Calling a method on C<*> also creates a closure:

    <a b c>.map: *.uc;      # same as    <a b c>.map: -> $char { $char.uc }

As mentioned  before, not all operators and syntactic constructs curry C<*> (or
C<Whatever>-stars) to C<WhateverCode>. In the following cases, C<*> will remain
a C<Whatever> object.

=begin table

    Exception           Example     What it does
    =========           =======     ============
    comma               1, *, 2     generates a List with a * element
    range operators     1..*        Range.new(:from(1), :to(*));
    series operator     1 ... *     infinite list
    smart-matching      1 ~~ *      returns True
    assignment          $x = *      assign * to $x
    binding             $x := *     binds * to $x
    list repetition     1 xx *      generates infinite list

=end table

The range operators are handled specially. They do not curry with
C<Whatever>-stars, but they do curry with C<WhateverCode>

    say (1..*).WHAT;        # Range
    say (1..*-1).WHAT;      # WhateverCode

This allow all these constructs to work:

    .say for 1..*;          # infinite loop
    my @a = 1..4;
    say @a[0..*];           # 1 2 3 4
    say @a[0..*-2];         # 1 2 3

Because I<Whatever-currying> is a purely syntactic compiler transform, you will get no
runtime currying of stored C<Whatever>-stars into C<WhateverCode>s.

    my $x = *;
    $x + 2;                 # not a closure, dies because
                            # it can't coerce $x to Numeric

The use cases for stored C<Whatever>-stars are involve those curry-exception
cases mentioned above. For example, if you want an infinite series by default.

    my $max    = potential-upper-limit() // *;
    my $series = known-lower-limit() ... $max;

A stored C<*> will also result in the generation of a C<WhateverCode> in the specific
case of smart match. Note that this is not actually the stored C<*> which is being curried, but
rather the C<*> on the LHS.

    my $constraint = find-constraint() // *;
    my $maybe-always-matcher = * ~~ $constraint;

If this hypothetical C<find-constraint> were to have found no constraint, C<$maybe-always-matcher>
would return to C<True> for anything.

    $maybe-always-matcher(555);      # True
    $maybe-always-matcher(Any);      # True

=head1 Methods

=head2 method ACCEPTS

    multi method ACCEPTS(Whatever:D: Mu $other)

Returns C<True>.

=end pod
