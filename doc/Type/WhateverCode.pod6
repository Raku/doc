=begin pod

=TITLE class WhateverCode

=SUBTITLE Code object constructed by Whatever-currying

    class WhateverCode is Code { }

C<WhateverCode> objects are the result of L<Whatever>-currying. See the
L<Whatever> documentation for details.

When you wish to control how a method or function interprets any
I<Whatever stars>, you may use multi dispatch with C<Whatever> and
C<WhateverCode> parameters to do so, as in the following example:

    class Cycle {
          has $.pos;
          has @.vals;
    }

    multi sub get-val(Cycle $c, Int $idx) {
          $c.vals[$idx % $c.vals.elems]
    }

    # Define what to do with a stand-alone * as the second argument
    multi sub get-val(Cycle $c, Whatever $idx) {
        get-val($c, $c.pos);
    }

    # Define what to do with a * WhateverCode in an expression
    multi sub get-val(Cycle $c, WhateverCode $idx) {
        get-val($c, $idx($c.pos));
    }

    my Cycle $c .= new(:pos(2), :vals(0..^10));

    say get-val($c, 3);   # OUTPUT: «3␤»
    say get-val($c, *);   # OUTPUT: «2␤»
    say get-val($c, *-1); # OUTPUT: «1␤»

Since C<WhateverCode> objects are C<Callable> you may use introspection
to create as fancy a behavior as you wish.  Continuing the following
example we may add handling for two I<Whatever stars>:

=begin code :skip-test
# Define what to do with two * in an expression
multi sub get-val(Cycle $c, WhateverCode $idx where { .arity == 2 }) {
    get-val($c, $idx($c.pos, $c.vals.elems));
}

say get-val($c, * + * div 2); # 2 + 10/2 = 7
=end code

Note, though, that subexpressions may impose their own I<Whatever star>
rules:

=for code :skip-test
my @a = (0, 1, 2);
say get-val($c, @a[*-1]) # 2, because the star belongs to the Array class

This can make the ownership of I<Whatever stars> become confusing rather
quickly, so be careful not to overdo it.

=end pod
