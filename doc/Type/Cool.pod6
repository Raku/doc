=begin pod :kind("Type") :subkind("class") :category("basic")

=TITLE class Cool

=SUBTITLE Object that can be treated as both a string and number

    class Cool is Any { }

C<Cool>, also known as the B<C>onvenient B<OO> B<L>oop, is a base class employed
by a number of built-in classes whose instances can be meaningfully coerced to a
string and a number. For example, an L<Array|/type/Array> can be used in
mathematical operations, where its numerical representation is the number of
elements it contains. At the same time, it can be concatenated to a string,
where its stringy representation is all of its elements L<joined|/routine/join>
by a space. Because L<Array|/type/Array> is C<Cool>, the appropriate
coercion happens automatically.

Methods in C<Cool> coerce the invocant to a more specific type, and then call
the same method on that type. For example both L<Int|/type/Int> and
L<Str|/type/Str> inherit from C<Cool>, and calling method C<substr> on an C<Int>
converts the integer to C<Str> first.

    123.substr(1, 1);   # '2', same as 123.Str.substr(1, 1)

The following built-in types inherit from C<Cool>: L<Array|/type/Array>
L<Bool|/type/Bool> L<Complex|/type/Complex> L<Cool|/type/Cool>
L<Duration|/type/Duration> L<Map|/type/Map> L<FatRat|/type/FatRat>
L<Hash|/type/Hash> L<Instant|/type/Instant> L<Int|/type/Int> L<List|/type/List>
L<Match|/type/Match> L<Nil|/type/Nil> L<Num|/type/Num> L<Range|/type/Range>
L<Seq|/type/Seq> L<Stash|/type/Stash> L<Str|/type/Str>.

The following table summarizes the methods that C<Cool> provides, and
what type they coerce to:

=begin table

    method          coercion type

    abs             Numeric
    conj            Numeric
    sqrt            Numeric
    sign            Real
    rand            Numeric
    sin             Numeric
    asin            Numeric
    cos             Numeric
    acos            Numeric
    tan             Numeric
    tanh            Numeric
    atan            Numeric
    atan2           Numeric
    atanh           Numeric
    sec             Numeric
    asec            Numeric
    cosec           Numeric
    acosec          Numeric
    cotan           Numeric
    cotanh          Numeric
    acotan          Numeric
    sinh            Numeric
    asinh           Numeric
    cosh            Numeric
    acosh           Numeric
    sech            Numeric
    asech           Numeric
    cosech          Numeric
    acosech         Numeric
    acotanh         Numeric
    cis             Numeric
    log             Numeric
    exp             Numeric
    roots           Numeric
    log10           Numeric
    log2            Numeric
    unpolar         Numeric
    round           Numeric
    floor           Numeric
    ceiling         Numeric
    truncate        Numeric
    chr             Int
    ord             Str
    chars           Str
    fmt             Str
    uniname         Str
    uninames        Seq
    unival          Str
    univals         Str
    uniprop         Str
    unimatch        Str
    uc              Str
    lc              Str
    fc              Str
    tc              Str
    tclc            Str
    flip            Str
    trans           Str
    contains        Str
    index           Str
    rindex          Str
    ords            Str
    split           Str
    match           Str
    comb            Str
    subst           Str
    sprintf         Str
    printf          Str
    samecase        Str
    trim            Str
    trim-leading    Str
    trim-trailing   Str
    EVAL            Str
    chomp           Str
    chop            Str
    codes           Str

=end table

=head1 Methods

=head2 routine abs

Defined as:

    sub abs(Numeric() $x)
    method abs()

Coerces the invocant (or in the sub form, the argument) to
L<Numeric|/type/Numeric> and returns the absolute value (that is, a
non-negative number).

    say (-2).abs;       # OUTPUT: Â«2â¤Â»
    say abs "6+8i";     # OUTPUT: Â«10â¤Â»

=head2 method conj

Defined as:

    method conj()

Coerces the invocant to L<Numeric|/type/Numeric> and returns the
L<complex|/type/Complex> conjugate (that is, the number with the sign of the
imaginary part negated).

    say (1+2i).conj;        # OUTPUT: Â«1-2iâ¤Â»

=head2 method EVAL

Defined as:

=for code :method
method EVAL(*%_)

It calls the L<subroutine form|/language/independent-routines#routine_EVAL> with the
invocant as the first argument, C<$code>, passing along named args, if any.


=head2 routine sqrt

Defined as:

    sub sqrt(Numeric(Cool) $x)
    method sqrt()

Coerces the invocant to L<Numeric|/type/Numeric> (or in the sub form, the
argument) and returns the square root, that is, a non-negative number that, when
multiplied with itself, produces the original number.

    say 4.sqrt;             # OUTPUT: Â«2â¤Â»
    say sqrt(2);            # OUTPUT: Â«1.4142135623731â¤Â»

=head2 method sign

Defined as:

    method sign()

Coerces the invocant to L<Numeric|/type/Real> and returns its sign, that
is, 0 if the number is 0, 1 for positive and -1 for negative values.

    say 6.sign;             # OUTPUT: Â«1â¤Â»
    say (-6).sign;          # OUTPUT: Â«-1â¤Â»
    say "0".sign;           # OUTPUT: Â«0â¤Â»

=head2 method rand

Defined as:

    method rand()

Coerces the invocant to L<Num|/type/Num> and returns a pseudo-random value
between zero and the number.

    say 1e5.rand;           # OUTPUT: Â«33128.495184283â¤Â»

=head2 routine sin

Defined as:

    sub sin(Numeric(Cool))
    method sin()

Coerces the invocant (or in the sub form, the argument) to L<Numeric|/type/Numeric>, interprets it as radians,
returns its L<sine|https://en.wikipedia.org/wiki/Sine>.

    say sin(0);             # OUTPUT: Â«0â¤Â»
    say sin(pi/4);          # OUTPUT: Â«0.707106781186547â¤Â»
    say sin(pi/2);          # OUTPUT: Â«1â¤Â»

Note that Raku is no computer algebra system, so C<sin(pi)> typically does
not produce an exact 0, but rather a very small L<floating-point
number|/type/Num>.

=head2 routine asin

Defined as:

    sub asin(Numeric(Cool))
    method asin()

Coerces the invocant (or in the sub form, the argument) to
L<Numeric|/type/Numeric>, and returns its
L<arc-sine|https://en.wikipedia.org/wiki/Inverse_trigonometric_functions> in
radians.

    say 0.1.asin;               # OUTPUT: Â«0.10016742116156â¤Â»
    say asin(0.1);              # OUTPUT: Â«0.10016742116156â¤Â»

=head2 routine cos

Defined as:

    sub cos(Numeric(Cool))
    method cos()

Coerces the invocant (or in sub form, the argument) to L<Numeric|/type/Numeric>,
interprets it as radians, returns its
L<cosine|https://en.wikipedia.org/wiki/Cosine>.

    say 0.cos;                  # OUTPUT: Â«1â¤Â»
    say pi.cos;                 # OUTPUT: Â«-1â¤Â»
    say cos(pi/2);              # OUTPUT: Â«6.12323399573677e-17â¤Â»

=head2 routine acos

Defined as:

    sub acos(Numeric(Cool))
    method acos()

Coerces the invocant (or in sub form, the argument) to L<Numeric|/type/Numeric>, and returns its
L<arc-cosine|https://en.wikipedia.org/wiki/Inverse_trigonometric_functions> in
radians.

    say 1.acos;                 # OUTPUT: Â«0â¤Â»
    say acos(-1);               # OUTPUT: Â«3.14159265358979â¤Â»

=head2 routine tan

Defined as:

    sub tan(Numeric(Cool))
    method tan()

Coerces the invocant (or in sub form, the argument) to L<Numeric|/type/Numeric>, interprets it as radians,
returns its L<tangent|https://en.wikipedia.org/wiki/Tangent>.

    say tan(3);                 # OUTPUT: Â«-0.142546543074278â¤Â»
    say 3.tan;                  # OUTPUT: Â«-0.142546543074278â¤Â»

=head2 routine atan

Defined as:

    sub atan(Numeric(Cool))
    method atan()

Coerces the invocant (or in sub form, the argument) to L<Numeric|/type/Numeric>, and returns its
L<arc-tangent|https://en.wikipedia.org/wiki/Inverse_trigonometric_functions> in
radians.

    say atan(3);                # OUTPUT: Â«1.24904577239825â¤Â»
    say 3.atan;                 # OUTPUT: Â«1.24904577239825â¤Â»

=head2 routine atan2

Defined as:

    sub atan2($y, $x = 1e0)
    method atan2($x = 1e0)

The sub should usually be written with two arguments for clarity as it
is seen in other languages and in mathematical texts, but the
single-argument form is available; its result will always match that of
L<atan|/routine/atan>.

    say atan2 3, 1;             # OUTPUT: Â«1.2490457723982544â¤Â»
    say atan2 3;                # OUTPUT: Â«1.2490457723982544â¤Â»
    say atan2 â…”, â…“;             # OUTPUT: Â«1.1071487177940904â¤Â»

The method coerces self and its single argument to
L<Numeric|/type/Numeric>, using them to compute the two-argument
L<arc-tangent|https://en.wikipedia.org/wiki/Atan2> in radians.

    say 3.atan2;                # OUTPUT: Â«1.24904577239825â¤Â»
    say â…”.atan2(â…“);             # OUTPUT: Â«1.1071487177940904â¤Â»

The $x argument in either the method or the sub defaults to 1 so, in both
single-argument cases, the function will return the angle Î¸ in radians
between the x-axis and a vector that goes from the origin to the point
(3, 1).

=head2 routine sec

Defined as:

    sub sec(Numeric(Cool))
    method sec()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, interprets it as radians,
returns its L<secant|https://en.wikipedia.org/wiki/Trigonometric_functions#Reciprocal_functions>,
that is, the reciprocal of its cosine.

    say 45.sec;                 # OUTPUT: Â«1.90359440740442â¤Â»
    say sec(45);                # OUTPUT: Â«1.90359440740442â¤Â»

=head2 routine asec

Defined as:

    sub asec(Numeric(Cool))
    method asec()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>,
and returns its
L<arc-secant|https://en.wikipedia.org/wiki/Inverse_trigonometric_functions> in
radians.

    say 1.asec;                 # OUTPUT: Â«0â¤Â»
    say sqrt(2).asec;           # OUTPUT: Â«0.785398163397448â¤Â»

=head2 routine cosec

Defined as:

    sub cosec(Numeric(Cool))
    method cosec()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>,
interprets it as radians, returns its
L<cosecant|https://en.wikipedia.org/wiki/Trigonometric_functions#Reciprocal_functions>,
that is, the reciprocal of its sine.

    say 0.45.cosec;             # OUTPUT: Â«2.29903273150897â¤Â»
    say cosec(0.45);            # OUTPUT: Â«2.29903273150897â¤Â»

=head2 routine acosec

Defined as:

    sub acosec(Numeric(Cool))
    method acosec()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>,
and returns its
L<arc-cosecant|https://en.wikipedia.org/wiki/Inverse_trigonometric_functions> in
radians.

    say 45.acosec;              # OUTPUT: Â«0.0222240516182672â¤Â»
    say acosec(45)              # OUTPUT: Â«0.0222240516182672â¤Â»

=head2 routine cotan

Defined as:

    sub cotan(Numeric(Cool))
    method cotan()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>,
interprets it as radians, returns its
L<cotangent|https://en.wikipedia.org/wiki/Trigonometric_functions#Reciprocal_functions>,
that is, the reciprocal of its tangent.

    say 45.cotan;               # OUTPUT: Â«0.617369623783555â¤Â»
    say cotan(45);              # OUTPUT: Â«0.617369623783555â¤Â»

=head2 routine acotan

Defined as:

    sub acotan(Numeric(Cool))
    method acotan()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>,
and returns its
L<arc-cotangent|https://en.wikipedia.org/wiki/Inverse_trigonometric_functions>
in radians.

    say 45.acotan;              # OUTPUT: Â«0.0222185653267191â¤Â»
    say acotan(45)              # OUTPUT: Â«0.0222185653267191â¤Â»

=head2 routine sinh

Defined as:

    sub sinh(Numeric(Cool))
    method sinh()

Coerces the invocant (or in method form, its argument) to
L<Numeric|/type/Numeric>, and returns its
L<Sine hyperbolicus|https://en.wikipedia.org/wiki/Hyperbolic_function>.

    say 1.sinh;                 # OUTPUT: Â«1.1752011936438â¤Â»
    say sinh(1);                # OUTPUT: Â«1.1752011936438â¤Â»

=head2 routine asinh

Defined as:

    sub asinh(Numeric(Cool))
    method asinh()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Inverse Sine hyperbolicus|https://en.wikipedia.org/wiki/Inverse_hyperbolic_function>.

    say 1.asinh;                # OUTPUT: Â«0.881373587019543â¤Â»
    say asinh(1);               # OUTPUT: Â«0.881373587019543â¤Â»

=head2 routine cosh

Defined as:

    sub cosh(Numeric(Cool))
    method cosh()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Cosine hyperbolicus|https://en.wikipedia.org/wiki/Hyperbolic_function>.

    say cosh(0.5);              # OUTPUT: Â«1.12762596520638â¤Â»

=head2 routine acosh

Defined as:

    sub acosh(Numeric(Cool))
    method acosh()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Inverse Cosine hyperbolicus|https://en.wikipedia.org/wiki/Inverse_hyperbolic_function>.

    say acosh(45);              # OUTPUT: Â«4.4996861906715â¤Â»

=head2 routine tanh

Defined as:

    sub tanh(Numeric(Cool))
    method tanh()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, interprets it as
radians and returns its L<Tangent hyperbolicus|https://en.wikipedia.org/wiki/Hyperbolic_function>.

    say tanh(0.5);              # OUTPUT: Â«0.46211715726001â¤Â»
    say tanh(atanh(0.5));       # OUTPUT: Â«0.5â¤Â»

=head2 routine atanh

Defined as:

    sub atanh(Numeric(Cool))
    method atanh()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Inverse tangent hyperbolicus|https://en.wikipedia.org/wiki/Inverse_hyperbolic_function>.

    say atanh(0.5);             # OUTPUT: Â«0.549306144334055â¤Â»

=head2 routine sech

Defined as:

    sub sech(Numeric(Cool))
    method sech()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Secant hyperbolicus|https://en.wikipedia.org/wiki/Hyperbolic_function>.

    say 0.sech;                 # OUTPUT: Â«1â¤Â»

=head2 routine asech

Defined as:

    sub asech(Numeric(Cool))
    method asech()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Inverse hyperbolic secant|https://en.wikipedia.org/wiki/Hyperbolic_function>.

    say 0.8.asech;              # OUTPUT: Â«0.693147180559945â¤Â»

=head2 routine cosech

Defined as:

    sub cosech(Numeric(Cool))
    method cosech()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Hyperbolic cosecant|https://en.wikipedia.org/wiki/Hyperbolic_function>.

    say cosech(pi/2);           # OUTPUT: Â«0.434537208094696â¤Â»

=head2 routine acosech

Defined as:

    sub acosech(Numeric(Cool))
    method acosech()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Inverse hyperbolic cosecant|https://en.wikipedia.org/wiki/Inverse_hyperbolic_function>.

    say acosech(4.5);           # OUTPUT: Â«0.220432720979802â¤Â»

=head2 routine cotanh

Defined as:

    sub cotanh(Numeric(Cool))
    method cotanh()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Hyperbolic cotangent|https://en.wikipedia.org/wiki/Hyperbolic_function>.

    say cotanh(pi);             # OUTPUT: Â«1.00374187319732â¤Â»

=head2 routine acotanh

Defined as:

    sub acotanh(Numeric(Cool))
    method acotanh()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Inverse hyperbolic cotangent|https://en.wikipedia.org/wiki/Inverse_hyperbolic_function>.

    say acotanh(2.5);           # OUTPUT: Â«0.423648930193602â¤Â»

=head2 routine cis

Defined as:

    sub cis(Numeric(Cool))
    method cis()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns
L<cos(argument) + i*sin(argument)|https://en.wikipedia.org/wiki/Cis_%28mathematics%29>.

    say cis(pi/4);              # OUTPUT: Â«0.707106781186548+0.707106781186547iâ¤Â»

=head2 routine log

Defined as:

    multi sub log(Numeric(Cool) $number, Numeric(Cool) $base?)
    multi method log(Cool:D: Cool:D $base?)

Coerces the arguments (including the invocant in the method form) to
L<Numeric|/type/Numeric>, and returns its
L<Logarithm|https://en.wikipedia.org/wiki/Logarithm> to base C<$base>, or to
base C<e> (Euler's Number) if no base was supplied
(L<Natural logarithm|https://en.wikipedia.org/wiki/Natural_logarithm>).
Returns C<NaN> if C<$base> is negative. Throws an exception if C<$base> is C<1>.

    say (e*e).log;              # OUTPUT: Â«2â¤Â»

=head2 routine log10

Defined as:

    multi sub log10(Cool(Numeric))
    multi method log10()

Coerces the invocant (or in the sub form, the invocant) to
L<Numeric|/type/Numeric>, and returns its
L<Logarithm|https://en.wikipedia.org/wiki/Logarithm> to base 10, that is, a
number that approximately produces the original number when raised to the power
of 10. Returns C<NaN> for negative arguments and C<-Inf> for C<0>.

    say log10(1001);            # OUTPUT: Â«3.00043407747932â¤Â»

=head2 method log2

Defined as:

    multi method log2()

Coerces the invocant to L<Numeric|/type/Numeric>, and returns its
L<Logarithm|https://en.wikipedia.org/wiki/Logarithm> to base 2, that is, a
number that approximately produces the original number when raised to the power
of 2. Returns C<NaN> for negative arguments and C<-Inf> for C<0>.

    say log2(5);            # OUTPUT: Â«2.321928094887362â¤Â»
    say "4".log2;           # OUTPUT: Â«2â¤Â»

=head2 routine exp

Defined as:

    multi sub exp(Cool:D $pow, Cool:D $base?)
    multi method exp(Cool:D: Cool:D $base?)

Coerces the arguments (including the invocant in the method from) to L<Numeric|/type/Numeric>, and returns C<$base>
raised to the power of the first number. If no C<$base> is supplied, C<e> (Euler's
Number) is used.

    say 0.exp;      # OUTPUT: Â«1â¤Â»
    say 1.exp;      # OUTPUT: Â«2.71828182845905â¤Â»
    say 10.exp;     # OUTPUT: Â«22026.4657948067â¤Â»

=head2 method unpolar

Defined as:

    method unpolar(Numeric(Cool))

Coerces the arguments (including the invocant in the method form) to L<Numeric|/type/Numeric>, and returns
a complex number from the given polar coordinates. The invocant (or the first argument in sub form) is the magnitude while
the argument (i.e. the second argument in sub form) is the angle. The angle is assumed to be in radians.

    say sqrt(2).unpolar(pi/4);      # OUTPUT: Â«1+1iâ¤Â»

=head2 routine round

Defined as:

    multi sub round(Numeric(Cool), $scale = 1)
    multi method round(Cool:D: $scale = 1)

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and rounds it to the unit of
C<$scale>. If C<$scale> is 1, rounds to the nearest integer; an arbitrary scale will result in the closest
multiple of that number.

    say 1.7.round;          # OUTPUT: Â«2â¤Â»
    say 1.07.round(0.1);    # OUTPUT: Â«1.1â¤Â»
    say 21.round(10);       # OUTPUT: Â«20â¤Â»
    say round(1000, 23.01)  # OUTPUT: Â«989.43Â»

Always rounds B<up> if the number is at mid-point:

    say (âˆ’.5 ).round;       # OUTPUT: Â«0â¤Â»
    say ( .5 ).round;       # OUTPUT: Â«1â¤Â»
    say (âˆ’.55).round(.1);   # OUTPUT: Â«-0.5â¤Â»
    say ( .55).round(.1);   # OUTPUT: Â«0.6â¤Â»

B<Pay attention> to types when using this method, as ending up with the wrong type may
affect the precision you seek to achieve. For L<Real|/type/Real> types, the type of the result
is the type of the argument (L<Complex|/type/Complex> argument gets coerced to L<Real|/type/Real>, ending up a L<Num|/type/Num>).
If rounding a L<Complex|/type/Complex>, the result is L<Complex|/type/Complex> as well, regardless of the type of the argument.

    9930972392403501.round(1)      .raku.say; # OUTPUT: Â«9930972392403501â¤Â»
    9930972392403501.round(1e0)    .raku.say; # OUTPUT: Â«9.9309723924035e+15â¤Â»
    9930972392403501.round(1e0).Int.raku.say; # OUTPUT: Â«9930972392403500â¤Â»

=head2 routine floor

Defined as:

    multi sub floor(Numeric(Cool))
    multi method floor

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and rounds it downwards to
the nearest integer.

    say "1.99".floor;       # OUTPUT: Â«1â¤Â»
    say "-1.9".floor;       # OUTPUT: Â«-2â¤Â»
    say 0.floor;            # OUTPUT: Â«0â¤Â»

=head2 method fmt

Defined as:

    method fmt($format = '%s')

Uses C<$format> to return a formatted representation of the invocant; equivalent
to calling L<sprintf|/routine/sprintf> with C<$format> as format and the
invocant as the second argument. The C<$format> will be coerced to
L<Stringy|/type/Stringy> and defaults to C<'%s'>.

For more information about formats strings, see L<sprintf|/routine/sprintf>.

    say 11.fmt('This Int equals %03d');         # OUTPUT: Â«This Int equals 011â¤Â»
    say '16'.fmt('Hexadecimal %x');             # OUTPUT: Â«Hexadecimal 10â¤Â»

=head2 routine ceiling

Defined as:

    multi sub ceiling(Numeric(Cool))
    multi method ceiling

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>,
and rounds it upwards to the nearest integer.

    say "1".ceiling;        # OUTPUT: Â«1â¤Â»
    say "-0.9".ceiling;     # OUTPUT: Â«0â¤Â»
    say "42.1".ceiling;     # OUTPUT: Â«43â¤Â»

=head2 routine truncate

Defined as:

    multi sub truncate(Numeric(Cool))
    multi method truncate()

Coerces the invocant (or in sub form, its argument) to
L<Numeric|/type/Numeric>, and rounds it towards zero.

    say 1.2.truncate;       # OUTPUT: Â«1â¤Â»
    say truncate -1.2;      # OUTPUT: Â«-1â¤Â»

=head2 routine ord

Defined as:

    sub ord(Str(Cool))
    method ord()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and
returns the L<Unicode code point|https://en.wikipedia.org/wiki/Code_point>
number of the first code point.

    say 'a'.ord;            # OUTPUT: Â«97â¤Â»

The inverse operation is L<chr|/routine/chr>.

Mnemonic: returns an ordinal number

=head2 method path

Defined as:

    method path()

B<DEPRECATED>. I<It's been deprecated as of the 6.d version. Will be removed in
the next ones.>

Stringifies the invocant and converts it to L<IO::Path|/type/IO::Path> object.
Use the LÂ«C<.IO method>|/routine/IOÂ» instead.

=head2 routine chr

Defined as:

    sub chr(Int(Cool))
    method chr()

Coerces the invocant (or in sub form, its argument) to L<Int|/type/Int>,
interprets it as a
L<Unicode code points|https://en.wikipedia.org/wiki/Code_point>, and returns a
L<string|/type/Str> made of that code point.

    say '65'.chr;       # OUTPUT: Â«Aâ¤Â»

The inverse operation is L<ord|/routine/ord>.

Mnemonic: turns an integer into a I<char>acter.

=head2 routine chars

Defined as:

    multi sub chars(Cool $x)
    multi sub chars(Str:D $x)
    multi sub chars(str $x --> int)
    method chars(--> Int:D)

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and
returns the number of characters in the string. Please note that on the JVM, you
currently get codepoints instead of graphemes.

    say 'mÃ¸p'.chars;    # OUTPUT: Â«3â¤Â»
    say 'Ã£Ì·Ì Ì¬ÌŠ'.chars;     # OUTPUT: Â«1â¤Â»
    say 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ğŸ¿'.chars;    # OUTPUT: Â«1â¤Â»

If the string is native, the number of chars will be also returned as a native
C<int>.

X<|Grapheme>

Graphemes are user visible characters. That is, this is what the user
thinks of as a â€œcharacterâ€.

Graphemes can contain more than one
codepoint. Typically the number of graphemes and codepoints differs
when C<Prepend> or C<Extend> characters are involved (also known as
L<Combining characters|https://en.wikipedia.org/wiki/Combining_character>), but
there are many other cases when this may happen. Another example is C<\c[ZWJ]>
(L<Zero-width joiner|https://en.wikipedia.org/wiki/Zero-width_joiner>).

You can check C<Grapheme_Cluster_Break> property of a character in
order to see how it is going to behave:

    say â€˜Ã£Ì·Ì Ì¬ÌŠâ€™.uniprops(â€˜Grapheme_Cluster_Breakâ€™); # OUTPUT: Â«(Other Extend Extend Extend Extend)â¤Â»
    say â€˜ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ğŸ¿â€™.uniprops(â€˜Grapheme_Cluster_Breakâ€™); # OUTPUT: Â«(E_Base_GAZ ZWJ E_Base_GAZ ZWJ E_Base_GAZ ZWJ E_Base_GAZ E_Modifier)â¤Â»

You can read more about graphemes in the
L<Unicode Standard|https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries>,
which Raku tightly follows, using a method called L<NFG, normal form graphemes|/language/glossary#NFG> for efficiently representing them.

=head2 routine codes

Defined as:

    sub codes(Str(Cool))
    method codes()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and
returns the number of L<Unicode code points|https://en.wikipedia.org/wiki/Code_point>.

    say 'mÃ¸p'.codes;    # OUTPUT: Â«3â¤Â»

The same result will be obtained with

    say +'mÃ¸p'.ords;    # OUTPUT: Â«3â¤Â»

L<ords|/routine/ords> first obtains the actual codepoints, so there might be a difference in speed.

=head2 routine flip

Defined as:

    sub flip(Cool $s --> Str:D)
    method flip()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and
returns a reversed version.

    say 421.flip;       # OUTPUT: Â«124â¤Â»

=head2 routine trim

Defined as:

    sub trim(Str(Cool))
    method trim()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and
returns the string with both leading and trailing whitespace stripped.

    my $stripped = '  abc '.trim;
    say "<$stripped>";          # OUTPUT: Â«<abc>â¤Â»

=head2 routine trim-leading

Defined as:

    sub trim-leading(Str(Cool))
    method trim-leading()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and
returns the string with leading whitespace stripped.

    my $stripped = '  abc '.trim-leading;
    say "<$stripped>";          # OUTPUT: Â«<abc >â¤Â»

=head2 routine trim-trailing

Defined as:

    sub trim-trailing(Str(Cool))
    method trim-trailing()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and
returns the string with trailing whitespace stripped.

    my $stripped = '  abc '.trim-trailing;
    say "<$stripped>";          # OUTPUT: Â«<  abc>â¤Â»

=head2 routine lc

Defined as:

    sub lc(Str(Cool))
    method lc()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and
returns it case-folded to lower case.

    say "ABC".lc;       # OUTPUT: Â«abcâ¤Â»

=head2 routine uc

Defined as:

    sub uc(Str(Cool))
    method uc()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and
returns it case-folded to upper case (capital letters).

    say "Abc".uc;       # OUTPUT: Â«ABCâ¤Â»

=head2 routine fc

Defined as:

    sub fc(Str(Cool))
    method fc()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and
returns the result a Unicode "case fold" operation suitable for doing caseless
string comparisons. (In general, the returned string is unlikely to be useful
for any purpose other than comparison.)

    say "groÃŸ".fc;       # OUTPUT: Â«grossâ¤Â»

=head2 routine tc

Defined as:

    sub tc(Str(Cool))
    method tc()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and
returns it with the first letter case-folded to title case (or where not
available, upper case).

    say "abC".tc;       # OUTPUT: Â«AbCâ¤Â»

=head2 routine tclc

Defined as:

    sub tclc(Str(Cool))
    method tclc()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and returns it with the first letter
case-folded to title case (or where not available, upper case), and the rest
of the string case-folded to lower case.

    say 'abC'.tclc;     # OUTPUT: Â«Abcâ¤Â»

=head2 routine wordcase

Defined as:

    sub wordcase(Str(Cool) $input, :&filter = &tclc, Mu :$where = True)
    method wordcase(:&filter = &tclc, Mu :$where = True)

Coerces the invocant (or in sub form, the first argument) to L<Str|/type/Str>, and filters each word that
smartmatches against C<$where> through the C<&filter>. With the default
filter (first character to upper case, rest to lower) and matcher (which
accepts everything), this title-cases each word:

    say "raku programming".wordcase;        # OUTPUT: Â«Raku Programmingâ¤Â»

With a matcher:

    say "have fun working on raku".wordcase(:where({ .chars > 3 }));
                                            # Have fun Working on Raku

With a customer filter too:

    say "have fun working on raku".wordcase(:filter(&uc), :where({ .chars > 3 }));
                                            # HAVE fun WORKING on RAKU

=head2 routine samecase

Defined as:

    sub samecase(Cool $string, Cool $pattern)
    method samecase(Cool:D: Cool $pattern)

Coerces the invocant (or in sub form, the first argument) to L<Str|/type/Str>,
and returns a copy of C<$string> with case information for each individual
character changed according to C<$pattern>.

B<Note>: The pattern string can contain
three types of characters, i.e. uppercase, lowercase and caseless. For a given
character in C<$pattern> its case information determines the case of the
corresponding character in the result.

If C<$string> is longer than
C<$pattern>, the case information from the last character of C<$pattern> is
applied to the remaining characters of C<$string>.

    say "raKu".samecase("A_a_"); # OUTPUT: Â«Rakuâ¤Â»
    say "rAKU".samecase("Ab");   # OUTPUT: Â«Rakuâ¤Â»

=head2 routine uniprop

Defined as:

    multi sub uniprop(Str:D, |c)
    multi sub uniprop(Int:D $code)
    multi sub uniprop(Int:D $code, Stringy:D $propname)
    multi method uniprop(|c)

Returns the L<unicode property|http://userguide.icu-project.org/strings/properties>
of the first character. If no property is specified returns the
L<General Category|https://en.wikipedia.org/wiki/Unicode_character_property#General_Category>.
Returns a Bool for Boolean properties. A L<uniprops|/routine/uniprops> routine can be used
to get the property for every character in a string.

    say 'a'.uniprop;               # OUTPUT: Â«Llâ¤Â»
    say '1'.uniprop;               # OUTPUT: Â«Ndâ¤Â»
    say 'a'.uniprop('Alphabetic'); # OUTPUT: Â«Trueâ¤Â»
    say '1'.uniprop('Alphabetic'); # OUTPUT: Â«Falseâ¤Â»

=head2 sub uniprops

Defined as:

    sub uniprops(Str:D $str, Stringy:D $propname = "General_Category")

Interprets the invocant as a L<Str|/type/Str>, and returns the
L<unicode property|http://userguide.icu-project.org/strings/properties> for each character
as a Seq. If no property is specified returns the
L<General Category|https://en.wikipedia.org/wiki/Unicode_character_property#General_Category>.
Returns a Bool for Boolean properties. Similar to
L<uniprop|/routine/uniprop>, but for each character in the passed
string.

=head2 routine uniname

Defined as:

    sub uniname(Str(Cool) --> Str)
    method uniname(--> Str)

Interprets the invocant or first argument as a L<Str|/type/Str>, and returns the
Unicode codepoint name of the first codepoint of the first character. See
L<uninames|/routine/uninames> for a routine that works with multiple
codepoints, and L<uniparse|/routine/uniparse> for the opposite direction.

    # Camelia in Unicode
    say â€˜Â»Ã¶Â«â€™.uniname;
    # OUTPUT: Â«"RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK"â¤Â»
    say "á¸ŒÌ‡".uniname; # Note, doesn't show "COMBINING DOT ABOVE"
    # OUTPUT: Â«"LATIN CAPITAL LETTER D WITH DOT BELOW"â¤Â»

    # Find the char with the longest Unicode name.
    say (0..0x1FFFF).sort(*.uniname.chars)[*-1].chr.uniname;
    # OUTPUT: Â«Â«ARABIC LIGATURE UIGHUR KIRGHIZ YEH WITH HAMZA ABOVE WITH ALEF MAKSURA INITIAL FORMâ¤Â»â¤Â»

=head2 routine uninames

Defined as:

    sub uninames(Str:D)
    method uninames()

Returns of a Seq of Unicode names for the all the codepoints in the Str
provided.

    say â€˜Â»Ã¶Â«â€™.uninames.raku;
    # OUTPUT: Â«("RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK", "LATIN SMALL LETTER O WITH DIAERESIS", "LEFT-POINTING DOUBLE ANGLE QUOTATION MARK").Seqâ¤Â»

Note this example, which gets a Seq where each element is a Seq of all the
codepoints in that character.

    say "á¸ŒÌ‡'oh".comb>>.uninames.raku;
    # OUTPUT: Â«(("LATIN CAPITAL LETTER D WITH DOT BELOW", "COMBINING DOT ABOVE").Seq, ("APOSTROPHE",).Seq, ("LATIN SMALL LETTER O",).Seq, ("LATIN SMALL LETTER H",).Seq)â¤Â»

See L<uniparse|/routine/uniparse> for the opposite direction.

=head2 routine unimatch

Defined as:

    multi sub unimatch(Str:D $str, |c)
    multi sub unimatch(Int:D $code, Stringy:D $pvalname, Stringy:D $propname = $pvalname)

Checks if the given integer codepoint or the first letter of the given string
has a unicode property equal to the value you give. If you supply the Unicode
property to be checked it will only return True if that property matches the
given value.

    say unimatch 'A', 'Latin';           # OUTPUT: Â«Trueâ¤Â»
    say unimatch 'A', 'Latin', 'Script'; # OUTPUT: Â«Trueâ¤Â»
    say unimatch 'A', 'Ll';              # OUTPUT: Â«Falseâ¤Â»

The last property corresponds to "lowercase letter", which explains why it
returns false.

=head2 routine chop

Defined as:

    sub chop(Str(Cool))
    method chop()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and
returns it with the last character removed.

    say 'raku'.chop;                        # OUTPUT: Â«rakâ¤Â»

=head2 routine chomp

Defined as:

    sub chomp(Str(Cool))
    method chomp()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and
returns it with the last character removed, if it is a logical newline.

    say 'ab'.chomp.chars;                   # OUTPUT: Â«2â¤Â»
    say "a\n".chomp.chars;                  # OUTPUT: Â«1â¤Â»

=head2 routine substr

Defined as:

    sub substr(Str(Cool) $str, |c)
    method substr(|c)

Coerces the invocant (or in the sub form, the first argument) to
L<Str|/type/Str>, and calls L<Str.substr|/type/Str#routine_substr> with
the arguments.

=head2 routine substr-rw

Defined as:

    multi method substr-rw(|) is rw
    multi sub substr-rw(|) is rw

Coerces the invocant (or in the sub form, the first argument) to
L<Str|/type/Str>, and calls L<Str.substr-rw|/type/Str#method_substr-rw> with
the arguments.

=head2 routine ords

Defined as:

    sub ords(Str(Cool) $str)
    method ords()

Coerces the invocant (or in the sub form, the first argument) to
L<Str|/type/Str>, and returns a list of Unicode codepoints for each character.

    say "Camelia".ords;              # OUTPUT: Â«67 97 109 101 108 105 97â¤Â»
    say ords 10;                     # OUTPUT: Â«49 48â¤Â»

This is the list-returning version of L<ord|/routine/ord>. The inverse operation in
L<chrs|/routine/chrs>. If you are only interested in the number of codepoints,
L<codes|/routine/codes> is a possibly faster option.

=head2 routine chrs

Defined as:

    sub chrs(*@codepoints --> Str:D)
    method chrs()

Coerces the invocant (or in the sub form, the argument list) to a list of
integers, and returns the string created by interpreting each integer as a
Unicode codepoint, and joining the characters.

    say <67 97 109 101 108 105 97>.chrs;   # OUTPUT: Â«Cameliaâ¤Â»

This is the list-input version of L<chr|/routine/chr>. The inverse operation is L<ords|/routine/ords>.

=head2 routine split

Defined as:

    multi sub    split(  Str:D $delimiter, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
    multi sub    split(Regex:D $delimiter, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
    multi sub    split(@delimiters, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
    multi method split(  Str:D $delimiter, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
    multi method split(Regex:D $delimiter, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
    multi method split(@delimiters, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)

N<IÂ«the L<comb|/routine/comb> routine is a much better choice for many tasks that in other
languages are handled by the C<split>.Â»>

Coerces the invocant (or in the sub form, the second argument) to
L<Str|/type/Str>, splits it into pieces based on delimiters found in the
string and returns the result as a LÂ«C<Seq>|/type/SeqÂ».

If C<$delimiter> is a string, it is searched for literally and not treated
as a regex. You can also provide multiple delimiters by specifying them as a
list, which can mix C<Cool> and C<Regex> objects.

    say split(';', "a;b;c").raku;               # OUTPUT: Â«("a", "b", "c").Seqâ¤Â»
    say split(';', "a;b;c", 2).raku;            # OUTPUT: Â«("a", "b;c").Seqâ¤Â»

    say split(';', "a;b;c,d").raku;             # OUTPUT: Â«("a", "b", "c,d").Seqâ¤Â»
    say split(/\;/, "a;b;c,d").raku;            # OUTPUT: Â«("a", "b", "c,d").Seqâ¤Â»
    say split(/<[;,]>/, "a;b;c,d").raku;        # OUTPUT: Â«("a", "b", "c", "d").Seqâ¤Â»

    say split(['a', /b+/, 4], '1a2bb345').raku; # OUTPUT: Â«("1", "2", "3", "5").Seqâ¤Â»

By default, C<split> omits the matches, and returns a list of only those parts of
the string that did not match. Specifying one of the C<:k, :v, :kv, :p> adverbs
changes that. Think of the matches as a list that is interleaved with the
non-matching parts.

The C<:v> interleaves the values of that list, which will be either
L<Match|/type/Match> objects, if a L<Regex|/type/Regex> was used as a matcher
in the split, or L<Str|/type/Str> objects, if a L<Cool|/type/Cool> was used
as matcher. If multiple delimiters are specified, L<Match|/type/Match> objects
will be generated for all of them, unless B<all> of the delimiters are
L<Cool|/type/Cool>.

    say 'abc'.split(/b/, :v);               # OUTPUT: Â«(a ï½¢bï½£ c)â¤Â»
    say 'abc'.split('b', :v);               # OUTPUT: Â«(a b c)â¤Â»

C<:k> interleaves the keys, that is, the indexes:

    say 'abc'.split(/b/, :k);               # OUTPUT: Â«(a 0 c)â¤Â»

C<:kv> adds both indexes and matches:

    say 'abc'.split(/b/, :kv);               # OUTPUT: Â«(a 0 ï½¢bï½£ c)â¤Â»

and C<:p> adds them as L<Pairs|/type/Pair>, using the same types for
values as C<:v> does:

    say 'abc'.split(/b/, :p);               # OUTPUT: Â«(a 0 => ï½¢bï½£ c)â¤Â»
    say 'abc'.split('b', :p);               # OUTPUT: Â«(a 0 => b c)â¤Â»

You can only use one of the C<:k, :v, :kv, :p> adverbs in a single call
to C<split>.

Note that empty chunks are not removed from the result list.
For that behavior, use the C<:skip-empty> named argument:

    say ("f,,b,c,d".split: /","/             ).raku;  # OUTPUT: Â«("f", "", "b", "c", "d").Seqâ¤Â»
    say ("f,,b,c,d".split: /","/, :skip-empty).raku;  # OUTPUT: Â«("f", "b", "c", "d").Seqâ¤Â»

=head2 routine lines

Defined as:

    sub lines(Str(Cool))
    method lines()

Coerces the invocant (and in sub form, the argument) to L<Str|/type/Str>,
decomposes it into lines (with the newline characters stripped), and returns
the list of lines.

    say lines("a\nb\n").join('|');          # OUTPUT: Â«a|bâ¤Â»
    say "some\nmore\nlines".lines.elems;    # OUTPUT: Â«3â¤Â»


This method can be used as part of an LÂ«C<IO::Path>|/type/IO::PathÂ»
to process a file line-by-line, since C<IO::Path> objects inherit from
C<Cool>, e.g.:

=begin code
for 'huge-csv'.IO.lines -> $line {
    # Do something with $line
}

# or if you'll be processing later
my @lines = 'huge-csv'.IO.lines;
=end code

Without any arguments, sub C<lines> operates on
LÂ«C<$*ARGFILES>|/language/variables#$*ARGFILESÂ».

To modify values in place use LÂ«C<is
copy>|/type/Signature#index-entry-trait_is_copyÂ» to force a writable
container.

=for code
for $*IN.lines -> $_ is copy { s/(\w+)/{$0 ~ $0}/; .say }

=head2 method words

Defined as:

    method words(Cool:D: |c)

Coerces the invocant (or first argument, if it is called as a subroutine) to
L<Str|/type/Str>, and returns a list of words that make up the string. Check
L<C<Str.words>|/type/Str#routine_words> for additional arguments and its
meaning.

=for code
say <The quick brown fox>.words.join('|');     # OUTPUT: Â«The|quick|brown|foxâ¤Â»
say <The quick brown fox>.words(2).join('|');  # OUTPUT: Â«The|quickâ¤Â»

C<Cool> is the base class for many other classes, and some of them, like
L<Match|/type/Match>, can be converted to a string. This is what happens in this case:

    say ( "easy come, easy goes" ~~ m:g/(ea\w+)/).words(Inf);
    # OUTPUT: Â«(easy easy)â¤Â»
    say words( "easy come, easy goes" ~~ m:g/(ea\w+)/ , âˆ);
    # OUTPUT: Â«(easy easy)â¤Â»

The example above illustrates two of the ways C<words> can be invoked, with the
first argument turned into invocant by its signature. Of course, C<Inf> is the
default value of the second argument, so in both cases (and forms) it can be
simply omitted.

Only whitespace (including no-break space) counts as word boundaries

    say <Flying on a BoeingÂ 747>.words.join('|');  # OUTPUT: Â«Flying|on|a|Boeing|747â¤Â»

In this case, "BoeingÂ 747" includes a (visible only in the source) no-break space;
C<words> still splits the (resulting) C<Str> on it, even if the original array
only had 4 elements:

    say <Flying on a BoeingÂ 747>.join('|');        # OUTPUT: Â«Flying|on|a|BoeingÂ 747â¤Â»

Please see L<C<Str.words>|/type/Str#routine_words> for more examples and ways to
invoke it.

=head2 routine comb

Defined as:

    multi sub comb(Regex $matcher, Cool $input, $limit = *)
    multi sub comb(Str $matcher, Cool $input, $limit = *)
    multi sub comb(Int:D $size, Cool $input, $limit = *)
    multi method comb(|c)

Returns a L<Seq|/type/Seq> of all (or if supplied, at most C<$limit>) matches of the
invocant (method form) or the second argument (sub form) against the
L<Regex|/type/Regex>, string or defined number.

    say "6 or 12".comb(/\d+/).join(", ");           # OUTPUT: Â«6, 12â¤Â»
    say comb(/\d <[1..9]> /,(11..30)).join("--");
    # OUTPUT:
    # Â«11--12--13--14--15--16--17--18--19--21--22--23--24--25--26--27--28--29â¤Â»

The second statement exemplifies the first form of C<comb>, with a C<Regex> that
excludes multiples of ten, and a C<Range> (which is C<Cool>) as C<$input>.
C<comb> stringifies the C<Range> before applying C<.comb> on the resulting
string. Check L<C<Str.comb>|/type/Str#routine_comb> for its effect on different
kind of input strings. When the first argument is an integer, it indicates the
(maximum) size of the chunks the input is going to be divided in

    say comb(3,[3,33,333,3333]).join("*");  # OUTPUT: Â«3 3*3 3*33 *333*3â¤Â»

In this case the input is a list, which after transformation to C<Str> (which
includes the spaces) is divided in chunks of size 3.

=head2 method contains

Defined as:

    method contains(Cool:D: |c)

Coerces the invocant to a L<C<Str>|/type/Str>, and calls
L<C<Str.contains>|/type/Str#method_contains> on it. Please refer to
that version of the method for arguments and general syntax.

    say 123.contains("2")# OUTPUT: Â«Trueâ¤Â»

Since L<Int|/type/Int> is a subclass of C<Cool>, C<123> is coerced to a C<Str> and
then C<contains> is called on it.

    say (1,1, * + * â€¦ * > 250).contains(233)# OUTPUT: Â«Trueâ¤Â»

L<Seq|/type/Seq>s are also subclasses of C<Cool>, and they are stringified to a
comma-separated form. In this case we are also using an C<Int>, which is
going to be stringified also; C<"233"> is included in that sequence, so
it returns C<True>. Please note that this sequence is not lazy; the
stringification of lazy sequences does not include each and every one of
their components for obvious reasons.

=head2 routine index

Defined as:

    multi sub index(Cool:D $s, Cool:D $needle, :i(:$ignorecase), :m(:$ignoremark) --> Int:D)
    multi sub index(Cool:D $s, Cool:D $needle, Cool:D $pos, :i(:$ignorecase), :m(:$ignoremark) --> Int:D)
    multi method index(Cool:D: Cool:D $needle --> Int:D)
    multi method index(Cool:D: Cool:D $needle, :m(:$ignoremark)! --> Int:D)
    multi method index(Cool:D: Cool:D $needle, :i(:$ignorecase)!, :m(:$ignoremark) --> Int:D)
    multi method index(Cool:D: Cool:D $needle, Cool:D $pos --> Int:D)
    multi method index(Cool:D: Cool:D $needle, Cool:D $pos, :m(:$ignoremark)!  --> Int:D)
    multi method index(Cool:D: Cool:D $needle, Cool:D $pos, :i(:$ignorecase)!, :m(:$ignoremark) --> Int:D)

Coerces the first two arguments (in method form, also counting the invocant) to
a L<Str|/type/Str>, and searches for C<$needle> in the string C<$s> starting
from C<$pos>. It returns the offset into the string where C<$needle> was
found, and C<Nil> if it was not found.

See L<the documentation in type Str|/type/Str#method_index> for examples.

=head2 routine rindex

Defined as:

    multi sub rindex(Cool:D $s, Cool:D $needle --> Int:D)
    multi sub rindex(Cool:D $s, Cool:D $needle, Cool:D $pos --> Int:D)
    multi method rindex(Cool:D: Cool:D $needle --> Int:D)
    multi method rindex(Cool:D: Cool:D $needle, Cool:D $pos --> Int:D)

Coerces the first two arguments (including the invocant in method form) to
L<Str|/type/Str> and C<$pos> to L<Int|/type/Int>, and returns the last
position of C<$needle> in the string not after C<$pos>. Returns C<Nil>
if C<$needle> wasn't found.

See L<the documentation in type Str|/type/Str#routine_rindex> for examples.

=head2 method match

Defined as:

    method match(Cool:D: $target, *%adverbs)

Coerces the invocant to L<Stringy|/type/Stringy> and calls the method
L<match|/type/Str#method_match> on it.

=head2 routine roots

Defined as:

    multi sub roots(Numeric(Cool) $x, Int(Cool) $n)
    multi method roots(Int(Cool) $n)

Coerces the first argument (and in method form, the invocant) to
L<Numeric|/type/Numeric> and the second (C<$n>) to L<Int|/type/Int>, and
produces a list of C<$n> L<Complex|/type/Complex> C<$n>-roots, which means
numbers that, raised to the C<$n>th power, approximately produce the original
number.

For example

=begin code
my $original = 16;
my @roots = $original.roots(4);
say @roots;

for @roots -> $r {
    say abs($r ** 4 - $original);
}

# OUTPUT:Â«2+0i 1.22464679914735e-16+2i -2+2.44929359829471e-16i -3.67394039744206e-16-2iâ¤Â»
# OUTPUT:Â«1.77635683940025e-15â¤Â»
# OUTPUT:Â«4.30267170434156e-15â¤Â»
# OUTPUT:Â«8.03651692704705e-15â¤Â»
# OUTPUT:Â«1.04441561648202e-14â¤Â»
=end code

=head2 method subst

Defined as:

    method subst(|)

Coerces the invocant to L<Stringy|/type/Stringy> and calls L<Str.subst|/type/Str#method_subst>.

=head2 method trans

Defined as:

    method trans(|)

Coerces the invocant to L<Str|/type/Str> and calls L<Str.trans|/type/Str#method_trans>

=head2 method IO

Defined as:

    method IO(--> IO::Path:D)

Coerces the invocant to L<IO::Path|/type/IO::Path>.

=for code
.say for '.'.IO.dir;        # gives a directory listing


=end pod

# vim: expandtab softtabstop=4 shiftwidth=4 ft=perl6
