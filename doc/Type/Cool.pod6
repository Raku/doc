=begin pod

=TITLE class Cool

=SUBTITLE Object that can be treated as both a string and number

    class Cool is Any { }

C<Cool>, also known as the B<C>onvenient B<OO> B<L>oop, is a base class employed
by a number of built-in classes whose instances can be meaningfully coerced to a
string and a number. For example, an L<Array|/type/Array> can be used in
mathematical operations, where its numerical representation is the number of
elements it contains. At the same time, it can be concatenated to a string,
where its stringy representation is all of its elements L<joined|/routine/join>
by a space. Because L<Array|/type/Array> is L<Cool|/type/Cool>, the appropriate
coercion happens automatically.

Methods in C<Cool> coerce the invocant to a more specific type, and then call
the same method on that type. For example both L<Int|/type/Int> and
L<Str|/type/Str> inherit from C<Cool>, and calling method C<substr> on an C<Int>
converts the integer to C<Str> first.

    123.substr(1, 1);   # '2', same as 123.Str.substr(1, 1)

The following built-in types inherit from C<Cool>: L<Array|/type/Array>
L<Bool|/type/Bool> L<Complex|/type/Complex> L<Cool|/type/Cool>
L<Duration|/type/Duration> L<Map|/type/Map> L<FatRat|/type/FatRat>
L<Hash|/type/Hash> L<Instant|/type/Instant> L<Int|/type/Int> L<List|/type/List>
L<Match|/type/Match> L<Nil|/type/Nil> L<Num|/type/Num> L<Range|/type/Range>
L<Seq|/type/Seq> L<Stash|/type/Stash> L<Str|/type/Str>.

The following table summarizes the methods that C<Cool> provides, and
what type they coerce to:

=begin table

    method          coercion type

    abs             Numeric
    conj            Numeric
    sqrt            Numeric
    sign            Real
    rand            Numeric
    sin             Numeric
    asin            Numeric
    cos             Numeric
    acos            Numeric
    tan             Numeric
    tanh            Numeric
    atan            Numeric
    atan2           Numeric
    atanh           Numeric
    sec             Numeric
    asec            Numeric
    cosec           Numeric
    acosec          Numeric
    cotan           Numeric
    cotanh          Numeric
    acotan          Numeric
    sinh            Numeric
    asinh           Numeric
    cosh            Numeric
    acosh           Numeric
    sech            Numeric
    asech           Numeric
    cosech          Numeric
    acosech         Numeric
    acotanh         Numeric
    cis             Numeric
    log             Numeric
    exp             Numeric
    roots           Numeric
    log10           Numeric
    unpolar         Numeric
    round           Numeric
    floor           Numeric
    ceiling         Numeric
    truncate        Numeric
    chr             Int
    ord             Str
    chars           Str
    fmt             Str
    uniname         Str
    uninames        Seq
    unival          Str
    univals         Str
    uniprop         Str
    unimatch        Str
    uc              Str
    lc              Str
    fc              Str
    tc              Str
    tclc            Str
    flip            Str
    trans           Str
    contains        Str
    index           Str
    rindex          Str
    ords            Str
    split           Str
    match           Str
    comb            Str
    subst           Str
    sprintf         Str
    printf          Str
    samecase        Str
    trim            Str
    trim-leading    Str
    trim-trailing   Str
    EVAL            Str
    chomp           Str
    chop            Str
    codes           Str

=end table

=head1 Methods

=head2 routine abs

Defined as:

    sub abs(Numeric() $x)
    method abs()

Coerces the invocant (or in the sub form, the argument) to
L<Numeric|/type/Numeric> and returns the absolute value (that is, a
non-negative number).

    say (-2).abs;       # OUTPUT: Â«2â¤Â»
    say abs "6+8i";     # OUTPUT: Â«10â¤Â»

=head2 method conj

Defined as:

    method conj()

Coerces the invocant to L<Numeric|/type/Numeric> and returns the
L<complex|/type/Complex> conjugate (that is, the number with the sign of the
imaginary part negated).

    say (1+2i).conj;        # OUTPUT: Â«1-2iâ¤Â»

=head2 routine sqrt

Defined as:

    sub sqrt(Numeric(Cool) $x)
    method sqrt()

Coerces the invocant to L<Numeric|/type/Numeric> (or in the sub form, the
argument) and returns the square root, that is, a non-negative number that, when
multiplied with itself, produces the original number.

    say 4.sqrt;             # OUTPUT: Â«2â¤Â»
    say sqrt(2);            # OUTPUT: Â«1.4142135623731â¤Â»

=head2 method sign

Defined as:

    method sign()

Coerces the invocant to L<Numeric|/type/Real> and returns its sign, that
is, 0 if the number is 0, 1 for positive and -1 for negative values.

    say 6.sign;             # OUTPUT: Â«1â¤Â»
    say (-6).sign;          # OUTPUT: Â«-1â¤Â»
    say "0".sign;           # OUTPUT: Â«0â¤Â»

=head2 method rand

Defined as:

    method rand()

Coerces the invocant to L<Num|/type/Num> and returns a pseudo-random value
between zero and the number.

    say 1e5.rand;           # OUTPUT: Â«33128.495184283â¤Â»

=head2 routine sin

Defined as:

    sub sin(Numeric(Cool))
    method sin()

Coerces the invocant (or in the sub form, the argument) to L<Numeric|/type/Numeric>, interprets it as radians,
returns its L<sine|https://en.wikipedia.org/wiki/Sine>.

    say sin(0);             # OUTPUT: Â«0â¤Â»
    say sin(pi/4);          # OUTPUT: Â«0.707106781186547â¤Â»
    say sin(pi/2);          # OUTPUT: Â«1â¤Â»

Note that PerlÂ 6 is no computer algebra system, so C<sin(pi)> typically does
not produce an exact 0, but rather a very small L<floating-point
number|/type/Num>.

=head2 routine asin

Defined as:

    sub asin(Numeric(Cool))
    method asin()

Coerces the invocant (or in the sub form, the argument) to
L<Numeric|/type/Numeric>, and returns its
L<arc-sine|https://en.wikipedia.org/wiki/Inverse_trigonometric_functions> in
radians.

    say 0.1.asin;               # OUTPUT: Â«0.10016742116156â¤Â»
    say asin(0.1);              # OUTPUT: Â«0.10016742116156â¤Â»

=head2 routine cos

Defined as:

    sub cos(Numeric(Cool))
    method cos()

Coerces the invocant (or in sub form, the argument) to L<Numeric|/type/Numeric>,
interprets it as radians, returns its
L<cosine|https://en.wikipedia.org/wiki/Cosine>.

    say 0.cos;                  # OUTPUT: Â«1â¤Â»
    say pi.cos;                 # OUTPUT: Â«-1â¤Â»
    say cos(pi/2);              # OUTPUT: Â«6.12323399573677e-17â¤Â»

=head2 routine acos

Defined as:

    sub acos(Numeric(Cool))
    method acos()

Coerces the invocant (or in sub form, the argument) to L<Numeric|/type/Numeric>, and returns its
L<arc-cosine|https://en.wikipedia.org/wiki/Inverse_trigonometric_functions> in
radians.

    say 1.acos;                 # OUTPUT: Â«0â¤Â»
    say acos(-1);               # OUTPUT: Â«3.14159265358979â¤Â»

=head2 routine tan

Defined as:

    sub tan(Numeric(Cool))
    method tan()

Coerces the invocant (or in sub form, the argument) to L<Numeric|/type/Numeric>, interprets it as radians,
returns its L<tangent|https://en.wikipedia.org/wiki/Tangent>.

    say tan(3);                 # OUTPUT: Â«-0.142546543074278â¤Â»
    say 3.tan;                  # OUTPUT: Â«-0.142546543074278â¤Â»

=head2 routine atan

Defined as:

    sub atan(Numeric(Cool))
    method atan()

Coerces the invocant (or in sub form, the argument) to L<Numeric|/type/Numeric>, and returns its
L<arc-tangent|https://en.wikipedia.org/wiki/Inverse_trigonometric_functions> in
radians.

    say atan(3);                # OUTPUT: Â«1.24904577239825â¤Â»
    say 3.atan;                 # OUTPUT: Â«1.24904577239825â¤Â»

=head2 routine atan2

Defined as:

    method atan2($y = 1e0)

Coerces self and argument to L<Numeric|/type/Numeric>, using them to compute the
two-argument L<arc-tangent|https://en.wikipedia.org/wiki/Atan2> in radians.

    say 3.atan2;                # OUTPUT: Â«1.24904577239825â¤Â»
    say â…”.atan2(â…“);             # OUTPUT: Â«1.1071487177940904â¤Â»

The first argument defaults to 1, so in the first case the function will return
the angle Î¸ in radians between a vector that goes from origin to the point (3, 1)
and the x axis.

=head2 routine sec

Defined as:

    sub sec(Numeric(Cool))
    method sec()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, interprets it as radians,
returns its L<secant|https://en.wikipedia.org/wiki/Trigonometric_functions#Reciprocal_functions>,
that is, the reciprocal of its cosine.

    say 45.sec;                 # OUTPUT: Â«1.90359440740442â¤Â»
    say sec(45);                # OUTPUT: Â«1.90359440740442â¤Â»

=head2 routine asec

Defined as:

    sub asec(Numeric(Cool))
    method asec()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>,
and returns its
L<arc-secant|https://en.wikipedia.org/wiki/Inverse_trigonometric_functions> in
radians.

    say 1.asec;                 # OUTPUT: Â«0â¤Â»
    say sqrt(2).asec;           # OUTPUT: Â«0.785398163397448â¤Â»

=head2 routine cosec

Defined as:

    sub cosec(Numeric(Cool))
    method cosec()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>,
interprets it as radians, returns its
L<cosecant|https://en.wikipedia.org/wiki/Trigonometric_functions#Reciprocal_functions>,
that is, the reciprocal of its sine.

    say 0.45.cosec;             # OUTPUT: Â«2.29903273150897â¤Â»
    say cosec(0.45);            # OUTPUT: Â«2.29903273150897â¤Â»

=head2 routine acosec

Defined as:

    sub acosec(Numeric(Cool))
    method acosec()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>,
and returns its
L<arc-cosecant|https://en.wikipedia.org/wiki/Inverse_trigonometric_functions> in
radians.

    say 45.acosec;              # OUTPUT: Â«0.0222240516182672â¤Â»
    say acosec(45)              # OUTPUT: Â«0.0222240516182672â¤Â»

=head2 routine cotan

Defined as:

    sub cotan(Numeric(Cool))
    method cotan()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>,
interprets it as radians, returns its
L<cotangent|https://en.wikipedia.org/wiki/Trigonometric_functions#Reciprocal_functions>,
that is, the reciprocal of its tangent.

    say 45.cotan;               # OUTPUT: Â«0.617369623783555â¤Â»
    say cotan(45);              # OUTPUT: Â«0.617369623783555â¤Â»

=head2 routine acotan

Defined as:

    sub acotan(Numeric(Cool))
    method acotan()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>,
and returns its
L<arc-cotangent|https://en.wikipedia.org/wiki/Inverse_trigonometric_functions>
in radians.

    say 45.acotan;              # OUTPUT: Â«0.0222185653267191â¤Â»
    say acotan(45)              # OUTPUT: Â«0.0222185653267191â¤Â»

=head2 routine sinh

Defined as:

    sub sinh(Numeric(Cool))
    method sinh()

Coerces the invocant (or in method form, its argument) to
L<Numeric|/type/Numeric>, and returns its
L<Sine hyperbolicus|https://en.wikipedia.org/wiki/Hyperbolic_function>.

    say 1.sinh;                 # OUTPUT: Â«1.1752011936438â¤Â»
    say sinh(1);                # OUTPUT: Â«1.1752011936438â¤Â»

=head2 routine asinh

Defined as:

    sub asinh(Numeric(Cool))
    method asinh()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Inverse Sine hyperbolicus|https://en.wikipedia.org/wiki/Inverse_hyperbolic_function>.

    say 1.asinh;                # OUTPUT: Â«0.881373587019543â¤Â»
    say asinh(1);               # OUTPUT: Â«0.881373587019543â¤Â»

=head2 routine cosh

Defined as:

    sub cosh(Numeric(Cool))
    method cosh()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Cosine hyperbolicus|https://en.wikipedia.org/wiki/Hyperbolic_function>.

    say cosh(0.5);              # OUTPUT: Â«1.12762596520638â¤Â»

=head2 routine acosh

Defined as:

    sub acosh(Numeric(Cool))
    method acosh()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Inverse Cosine hyperbolicus|https://en.wikipedia.org/wiki/Inverse_hyperbolic_function>.

    say acosh(45);              # OUTPUT: Â«4.4996861906715â¤Â»

=head2 routine tanh

Defined as:

    sub tanh(Numeric(Cool))
    method tanh()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, interprets it as
radians and returns its L<Tangent hyperbolicus|https://en.wikipedia.org/wiki/Hyperbolic_function>.

    say tanh(0.5);              # OUTPUT: Â«0.46211715726001â¤Â»
    say tanh(atanh(0.5));       # OUTPUT: Â«0.5â¤Â»

=head2 routine atanh

Defined as:

    sub atanh(Numeric(Cool))
    method atanh()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Inverse tangent hyperbolicus|https://en.wikipedia.org/wiki/Inverse_hyperbolic_function>.

    say atanh(0.5);             # OUTPUT: Â«0.549306144334055â¤Â»

=head2 routine sech

Defined as:

    sub sech(Numeric(Cool))
    method sech()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Secant hyperbolicus|https://en.wikipedia.org/wiki/Hyperbolic_function>.

    say 0.sech;                 # OUTPUT: Â«1â¤Â»

=head2 routine asech

Defined as:

    sub asech(Numeric(Cool))
    method asech()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Inverse hyperbolic secant|https://en.wikipedia.org/wiki/Hyperbolic_function>.

    say 0.8.asech;              # OUTPUT: Â«0.693147180559945â¤Â»

=head2 routine cosech

Defined as:

    sub cosech(Numeric(Cool))
    method cosech()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Hyperbolic cosecant|https://en.wikipedia.org/wiki/Hyperbolic_function>.

    say cosech(pi/2);           # OUTPUT: Â«0.434537208094696â¤Â»

=head2 routine acosech

Defined as:

    sub acosech(Numeric(Cool))
    method acosech()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Inverse hyperbolic cosecant|https://en.wikipedia.org/wiki/Inverse_hyperbolic_function>.

    say acosech(4.5);           # OUTPUT: Â«0.220432720979802â¤Â»

=head2 routine cotanh

Defined as:

    sub cotanh(Numeric(Cool))
    method cotanh()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Hyperbolic cotangent|https://en.wikipedia.org/wiki/Hyperbolic_function>.

    say cotanh(pi);             # OUTPUT: Â«1.00374187319732â¤Â»

=head2 routine acotanh

Defined as:

    sub acotanh(Numeric(Cool))
    method acotanh()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns its
L<Inverse hyperbolic cotangent|https://en.wikipedia.org/wiki/Inverse_hyperbolic_function>.

    say acotanh(2.5);           # OUTPUT: Â«0.423648930193602â¤Â»

=head2 routine cis

Defined as:

    sub cis(Numeric(Cool))
    method cis()

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and returns
L<cos(argument) + i*sin(argument)|https://en.wikipedia.org/wiki/Cis_%28mathematics%29>.

    say cis(pi/4);              # OUTPUT: Â«0.707106781186548+0.707106781186547iâ¤Â»

=head2 routine log

Defined as:

    multi sub log(Numeric(Cool) $number, Numeric(Cool) $base?)
    multi method log(Cool:D: Cool:D $base?)

Coerces the arguments (including the invocant in the method form) to
L<Numeric|/type/Numeric>, and returns its
L<Logarithm|https://en.wikipedia.org/wiki/Logarithm> to base C<$base>, or to
base C<e> (Euler's Number) if no base was supplied
(L<Natural logarithm|https://en.wikipedia.org/wiki/Natural_logarithm>).
Returns C<NaN> if C<$base> is negative. Throws an exception if C<$base> is C<1>.

    say (e*e).log;              # OUTPUT: Â«2â¤Â»

=head2 routine log10

Defined as:

    multi sub log10(Cool(Numeric))
    multi method log10()

Coerces the invocant (or in the sub form, the invocant) to
L<Numeric|/type/Numeric>, and returns its
L<Logarithm|https://en.wikipedia.org/wiki/Logarithm> to base 10, that is, a
number that approximately produces the original number when raised to the power
of 10. Returns C<NaN> for negative arguments and C<-Inf> for C<0>.

    say log10(1001);            # OUTPUT: Â«3.00043407747932â¤Â»

=head2 routine exp

Defined as:

    multi sub exp(Cool:D $pow, Cool:D $base?)
    multi method exp(Cool:D: Cool:D $base?)

Coerces the arguments (including the invocant in the method from) to L<Numeric|/type/Numeric>, and returns C<$base>
raised to the power of the first number. If no C<$base> is supplied, C<e> (Euler's
Number) is used.

    say 0.exp;      # OUTPUT: Â«1â¤Â»
    say 1.exp;      # OUTPUT: Â«2.71828182845905â¤Â»
    say 10.exp;     # OUTPUT: Â«22026.4657948067â¤Â»

=head2 method unpolar

Defined as:

    method unpolar(Numeric(Cool))

Coerces the arguments (including the invocant in the method form) to L<Numeric|/type/Numeric>, and returns
a complex number from the given polar coordinates. The invocant (or the first argument in sub form) is the magnitude while
the argument (i.e. the second argument in sub form) is the angle. The angle is assumed to be in radians.

    say sqrt(2).unpolar(pi/4);      # OUTPUT: Â«1+1iâ¤Â»

=head2 routine round

Defined as:

    multi sub round(Numeric(Cool))
    multi method round(Cool:D: $unit = 1)

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and rounds it to the unit of
C<$unit>. If C<$unit> is 1, rounds to the nearest integer.

    say 1.7.round;          # OUTPUT: Â«2â¤Â»
    say 1.07.round(0.1);    # OUTPUT: Â«1.1â¤Â»
    say 21.round(10);       # OUTPUT: Â«20â¤Â»

Always rounds B<up> if the number is at mid-point:

    say (âˆ’.5 ).round;       # OUTPUT: Â«0â¤Â»
    say ( .5 ).round;       # OUTPUT: Â«1â¤Â»
    say (âˆ’.55).round(.1);   # OUTPUT: Â«-0.5â¤Â»
    say ( .55).round(.1);   # OUTPUT: Â«0.6â¤Â»

B<Pay attention> to types when using this method, as ending up with the wrong type may
affect the precision you seek to achieve. For L<Real|/type/Real> types, the type of the result
is the type of the argument (L<Complex|/type/Complex> argument gets coerced to L<Real|/type/Real>, ending up a L<Num|/type/Num>).
If rounding a L<Complex|/type/Complex>, the result is L<Complex|/type/Complex> as well, regardless of the type of the argument.

    9930972392403501.round(1)      .perl.say; # OUTPUT: Â«9930972392403501â¤Â»
    9930972392403501.round(1e0)    .perl.say; # OUTPUT: Â«9.9309723924035e+15â¤Â»
    9930972392403501.round(1e0).Int.perl.say; # OUTPUT: Â«9930972392403500â¤Â»

=head2 routine floor

Defined as:

    multi sub floor(Numeric(Cool))
    multi method floor

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and rounds it downwards to
the nearest integer.

    say "1.99".floor;       # OUTPUT: Â«1â¤Â»
    say "-1.9".floor;       # OUTPUT: Â«-2â¤Â»
    say 0.floor;            # OUTPUT: Â«0â¤Â»

=head2 method fmt

Defined as:

    method fmt($format = '%s')

Equivalent to calling L<sprintf|/routine/sprintf> with C<$format> as format and
the invocant as the second argument. The C<$format> will be coerced to
L<Stringy|/type/Stringy> and defaults to C<'%s'>.

=head2 routine ceiling

Defined as:

    multi sub ceiling(Numeric(Cool))
    multi method ceiling

Coerces the invocant (or in sub form, its argument) to L<Numeric|/type/Numeric>, and rounds it upwards to
the nearest integer.

    say "1".ceiling;        # OUTPUT: Â«1â¤Â»
    say "-0.9".ceiling;     # OUTPUT: Â«0â¤Â»
    say "42.1".ceiling;     # OUTPUT: Â«43â¤Â»

=head2 routine truncate

Defined as:

    multi sub truncate(Numeric(Cool))
    multi method truncate()

Coerces the invocant (or in sub form, its argument) to
L<Numeric|/type/Numeric>, and rounds it towards zero.

    say 1.2.truncate;       # OUTPUT: Â«1â¤Â»
    say truncate -1.2;      # OUTPUT: Â«-1â¤Â»

=head2 routine ord

Defined as:

    sub ord(Str(Cool))
    method ord()

Coerces the invocant (or in sub form, its argument) to
L<Str|/type/Str>, and returns the L<Unicode code point|https://en.wikipedia.org/wiki/Code_point> number of the first
code point.

    say 'a'.ord;            # OUTPUT: Â«97â¤Â»

The inverse operation is L<chr|/routine/chr>.

Mnemonic: returns an ordinal number

=head2 method path

Defined as:

    method path()

B<DEPRECATED>. I<It's been deprecated as of the 6.d version. Will be removed in
the next ones.>

Stringifies the invocant and converts it to L<IO::Path> object.
Use the LÂ«C<.IO method>|/routine/IOÂ» instead.

=head2 routine chr

Defined as:

    sub chr(Int(Cool))
    method chr()

Coerces the invocant (or in sub form, its argument) to L<Int|/type/Int>,
interprets it as a
L<Unicode code points|https://en.wikipedia.org/wiki/Code_point>, and returns a
L<string|/type/Str> made of that code point.

    say '65'.chr;       # OUTPUT: Â«Aâ¤Â»

The inverse operation is L<ord|/routine/ord>.

Mnemonic: turns an integer into a I<char>acter.

=head2 routine chars

Defined as:

    sub chars(Str(Cool))
    method chars()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and returns the
number of characters in the string. Please note that on the JVM, you currently get
codepoints instead of graphemes.

    say 'mÃ¸p'.chars;    # OUTPUT: Â«3â¤Â»
    say 'Ã£Ì·Ì Ì¬ÌŠ'.chars;     # OUTPUT: Â«1â¤Â»
    say 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ğŸ¿'.chars;    # OUTPUT: Â«1â¤Â»

X<|Grapheme>

Graphemes are user visible characters. That is, this is what the user
thinks of as a â€œcharacterâ€.

Graphemes can contain more than one
codepoint. Typically the number of graphemes and codepoints differs
when C<Prepend> or C<Extend> characters are involved (also known as
L<Combining characters|https://en.wikipedia.org/wiki/Combining_character>), but
there are many other cases when this may happen. Another example is C<\c[ZWJ]>
(L<Zero-width joiner|https://en.wikipedia.org/wiki/Zero-width_joiner>).

You can check C<Grapheme_Cluster_Break> property of a character in
order to see how it is going to behave:

    say â€˜Ã£Ì·Ì Ì¬ÌŠâ€™.uniprops(â€˜Grapheme_Cluster_Breakâ€™); # OUTPUT: Â«(Other Extend Extend Extend Extend)â¤Â»
    say â€˜ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ğŸ¿â€™.uniprops(â€˜Grapheme_Cluster_Breakâ€™); # OUTPUT: Â«(E_Base_GAZ ZWJ E_Base_GAZ ZWJ E_Base_GAZ ZWJ E_Base_GAZ E_Modifier)â¤Â»

You can read more about graphemes in the
L<Unicode Standard|https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries>,
which PerlÂ 6 tightly follows, using a method called L<NFG, normal form graphemes|/language/glossary#NFG> for efficiently representing them.

=head2 routine codes

Defined as:

    sub codes(Str(Cool))
    method codes()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and returns the number of
L<Unicode code points|https://en.wikipedia.org/wiki/Code_point>.

    say 'mÃ¸p'.codes;    # OUTPUT: Â«3â¤Â»

The same result will be obtained with

    say +'mÃ¸p'.ords;    # OUTPUT: Â«3â¤Â»

L<ords|/routine/ords> first obtains the actual codepoints, so there might be a difference in speed.

=head2 routine flip

Defined as:

    sub flip(Str(Cool))
    method flip()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and returns a reversed version.

    say 421.flip;       # OUTPUT: Â«124â¤Â»

=head2 routine trim

Defined as:

    sub trim(Str(Cool))
    method trim()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and returns the string with both
leading and trailing whitespace stripped.

    my $stripped = '  abc '.trim;
    say "<$stripped>";          # OUTPUT: Â«<abc>â¤Â»

=head2 routine trim-leading

Defined as:

    sub trim-leading(Str(Cool))
    method trim-leading()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and returns the string with
leading whitespace stripped.

    my $stripped = '  abc '.trim-leading;
    say "<$stripped>";          # OUTPUT: Â«<abc >â¤Â»

=head2 routine trim-trailing

Defined as:

    sub trim-trailing(Str(Cool))
    method trim-trailing()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and
returns the string with trailing whitespace stripped.

    my $stripped = '  abc '.trim-trailing;
    say "<$stripped>";          # OUTPUT: Â«<  abc>â¤Â»

=head2 routine lc

Defined as:

    sub lc(Str(Cool))
    method lc()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and returns it case-folded to lower
case.

    say "ABC".lc;       # OUTPUT: Â«abcâ¤Â»

=head2 routine uc

Defined as:

    sub uc(Str(Cool))
    method uc()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and returns it case-folded to upper
case (capital letters).

    say "Abc".uc;       # OUTPUT: Â«ABCâ¤Â»

=head2 routine fc

Defined as:

    sub fc(Str(Cool))
    method fc()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and
returns the result a Unicode "case fold" operation suitable for doing caseless
string comparisons. (In general, the returned string is unlikely to be useful
for any purpose other than comparison.)

    say "groÃŸ".fc;       # OUTPUT: Â«grossâ¤Â»

=head2 routine tc

Defined as:

    sub tc(Str(Cool))
    method tc()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and returns it with the first letter
case-folded to title case (or where not available, upper case).

    say "abC".tc;       # OUTPUT: Â«AbCâ¤Â»

=head2 routine tclc

Defined as:

    sub tclc(Str(Cool))
    method tclc()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and returns it with the first letter
case-folded to title case (or where not available, upper case), and the rest
of the string case-folded to lower case.

    say 'abC'.tclc;     # OUTPUT: Â«Abcâ¤Â»

=head2 routine wordcase

Defined as:

    sub wordcase(Str(Cool) $input, :&filter = &tclc, Mu :$where = True)
    method wordcase(:&filter = &tclc, Mu :$where = True)

Coerces the invocant (or in sub form, the first argument) to L<Str|/type/Str>, and filters each word that
smartmatches against C<$where> through the C<&filter>. With the default
filter (first character to upper case, rest to lower) and matcher (which
accepts everything), this title-cases each word:

    say "perlÂ 6 programming".wordcase;      # OUTPUT: Â«PerlÂ 6 Programmingâ¤Â»

With a matcher:

    say "have fun working on perl".wordcase(:where({ .chars > 3 }));
                                            # Have fun Working on Perl

With a customer filter too:

    say "have fun working on perl".wordcase(:filter(&uc), :where({ .chars > 3 }));
                                            # HAVE fun WORKING on PERL

=head2 routine samecase

Defined as:

    sub samecase(Cool $string, Cool $pattern)
    method samecase(Cool:D: Cool $pattern)

Coerces the invocant (or in sub form, the first argument) to L<Str|/type/Str>,
and returns a copy of C<$string> with case information for each individual
character changed according to C<$pattern>.

B<Note>: The pattern string can contain
three types of characters, i.e. uppercase, lowercase and caseless. For a given
character in C<$pattern> its case information determines the case of the
corresponding character in the result.

If C<$string> is longer than
C<$pattern>, the case information from the last character of C<$pattern> is
applied to the remaining characters of C<$string>.

    say "perL 6".samecase("A__a__"); # OUTPUT: Â«PerlÂ 6â¤Â»
    say "pERL 6".samecase("Ab");     # OUTPUT: Â«PerlÂ 6â¤Â»

=head2 routine uniprop

Defined as:

    multi sub uniprop(Str:D, |c)
    multi sub uniprop(Int:D $code)
    multi sub uniprop(Int:D $code, Stringy:D $propname)
    multi method uniprop(|c)

Returns the L<unicode property|http://userguide.icu-project.org/strings/properties>
of the first character. If no property is specified returns the
L<General Category|https://en.wikipedia.org/wiki/Unicode_character_property#General_Category>.
Returns a Bool for Boolean properties. A L<uniprops|/routine/uniprops> routine can be used
to get the property for every character in a string.

    say 'a'.uniprop;               # OUTPUT: Â«Llâ¤Â»
    say '1'.uniprop;               # OUTPUT: Â«Ndâ¤Â»
    say 'a'.uniprop('Alphabetic'); # OUTPUT: Â«Trueâ¤Â»
    say '1'.uniprop('Alphabetic'); # OUTPUT: Â«Falseâ¤Â»

=head2 sub uniprops

Defined as:

    sub uniprops(Str:D $str, Stringy:D $propname = "General_Category")

Interprets the invocant as a L<Str|/type/Str>, and returns the
L<unicode property|http://userguide.icu-project.org/strings/properties> for each character
as a Seq. If no property is specified returns the
L<General Category|https://en.wikipedia.org/wiki/Unicode_character_property#General_Category>.
Returns a Bool for Boolean properties. Similar to
L<uniprop|/routine/uniprop>, but for each character in the passed
string.

=head2 routine uniname

Defined as:

    sub uniname(Str(Cool) --> Str)
    method uniname(--> Str)

Interprets the invocant or first argument as a L<Str|/type/Str>, and returns the
Unicode codepoint name of the first codepoint of the first character. See
L<uninames|/routine/uninames> for a routine that works with multiple
codepoints, and L<uniparse|/routine/uniparse> for the opposite direction.

    # Camelia in Unicode
    say â€˜Â»Ã¶Â«â€™.uniname;
    # OUTPUT: Â«"RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK"â¤Â»
    say "á¸ŒÌ‡".uniname; # Note, doesn't show "COMBINING DOT ABOVE"
    # OUTPUT: Â«"LATIN CAPITAL LETTER D WITH DOT BELOW"â¤Â»

    # Find the char with the longest Unicode name.
    say (0..0x1FFFF).sort(*.uniname.chars)[*-1].chr.uniname;
    # OUTPUT: Â«Â«ARABIC LIGATURE UIGHUR KIRGHIZ YEH WITH HAMZA ABOVE WITH ALEF MAKSURA INITIAL FORMâ¤Â»â¤Â»

=head2 routine uninames

Defined as:

    sub uninames(Str:D)
    method uninames()

Returns of a Seq of Unicode names for the all the codepoints in the Str
provided.

    say â€˜Â»Ã¶Â«â€™.uninames.perl;
    # OUTPUT: Â«("RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK", "LATIN SMALL LETTER O WITH DIAERESIS", "LEFT-POINTING DOUBLE ANGLE QUOTATION MARK").Seqâ¤Â»

Note this example, which gets a Seq where each element is a Seq of all the
codepoints in that character.

    say "á¸ŒÌ‡'oh".comb>>.uninames.perl;
    # OUTPUT: Â«(("LATIN CAPITAL LETTER D WITH DOT BELOW", "COMBINING DOT ABOVE").Seq, ("APOSTROPHE",).Seq, ("LATIN SMALL LETTER O",).Seq, ("LATIN SMALL LETTER H",).Seq)â¤Â»

See L<uniparse|/routine/uniparse> for the opposite direction.

=head2 routine unimatch

Defined as:

    multi sub unimatch(Str:D $str, |c)
    multi unimatch(Int:D $code, Stringy:D $pvalname, Stringy:D $propname = $pvalname)

Checks if the given integer codepoint or the first letter of the string given
have a unicode property equal to the value you give. If you supply the Unicode
property to be checked it will only return True if that property matches the
given value.

    say unimatch 'A', 'Latin';           # OUTPUT: Â«Trueâ¤Â»
    say unimatch 'A', 'Latin', 'Script'; # OUTPUT: Â«Trueâ¤Â»
    say unimatch 'A', 'Ll';              # OUTPUT: Â«Trueâ¤Â»

=head2 routine chop

Defined as:

    sub chop(Str(Cool))
    method chop()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and
returns it with the last character removed.

    say 'perl'.chop;                        # OUTPUT: Â«perâ¤Â»

=head2 routine chomp

Defined as:

    sub chomp(Str(Cool))
    method chomp()

Coerces the invocant (or in sub form, its argument) to L<Str|/type/Str>, and
returns it with the last character removed, if it is a logical newline.

    say 'ab'.chomp.chars;                   # OUTPUT: Â«2â¤Â»
    say "a\n".chomp.chars;                  # OUTPUT: Â«1â¤Â»

=head2 routine substr

Defined as:

    sub substr(Str(Cool) $str, |c)
    method substr(|c)

Coerces the invocant (or in the sub form, the first argument) to
L<Str|/type/Str>, and calls L<Str.substr|/type/Str#routine_substr> with
the arguments.

=head2 routine substr-rw

Defined as:

    multi method substr-rw(|) is rw
    multi sub substr-rw(|) is rw

Coerces the invocant (or in the sub form, the first argument) to
L<Str|/type/Str>, and calls L<Str.substr-rw|/type/Str#routine_substr-rw> with
the arguments.

=head2 routine ords

Defined as:

    sub ords(Str(Cool) $str)
    method ords()

Coerces the invocant (or in the sub form, the first argument) to
L<Str|/type/Str>, and returns a list of Unicode codepoints for each character.

    say "Camelia".ords;              # OUTPUT: Â«67 97 109 101 108 105 97â¤Â»
    say ords 10;                     # OUTPUT: Â«49 48â¤Â»

This is the list-returning version of L<ord|/routine/ord>. The inverse operation in
L<chrs|/routine/chrs>. If you are only interested in the number of codepoints,
L<codes|/routine/codes> is a possibly faster option.

=head2 routine chrs

Defined as:

    sub chrs(*@codepoints --> Str:D)
    method chrs()

Coerces the invocant (or in the sub form, the argument list) to a list of
integers, and returns the string created by interpreting each integer as a
Unicode codepoint, and joining the characters.

    say <67 97 109 101 108 105 97>.chrs;   # OUTPUT: Â«Cameliaâ¤Â»

This is the list-input version of L<chr|/routine/chr>. The inverse operation is L<ords|/routine/ords>.

=head2 routine split

Defined as:

    multi sub    split(  Str:D $delimiter, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
    multi sub    split(Regex:D $delimiter, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
    multi sub    split(@delimiters, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
    multi method split(  Str:D $delimiter, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
    multi method split(Regex:D $delimiter, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)
    multi method split(@delimiters, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)

N<IÂ«the L<comb|/routine/comb> routine is a much better choice for many tasks that in other
languages are handled by the C<split>.Â»>

Coerces the invocant (or in the sub form, the second argument) to
L<Str|/type/Str>, and splits it into pieces based on delimiters found in the
string.

If C<$delimiter> is a string, it is searched for literally and not treated
as a regex. You can also provide multiple delimiters by specifying them as a
list; mixing Cool and Regex objects is OK.

    say split(';', "a;b;c").perl;               # OUTPUT: Â«("a", "b", "c")â¤Â»
    say split(';', "a;b;c", 2).perl;            # OUTPUT: Â«("a", "b;c").Seqâ¤Â»

    say split(';', "a;b;c,d").perl;             # OUTPUT: Â«("a", "b", "c,d")â¤Â»
    say split(/\;/, "a;b;c,d").perl;            # OUTPUT: Â«("a", "b", "c,d")â¤Â»
    say split(/<[;,]>/, "a;b;c,d").perl;        # OUTPUT: Â«("a", "b", "c", "d")â¤Â»

    say split(['a', /b+/, 4], '1a2bb345').perl; # OUTPUT: Â«("1", "2", "3", "5")â¤Â»

By default, split omits the matches, and returns a list of only those parts of
the string that did not match. Specifying one of the C<:k, :v, :kv, :p> adverbs
changes that. Think of the matches as a list that is interleaved with the
non-matching parts.

The C<:v> interleaves the values of that list, which will be either
L<Match|/type/Match> objects, if a L<Regex|/type/Regex> was used as a matcher
in the split, or L<Str|/type/Str> objects, if a L<Cool|/type/Cool> was used
as matcher. If multiple delimiters are specified, L<Match|/type/Match> objects
will be generated for all of them, unless B<all> of the delimiters are
L<Cool|/type/Cool>.

    say 'abc'.split(/b/, :v);               # OUTPUT: Â«(a ï½¢bï½£ c)â¤Â»
    say 'abc'.split('b', :v);               # OUTPUT: Â«(a b c)â¤Â»

C<:k> interleaves the keys, that is, the indexes:

    say 'abc'.split(/b/, :k);               # OUTPUT: Â«(a 0 c)â¤Â»

C<:kv> adds both indexes and matches:

    say 'abc'.split(/b/, :kv);               # OUTPUT: Â«(a 0 ï½¢bï½£ c)â¤Â»

and C<:p> adds them as L<Pairs|/type/Pair>, using the same types for
values as C<:v> does:

    say 'abc'.split(/b/, :p);               # OUTPUT: Â«(a 0 => ï½¢bï½£ c)â¤Â»
    say 'abc'.split('b', :p);               # OUTPUT: Â«(a 0 => b c)â¤Â»

You can only use one of the C<:k, :v, :kv, :p> adverbs in a single call
to C<split>.

Note that empty chunks are not removed from the result list.
For that behavior, use the C<:skip-empty> named argument:

    say ("f,,b,c,d".split: /","/             ).perl;  # OUTPUT: Â«("f", "", "b", "c", "d")â¤Â»
    say ("f,,b,c,d".split: /","/, :skip-empty).perl;  # OUTPUT: Â«("f", "b", "c", "d")â¤Â»

=head2 routine lines

Defined as:

    sub lines(Str(Cool))
    method lines()

Coerces the invocant (and in sub form, the argument) to L<Str|/type/Str>,
decomposes it into lines (with the newline characters stripped), and returns
the list of lines.

    say lines("a\nb\n").join('|');          # OUTPUT: Â«a|bâ¤Â»
    say "some\nmore\nlines".lines.elems;    # OUTPUT: Â«3â¤Â»


This method can be used as part of an C<IO::Path> to process a file
line-by-line, since C<IO::Path> objects inherit from C<Cool>, e.g.:

=begin code
for 'huge-csv'.IO.lines -> $line {
    # Do something with $line
}

# or if you'll be processing later
my @lines = 'huge-csv'.IO.lines;
=end code

Without any arguments, sub C<lines> operates on
C<$*ARGFILES>, which defaults to C<$*IN> in the absence of any filenames.

To modify values in place use C<is copy> to force a writable container.

=for code
for $*IN.lines -> $_ is copy { s/(\w+)/{$0 ~ $0}/; .say }

=head2 method words

Defined as:

    method words(Cool:D: |c)

Coerces the invocant (or first argument, if it is called as a subroutine) to
L<Str|/type/Str>, and returns a list of words that make up the string. Check
L<C<Str.words>|/type/Str#routine_words> for additional arguments and its
meaning.

=for code
say <The quick brown fox>.words.join('|');     # OUTPUT: Â«The|quick|brown|foxâ¤Â»
say <The quick brown fox>.words(2).join('|');  # OUTPUT: Â«The|quickâ¤Â»

C<Cool> is the base class for many other classes, and some of them, like
L<Match|/type/Match>, can be converted to a string. This is what happens in this case:

    say ( "easy come, easy goes" ~~ m:g/(ea\w+)/).words(Inf);
    # OUTPUT: Â«(easy easy)â¤Â»
    say words( "easy come, easy goes" ~~ m:g/(ea\w+)/ , âˆ);
    # OUTPUT: Â«(easy easy)â¤Â»

The example above illustrates two of the ways C<words> can be invoked, with the
first argument turned into invocant by its signature. Of course, C<Inf> is the
default value of the second argument, so in both cases (and forms) it can be
simply omitted.

Only whitespace (including no-break space) counts as word boundaries

    say <Don't we â™¥ PerlÂ 6>.words.join('|');  # OUTPUT: Â«Don't|we|â™¥|Perl|6â¤Â»

In this case, PerlÂ 6 includes an (visible only in the source) no-break space;
C<words> still splits the (resulting) C<Str> on it, even if the original array
only had 4 elements:

    say <Don't we â™¥ PerlÂ 6>.join("|");  # OUTPUT: Â«Don't|we|â™¥|PerlÂ 6â¤Â»

Please see L<C<Str.words>|/type/Str#routine_words> for more examples and ways to
invoke it.

=head2 routine comb

Defined as:

    multi sub comb(Regex $matcher, Cool $input, $limit = *)
    multi sub comb(Str $matcher, Cool $input, $limit = *)
    multi sub comb(Int:D $size, Cool $input, $limit = *)
    multi method comb(|c)

Returns a L<Seq|/type/Seq> of all (or if supplied, at most C<$limit>) matches of the
invocant (method form) or the second argument (sub form) against the
L<Regex|/type/Regex>, string or defined number.

    say "6 or 12".comb(/\d+/).join(", ");           # OUTPUT: Â«6, 12â¤Â»
    say comb(/\d <[1..9]> /,(11..30)).join("--");
    # OUTPUT:
    # Â«11--12--13--14--15--16--17--18--19--21--22--23--24--25--26--27--28--29â¤Â»

The second statement exemplifies the first form of C<comb>, with a C<Regex> that
excludes multiples of ten, and a C<Range> (which is C<Cool>) as C<$input>.
C<comb> stringifies the C<Range> before applying C<.comb> on the resulting
string. Check L<C<Str.comb>|/type/Str#routine_comb> for its effect on different
kind of input strings. When the first argument is an integer, it indicates the
(maximum) size of the chunks the input is going to be divided in

    say comb(3,[3,33,333,3333]).join("*");  # OUTPUT: Â«3 3*3 3*33 *333*3â¤Â»

In this case the input is a list, which after transformation to C<Str> (which
includes the spaces) is divided in chunks of size 3.

=head2 method contains

Defined as:

    method contains(Cool:D: |c)

Coerces the invocant L<C<Str>|/type/Str>, and calls
L<C<Str.contains>|/type/Str#routine_contains> on it. Please refer to
that version of the method for arguments and general syntax.

    say 123.contains("2")# OUTPUT: Â«Trueâ¤Â»

Since L<Int|/type/Int> is a subclass of C<Cool>, C<123> is coerced to a C<Str> and
then C<contains> is called on it.

    say (1,1, * + * â€¦ * > 250).contains(233)# OUTPUT: Â«Trueâ¤Â»

L<Seq|/type/Seq>s are also subclasses of C<Cool>, and they are stringified to a
comma-separated form. In this case we are also using an C<Int>, which is
going to be stringified also; C<"233"> is included in that sequence, so
it returns C<True>. Please note that this sequence is not lazy; the
stringification of lazy sequences does not include each and every one of
their components for obvious reasons.

=head2 routine index

Defined as:

    multi sub index(Cool $s, Cool $needle, Cool $pos = 0)
    method    index(Cool:D: |c)

Coerces the first two arguments (in method form, also counting the invocant) to
a L<Str|/type/Str>, and searches for C<$needle> in the string C<$s> starting
from C<$startpos>. It returns the offset into the string where C<$needle> was
found, and an undefined value if it was not found.

See L<the documentation in type Str|/type/Str#routine_index> for examples.

=head2 routine rindex

Defined as:

    multi sub    rindex(Str(Cool) $haystack, Str(Cool) $needle, Int(Cool) $startpos = $haystack.chars)
    multi method rindex(Str(Cool) $haystack: Str(Cool) $needle, Int(Cool) $startpos = $haystack.chars)

Coerces the first two arguments (including the invocant in method form) to
L<Str|/type/Str> and C<$startpos> to L<Int|/type/Int>, and
returns the last position of C<$needle> in C<$haystack> not after C<$startpos>.
Returns an undefined value if C<$needle> wasn't found.

See L<the documentation in type Str|/type/Str#routine_rindex> for examples.

=head2 method match

Defined as:

    multi method match(Cool:D: $target, *%adverbs)

Coerces the invocant to L<Str|/type/Str> and calls the method
L<match|/type/Str#method_match> on it.

=head2 method fmt

Defined as:

    method fmt($format = '%s' --> Str:D)

Uses C<$format> to return a formatted representation of the invocant.

For more information about formats strings, see L<sprintf|/routine/sprintf>.

    say 11.fmt('This Int equals %03d');               # OUTPUT: Â«This Int equals 011â¤Â»
    say '16'.fmt('Hexadecimal %x');                   # OUTPUT: Â«Hexadecimal 10â¤Â»

=head2 routine roots

Defined as:

    multi sub roots(Numeric(Cool) $x, Int(Cool) $n)
    multi method roots(Int(Cool) $n)

Coerces the first argument (and in method form, the invocant) to
L<Numeric|/type/Numeric> and the second (C<$n>) to L<Int|/type/Int>, and
produces a list of C<$n> L<Complex|/type/Complex> C<$n>-roots, which means
numbers that, raised to the C<$n>th power, approximately produce the original
number.

For example

=begin code
my $original = 16;
my @roots = $original.roots(4);
say @roots;

for @roots -> $r {
    say abs($r ** 4 - $original);
}

# OUTPUT:Â«2+0i 1.22464679914735e-16+2i -2+2.44929359829471e-16i -3.67394039744206e-16-2iâ¤Â»
# OUTPUT:Â«1.77635683940025e-15â¤Â»
# OUTPUT:Â«4.30267170434156e-15â¤Â»
# OUTPUT:Â«8.03651692704705e-15â¤Â»
# OUTPUT:Â«1.04441561648202e-14â¤Â»
=end code

=head2 method match

Defined as:

    method match(|)

Coerces the invocant to L<Stringy|/type/Stringy> and calls
L<Str.match|/type/Str#method_match>.

=head2 method subst

Defined as:

    method subst(|)

Coerces the invocant to L<Stringy|/type/Stringy> and calls L<Str.subst|/type/Str#method_subst>.

=head2 method trans

Defined as:

    method trans(|)

Coerces the invocant to L<Str|/type/Str> and calls L<Str.trans|/type/Str#method_trans>

=head2 method IO

Defined as:

    method IO(--> IO::Path:D)

Coerces the invocant to L<IO::Path>.

=for code
.say for '.'.IO.dir;        # gives a directory listing

=head2 routine EVAL

Defined as:

=begin code :method
method EVAL(*%_)
=end code
=begin code :method
proto sub EVAL($code is copy where Blob|Cool|Callable, Str() :$lang = 'perl6',
                PseudoStash :$context, *%n)
=end code
=begin code :method
multi sub EVAL($code, Str :$lang where { ($lang // '') eq 'Perl5' },
                PseudoStash :$context)
=end code

If it is invoked as a method, it calls the subroutine form with
invocant as the first argument, C<$code>, passing along named args, if any; this
coerces L<Cool|/type/Cool> C<$code> to L<Str|/type/Str>. If C<$code> is a
L<Blob|/type/Blob>, it'll be processed using the same encoding as the C<$lang>
compiler would: for C<perl6> C<$lang>, uses C<utf-8>; for C<Perl5>, processes
using the same rules as C<perl>.

This works as-is with a literal string parameter. More complex input,
such as a variable or string with embedded code, is illegal by default.
This can be overridden in any of several ways:

    use MONKEY-SEE-NO-EVAL; # Or...
    use MONKEY;             # shortcut that turns on all MONKEY pragmas
    use Test;

    # any of the above allows:
    EVAL "say { 5 + 5 }";   # OUTPUT: Â«10â¤Â»

In case the C<MONKEY-SEE-NO-EVAL> pragma is not activated, the compiler will
complain with a C<EVAL is a very dangerous function!!!> exception. And it is
essentially right, since that will run arbitrary code with the same permissions
as the program. You should take care of cleaning the code that is going to pass
through EVAL if you activate the C<MONKEY-SEE-NO-EVAL> pragma.

Please note that you can interpolate to create routine names using
quotation, as can be seen in
L<this example|/language/quoting#index-entry-%26_(interpolation)>
or
L<other ways to interpolate to create identifier names|/language/syntax#Identifiers>.
This only works, however, for already declared functions and other
objects and is thus safer to use.

Symbols in the current lexical scope are visible to code in an C<EVAL>.

    my $answer = 42;
    EVAL 'say $answer;';    # OUTPUT: Â«42â¤Â»

However, since the set of symbols in a lexical scope is immutable after
compile time, an C<EVAL> can never introduce symbols into the surrounding
scope.

=for code :skip-test<compile time error>
EVAL 'my $lives = 9'; say $lives;   # error, $lives not declared

Furthermore, the C<EVAL> is evaluated in the current package:

    module M {
        EVAL 'our $answer = 42'
    }
    say $M::answer;         # OUTPUT: Â«42â¤Â»

And also in the current language, meaning any added syntax is available:

    sub infix:<mean>(*@a) is assoc<list> {
        @a.sum / @a.elems
    }
    EVAL 'say 2 mean 6 mean 4';     # OUTPUT: Â«4â¤Â»

An C<EVAL> statement evaluates to the result of the last statement:

=begin code
sub infix:<mean>(*@a) is assoc<list> {
    @a.sum / @a.elems
}
say EVAL 'say 1; 2 mean 6 mean 4';         # OUTPUT: Â«1â¤4â¤Â»
=end code

C<EVAL> is also a gateway for executing code in other languages:

=for code
EVAL "use v5.20; say 'Hello from perl5!'", :lang<Perl5>;

You need to have L<C<Inline::Perl5>|https://github.com/niner/Inline-Perl5> for
this to work correctly.

=head2 sub EVALFILE

Defined as:

    sub EVALFILE($filename where Blob|Cool, :$lang = 'perl6')

Slurps the specified file and evaluates it. Behaves the same way as
C<EVAL> with regard to L<Blob|/type/Blob> decoding, scoping, and the C<$lang>
parameter. Evaluates to the value produced by the final statement in the
file.

=for code
EVALFILE "foo.p6";

=head2 routine unpolar

Defined as:

    method unpolar(Real $angle)
    multi sub unpolar(Real $mag, Real $angle)

Returns a C<Complex> with the coordinates corresponding to the angle in
radians and magnitude corresponding to the object value or C<$mag> in
the case it's being used as a C<sub>

    say 1.unpolar(â…“*pi);
    # OUTPUT: Â«0.5000000000000001+0.8660254037844386iâ¤Â»

=head2 routine printf

Defined as:

     method printf (*@args)
     multi sub printf(Cool:D $format, *@args)

As a method, takes the object as a format using
L<the same language as C<Str.sprintf>|/type/Str#routine_sprintf>; as a sub, its
first argument will be
the format string, and the rest of the arguments will be substituted in the
format following the format conventions.

    "%s is %s".printf("Ã¾or", "mighty");    # OUTPUT: Â«Ã¾or is mightyÂ»
    printf( "%s is %s", "Ã¾or", "mighty");  # OUTPUT: Â«Ã¾or is mightyÂ»

=head2 routine sprintf

Defined as:

    method sprintf(*@args)
    multi sub sprintf(Cool:D $format, *@args)

Formats and outputs a string, following
L<the same language as C<Str.sprintf>|/type/Str#routine_sprintf>, using as such
format either the object (if called in method form) or the first argument (if
called as a routine)

    sprintf( "%s the %d%s", "Ã¾or", 1, "st").put; #OUTPUT: Â«Ã¾or the 1stâ¤Â»
    sprintf( "%s is %s", "Ã¾or", "mighty").put;   # OUTPUT: Â«Ã¾or is mightyâ¤Â»
    "%s's weight is %.2f %s".sprintf( "MjÃ¶lnir", 3.3392, "kg").put;
    # OUTPUT: Â«MjÃ¶lnir's weight is 3.34 kgâ¤Â»

This function is mostly identical to the C library's C<sprintf> and C<printf>
functions.  The only difference between the two functions is that C<sprintf>
returns a string while the C<printf> function writes to a filehandle. C<sprintf>
returns a C<Str>, not a literal.

The C<$format> is scanned for C<%> characters. Any C<%> introduces a format
token. Directives guide the use (if any) of the arguments. When a directive
other than C<%> is used, it indicates how the next argument passed is to be
formatted into the string to be created.

N<The information below is for a fully functioning C<sprintf> implementation
which hasn't been achieved yet. Formats or features not yet implemented are
marked NYI.>

The directives are:

=begin table

 % |  a literal percent sign
 c |  a character with the given codepoint
 s |  a string
 d |  a signed integer, in decimal
 u |  an unsigned integer, in decimal
 o |  an unsigned integer, in octal
 x |  an unsigned integer, in hexadecimal
 e |  a floating-point number, in scientific notation
 f |  a floating-point number, in fixed decimal notation
 g |  a floating-point number, in %e or %f notation
 X |  like x, but using uppercase letters
 E |  like e, but using an uppercase "E"
 G |  like g, but with an uppercase "E" (if applicable)
 b |  an unsigned integer, in binary

=end table

Compatibility:

=begin table

 i |  a synonym for %d
 D |  a synonym for %ld
 U |  a synonym for %lu
 O |  a synonym for %lo
 F |  a synonym for %f

=end table

Modifiers change the meaning of format directives, but are largely
no-ops (the semantics are still being determined).

=begin table

     | h  | interpret integer as native "short" (typically int16)
 NYI | l  | interpret integer as native "long" (typically int32 or int64)
 NYI | ll | interpret integer as native "long long" (typically int64)
 NYI | L  | interpret integer as native "long long" (typically uint64)
 NYI | q  | interpret integer as native "quads" (typically int64 or larger)

=end table

Between the C<%> and the format letter, you may specify several
additional attributes controlling the interpretation of the format. In
order, these are:

=head3 Format parameter index

An explicit format parameter index, such as C<2$>. By default,
C<sprintf> will format the next unused argument in the list, but this
allows you to take the arguments out of order:

  sprintf '%2$d %1$d', 12, 34;      # OUTPUT: Â«34 12â¤Â»
  sprintf '%3$d %d %1$d', 1, 2, 3;  # OUTPUT: Â«3 1 1â¤Â»

=head3 Flags

One or more of:

=begin table
   space |  prefix non-negative number with a space
----------------------------------------------------------------
  \+     |  prefix non-negative number with a plus sign
----------------------------------------------------------------
   -     |  left-justify within the field
----------------------------------------------------------------
   0     |  use leading zeros, not spaces, for required padding
----------------------------------------------------------------
   #     |  ensure the leading "0" for any octal,
         |  prefix non-zero hexadecimal with "0x" or "0X",
         |  prefix non-zero binary with "0b" or "0B"
=end table

For example:

  sprintf '<% d>',  12;   # RESULT: Â«< 12>â¤Â»
  sprintf '<% d>',   0;   # RESULT: Â«< 0>"Â»
  sprintf '<% d>', -12;   # RESULT: Â«<-12>â¤Â»
  sprintf '<%+d>',  12;   # RESULT: Â«<+12>â¤Â»
  sprintf '<%+d>',   0;   # RESULT: Â«<+0>"Â»
  sprintf '<%+d>', -12;   # RESULT: Â«<-12>â¤Â»
  sprintf '<%6s>',  12;   # RESULT: Â«<    12>â¤Â»
  sprintf '<%-6s>', 12;   # RESULT: Â«<12    >â¤Â»
  sprintf '<%06s>', 12;   # RESULT: Â«<000012>â¤Â»
  sprintf '<%#o>',  12;   # RESULT: Â«<014>â¤Â»
  sprintf '<%#x>',  12;   # RESULT: Â«<0xc>â¤Â»
  sprintf '<%#X>',  12;   # RESULT: Â«<0XC>â¤Â»
  sprintf '<%#b>',  12;   # RESULT: Â«<0b1100>â¤Â»
  sprintf '<%#B>',  12;   # RESULT: Â«<0B1100>â¤Â»

When a space and a plus sign are given as the flags at once, the space
is ignored:

  sprintf '<%+ d>', 12;   # RESULT: Â«<+12>â¤Â»
  sprintf '<% +d>', 12;   # RESULT: Â«<+12>â¤Â»

When the C<#> flag and a precision are given in the C<%o> conversion, the
necessary number of 0s is added at the beginning. If the value of the number is
C<0> and the precision is 0, it will output nothing; precision 0 or smaller than
the actual number of elements will return the number with 0 to the left:

  say sprintf '<%#.5o>', 0o12;     # OUTPUT: Â«<00012>â¤Â»
  say sprintf '<%#.5o>', 0o12345;  # OUTPUT: Â«<012345>â¤Â»
  say sprintf '<%#.0o>', 0;        # OUTPUT: Â«<>â¤Â» zero precision and value 0 results in no output!
  say sprintf '<%#.0o>', 0o1       # OUTPUT: Â«<01>â¤Â»

=head3 Vector flag

This flag tells PerlÂ 6 to interpret the supplied string as a vector of
integers, one for each character in the string. PerlÂ 6 applies the
format to each integer in turn, then joins the resulting strings with
a separator (a dot, C<'.'>, by default). This can be useful for
displaying ordinal values of characters in arbitrary strings:

=begin code :skip-test
NYI sprintf "%vd", "AB\x{100}";           # "65.66.256"
=end code

You can also explicitly specify the argument number to use for the
join string using something like C<*2$v>; for example:

=begin code :skip-test
NYI sprintf '%*4$vX %*4$vX %*4$vX',       # 3 IPv6 addresses
        @addr[1..3], ":";
=end code

=head3 (Minimum) Width

Arguments are usually formatted to be only as wide as required to
display the given value. You can override the width by putting a
number here, or get the width from the next argument (with C<*> ) or
from a specified argument (e.g., with C<*2$>):

 sprintf "<%s>", "a";           # RESULT: Â«<a>â¤Â»
 sprintf "<%6s>", "a";          # RESULT: Â«<     a>â¤Â»
 sprintf "<%*s>", 6, "a";       # RESULT: Â«<     a>â¤Â»
=begin code :skip-test
 NYI sprintf '<%*2$s>', "a", 6; # "<     a>"
=end code
 sprintf "<%2s>", "long";       # RESULT: Â«<long>â¤Â» (does not truncate)

If a field width obtained through C<*> is negative, it has the same
effect as the C<-> flag: left-justification.

=head3 Precision, or maximum width

You can specify a precision (for numeric conversions) or a maximum
width (for string conversions) by specifying a C<.> followed by a
number. For floating-point formats, except C<g> and C<G>, this
specifies how many places right of the decimal point to show (the
default being 6). For example:

  # these examples are subject to system-specific variation
  sprintf '<%f>', 1;    # RESULT: Â«"<1.000000>"â¤Â»
  sprintf '<%.1f>', 1;  # RESULT: Â«"<1.0>"â¤Â»
  sprintf '<%.0f>', 1;  # RESULT: Â«"<1>"â¤Â»
  sprintf '<%e>', 10;   # RESULT: Â«"<1.000000e+01>"â¤Â»
  sprintf '<%.1e>', 10; # RESULT: Â«"<1.0e+01>"â¤Â»

For "g" and "G", this specifies the maximum number of digits to show,
including those prior to the decimal point and those after it; for
example:

  # These examples are subject to system-specific variation.
  sprintf '<%g>', 1;        # RESULT: Â«<1>â¤Â»
  sprintf '<%.10g>', 1;     # RESULT: Â«<1>â¤Â»
  sprintf '<%g>', 100;      # RESULT: Â«<100>â¤Â»
  sprintf '<%.1g>', 100;    # RESULT: Â«<1e+02>â¤Â»
  sprintf '<%.2g>', 100.01; # RESULT: Â«<1e+02>â¤Â»
  sprintf '<%.5g>', 100.01; # RESULT: Â«<100.01>â¤Â»
  sprintf '<%.4g>', 100.01; # RESULT: Â«<100>â¤Â»

For integer conversions, specifying a precision implies that the
output of the number itself should be zero-padded to this width, where
the C<0> flag is ignored:

(Note that this feature currently works for unsigned integer conversions, but
not for signed integer.)

  =begin code :skip-test
  sprintf '<%.6d>', 1;      # <000001>
  NYI sprintf '<%+.6d>', 1;     # <+000001>
  NYI sprintf '<%-10.6d>', 1;   # <000001    >
  sprintf '<%10.6d>', 1;    # <    000001>
  NYI sprintf '<%010.6d>', 1;   #     000001>
  NYI sprintf '<%+10.6d>', 1;   # <   +000001>
  sprintf '<%.6x>', 1;         # RESULT: Â«<000001>â¤Â»
  sprintf '<%#.6x>', 1;        # RESULT: Â«<0x000001>â¤Â»
  sprintf '<%-10.6x>', 1;      # RESULT: Â«<000001    >â¤Â»
  sprintf '<%10.6x>', 1;       # RESULT: Â«<    000001>â¤Â»
  sprintf '<%010.6x>', 1;      # RESULT: Â«<    000001>â¤Â»
  sprintf '<%#10.6x>', 1;      # RESULT: Â«<  0x000001>â¤Â»
  =end code

For string conversions, specifying a precision truncates the string to
fit the specified width:

  sprintf '<%.5s>', "truncated";   # RESULT: Â«<trunc>â¤Â»
  sprintf '<%10.5s>', "truncated"; # RESULT: Â«<     trunc>â¤Â»

You can also get the precision from the next argument using C<.*>, or
from a specified argument (e.g., with C<.*2$>):

  =begin code :skip-test
  sprintf '<%.6x>', 1;       # RESULT: Â«<000001>â¤Â»
  sprintf '<%.*x>', 6, 1;    # RESULT: Â«<000001>â¤Â»
  NYI sprintf '<%.*2$x>', 1, 6;  # "<000001>"
  NYI sprintf '<%6.*2$x>', 1, 4; # "<  0001>"
  =end code

If a precision obtained through C<*> is negative, it counts as having
no precision at all:

  sprintf '<%.*s>',  7, "string";   # RESULT: Â«<string>â¤Â»
  sprintf '<%.*s>',  3, "string";   # RESULT: Â«<str>â¤Â»
  sprintf '<%.*s>',  0, "string";   # RESULT: Â«<>â¤Â»
  sprintf '<%.*s>', -1, "string";   # RESULT: Â«<string>â¤Â»
  sprintf '<%.*d>',  1, 0;          # RESULT: Â«<0>â¤Â»
  sprintf '<%.*d>',  0, 0;          # RESULT: Â«<>â¤Â»
  sprintf '<%.*d>', -1, 0;          # RESULT: Â«<0>â¤Â»

=head3 Size

For numeric conversions, you can specify the size to interpret the
number as using C<l>, C<h>, C<V>, C<q>, C<L>, or C<ll>. For integer
conversions (C<d> C<u> C<o> C<x> C<X> C<b> C<i> C<D> C<U> C<O>),
numbers are usually assumed to be whatever the default integer size is
on your platform (usually 32 or 64 bits), but you can override this to
use instead one of the standard C types, as supported by the compiler
used to build PerlÂ 6:

(Note: None of the following have been implemented.)

=begin table

   hh          | interpret integer as C type "char" or "unsigned char"
   h           | interpret integer as C type "short" or "unsigned short"
   j           | interpret integer as C type "intmax_t", only with a C99 compiler (unportable)
   l           | interpret integer as C type "long" or "unsigned long"
   q, L, or ll | interpret integer as C type "long long", "unsigned long long", or "quad" (typically 64-bit integers)
   t           | interpret integer as C type "ptrdiff_t"
   z           | interpret integer as C type "size_t"
=end table

=head3 Order of arguments

Normally, C<sprintf> takes the next unused argument as the value to
format for each format specification. If the format specification uses
C<*> to require additional arguments, these are consumed from the
argument list in the order they appear in the format specification
before the value to format. Where an argument is specified by an
explicit index, this does not affect the normal order for the
arguments, even when the explicitly specified index would have been
the next argument.

So:

   my $a = 5; my $b = 2; my $c = 'net';
   sprintf "<%*.*s>", $a, $b, $c; # RESULT: Â«<   ne>â¤Â»

uses C<$a> for the width, C<$b> for the precision, and C<$c> as the value to
format; while:

=for code :skip-test
NYI sprintf '<%*1$.*s>', $a, $b;

would use C<$a> for the width and precision and C<$b> as the value to format.

Here are some more examples; be aware that when using an explicit
index, the C<$> may need escaping:

=for code :skip-test<a part is not yet implemented>
sprintf "%2\$d %d\n",      12, 34;     # RESULT: Â«34 12â¤â¤Â»
sprintf "%2\$d %d %d\n",   12, 34;     # RESULT: Â«34 12 34â¤â¤Â»
sprintf "%3\$d %d %d\n",   12, 34, 56; # RESULT: Â«56 12 34â¤â¤Â»
NYI sprintf "%2\$*3\$d %d\n",  12, 34,  3; # " 34 12\n"
NYI sprintf "%*1\$.*f\n",       4,  5, 10; # "5.0000\n"

Other examples:

=for code :skip-test
NYI sprintf "%ld a big number", 4294967295;
NYI sprintf "%%lld a bigger number", 4294967296;
sprintf('%c', 97);                  # RESULT: Â«aâ¤Â»
sprintf("%.2f", 1.969);             # RESULT: Â«1.97â¤Â»
sprintf("%+.3f", 3.141592);         # RESULT: Â«+3.142â¤Â»
sprintf('%2$d %1$d', 12, 34);       # RESULT: Â«34 12â¤Â»
sprintf("%x", 255);                 # RESULT: Â«ffâ¤Â»

Special case: CÂ«sprintf("<b>%s</b>\n", "PerlÂ 6")Â» will not work, but
one of the following will:

=for code
sprintf Q:b "<b>%s</b>\n",  "PerlÂ 6"; # RESULT: Â«<b>PerlÂ 6</b>â¤â¤Â»
sprintf     "<b>\%s</b>\n", "PerlÂ 6"; # RESULT: Â«<b>PerlÂ 6</b>â¤â¤Â»
sprintf     "<b>%s\</b>\n", "PerlÂ 6"; # RESULT: Â«<b>PerlÂ 6</b>â¤â¤Â»



=end pod

# vim: expandtab softtabstop=4 shiftwidth=4 ft=perl6
