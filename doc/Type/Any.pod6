=begin pod

=TITLE class Any

=SUBTITLE Thing/object

    class Any is Mu {}

While L<Mu|/type/Mu> is the root of the Perl 6 class hierarchy, L<Any|/type/Any>
is the class that serves as a default base class for new classes, and as the
base class for most built-in classes.

Since Perl 6 intentionally confuses items and single-element lists, most methods
in L<Any|/type/List> are also present on class L<List|/type/Any>, and coerce to
List or a list-like type.

=head1 Methods

=head2 method ACCEPTS

Defined as:

    multi method ACCEPTS(Any:D: Mu $other)

Usage:

=begin code :lang<pseudo>
EXPR.ACCEPTS(EXPR);
=end code

Returns C<True> if C<$other === self> (i.e. it checks object identity).

Many built-in types override this for more specific comparisons

=head2 method any

Defined as:

    method any(--> Junction:D)

Interprets the invocant as a list and creates an
L<any|/routine/any>-L<Junction|/type/Junction> from it.

    say so 2 == <1 2 3>.any;        # OUTPUT: «True␤»
    say so 5 == <1 2 3>.any;        # OUTPUT: «False␤»

=head2 method all

Defined as:

    method all(--> Junction:D)

Interprets the invocant as a list and creates an
L<all|/routine/all>-L<Junction|/type/Junction> from it.

    say so 1 < <2 3 4>.all;         # OUTPUT: «True␤»
    say so 3 < <2 3 4>.all;         # OUTPUT: «False␤»

=head2 method one

Defined as:

    method one(--> Junction:D)

Interprets the invocant as a list and creates a
L<one|/routine/one>-L<Junction|/type/Junction> from it.

    say so 1 == (1, 2, 3).one;      # OUTPUT: «True␤»
    say so 1 == (1, 2, 1).one;      # OUTPUT: «False␤»

=head2 method none

Defined as:

    method none(--> Junction:D)

Interprets the invocant as a list and creates a
L<none|/routine/none>-L<Junction|/type/Junction> from it.

    say so 1 == (1, 2, 3).none;     # OUTPUT: «False␤»
    say so 4 == (1, 2, 3).none;     # OUTPUT: «True␤»

=head2 method list

Defined as:

    multi method list(Any:U: --> List)
    multi method list(Any:D \SELF: --> List)


Applies the infix L«C<,>|/routine/,» operator to the invocant and returns
the resulting L<List|/type/List>:

    say 42.list.^name;           # OUTPUT: «List␤»
    say 42.list.elems;           # OUTPUT: «1␤»

Subclasses of C<Any> may choose to return any I<core> type that
does the L<Positional|/type/Positional> role
from L«C<.list>|/routine/list». Use L«C<.List>|/routine/List» to
coerce specifically to L<List|/type/List>.

X<|@ list contextualizer>
C<@> can also be used as a list or C<Positional> contextualizer:

=for code
my $not-a-list-yet = $[1,2,3];
say $not-a-list-yet.perl;             # OUTPUT: «$[1, 2, 3]␤»
my @maybe-a-list = @$not-a-list-yet;
say @maybe-a-list.^name;              # OUTPUT: «Array␤»

In the first case, the list is I<itemized>. C<@> as a prefix puts the initial
scalar in a list context by calling C<.list> and turning it into an C<Array>.

=head2 method push

Defined as:

    method push(|values --> Positional:D)

The method push is defined for undefined invocants and allows for
autovivifying undefined to an empty L<Array|/type/Array>, unless the undefined value
implements L<Positional|/type/Positional> already. The argument provided will then be pushed
into the newly created Array.

    my %h;
    say %h<a>;     # OUTPUT: «(Any)␤»      <-- Undefined
    %h<a>.push(1); # .push on Any
    say %h;        # OUTPUT: «{a => [1]}␤» <-- Note the Array

=head2 routine reverse

Defined as:

    multi sub    reverse(*@list  --> Seq:D)
    multi method reverse(List:D: --> Seq:D)

Returns a L<Seq|/type/Seq> with the same elements in reverse order.

Note that C<reverse> always refers to reversing elements of a list;
to reverse the characters in a string, use L<flip|/routine/flip>.

Examples:

    say <hello world!>.reverse;     # OUTPUT: «(world! hello)␤»
    say reverse ^10;                # OUTPUT: «(9 8 7 6 5 4 3 2 1 0)␤»

=head2 method sort

Defined as:

    multi method sort()
    multi method sort(&custom-routine-to-use)

Sorts iterables with L<cmp|/routine/cmp> or given code object and returns a new L<Seq|/type/Seq>.
Optionally, takes a L<Callable|/type/Callable> as a positional parameter, specifying how to
sort.

Examples:

    say <b c a>.sort;                           # OUTPUT: «(a b c)␤»
    say 'bca'.comb.sort.join;                   # OUTPUT: «abc␤»
    say 'bca'.comb.sort({$^b cmp $^a}).join;    # OUTPUT: «cba␤»
    say '231'.comb.sort(&infix:«<=>»).join;     # OUTPUT: «123␤»

=head2 method map

Defined as:

    multi method map(\SELF: &block;; :$label, :$item)

C<map> will iterate over the invocant and apply the number of positional
parameters of the code object from the invocant per call.  The returned values
of the code object will become elements of the returned L<Seq|/type/Seq>.

The C<:$label> and C<:$item> are useful only internally, since C<for> loops
get converted to C<map>s. The C<:$label> takes an existing L<Label|/type/Label> to label
the C<.map>'s loop with and C<:$item> controls whether the iteration will
occur over C<(SELF,)> (if C<:$item> is set) or C<SELF>.

=head2 method deepmap

Defined as:

    method deepmap(&block --> List) is nodal

C<deepmap> will apply C<&block> to each element and return a new L<List|/type/List> with
the return values of C<&block>, unless the element does the L<Iterable|/type/Iterable> role.
For those elements L<deepmap|/routine/deepmap> will descend recursively into the sublist.

    say [[1,2,3],[[4,5],6,7]].deepmap(* + 1);
    # OUTPUT: «[[2 3 4] [[5 6] 7 8]]␤»

=head2 method duckmap

Defined as:

    method duckmap(&block) is rw is nodal

C<duckmap> will apply C<&block> on each element that behaves in such a way that C<&block> can be applied. If it fails, it will descend recursively if possible, or otherwise return the item without any transformation.

    <a b c d e f g>.duckmap(-> $_ where <c d e>.any { .uc }).say;
    # OUTPUT: «(a b C D E f g)␤»
    (('d', 'e'), 'f').duckmap(-> $_ where <e f>.any { .uc }).say;
    # OUTPUT: «((d E) F)␤»

In the first case, it is applied to C<c>, C<d> and C<e> which are the ones that meet the conditions for the block (C<{ .uc }>) to be applied; the rest are returned as is.

In the second case, the first item is a list that does not meet the condition, so it's visited; that flat list will behave in the same way as the first one. In this case:

    say [[1,2,3],[[4,5],6,7]].duckmap( *² ); # OUTPUT: «[9 9]␤»

You can square anything as long as it behaves like a number. In this case, there are two arrays with 3 elements each; these arrays will be converted into the number 3 and squared. In the next case, however

    say [[1,2,3],[[4,5],6.1,7.2]].duckmap( -> Rat $_ { $_²} );
    # OUTPUT: «[[1 2 3] [[4 5] 37.21 51.84]]␤»

3-item lists are not C<Rat>, so it descends recursively, but eventually only applies the operation to those that walk (or slither, as the case may be) like a C<Rat>.

Although on the surface (and name), C<duckmap> might look similar to L<C<deepmap>|/routine/deepmap>, the latter is applied recursively regardless of the type of the item.

=head2 method nodemap

Defined as:

    method nodemap(&block --> List) is nodal

C<nodemap> will apply C<&block> to each element and return a new L<List|/type/List> with
the return values of C<&block>. In contrast to L<deepmap|/routine/deepmap> it will B<not> descend
recursively into sublists if it finds elements which L<does|/routine/does> the L<Iterable|/type/Iterable> role.

    say [[1,2,3], [[4,5],6,7], 7].nodemap(*+1);
    # OUTPUT: «(4, 4, 8)␤»

    say [[2, 3], [4, [5, 6]]]».nodemap(*+1)
    # OUTPUT: «((3 4) (5 3))␤»

The examples above would have produced the exact same results if we had used
L<map|/routine/map> instead of C<nodemap>. The difference between the two lies in the
fact that L<map|/routine/map> flattens out L<slips|/type/Slip> while C<nodemap> doesn't.

    say [[2,3], [[4,5],6,7], 7].nodemap({.elems == 1 ?? $_ !! slip});
    # OUTPUT: «(() () 7)␤»
    say [[2,3], [[4,5],6,7], 7].map({.elems == 1 ?? $_ !! slip});
    # OUTPUT: «(7)␤»

=head2 method flat

Defined as:

    method flat(--> Seq:D) is nodal

Interprets the invocant as a list, flattens
L<non-containerized|/language/containers> L<Iterable|/type/Iterable>s
into a flat list, and returns that list. Keep in mind L<Map|/type/Map> and
L<Hash|/type/Hash> types are L<Iterable|/type/Iterable> and so will be flattened into lists
of pairs.

    say ((1, 2), (3), %(:42a));      # OUTPUT: «((1 2) 3 {a => 42})␤»
    say ((1, 2), (3), %(:42a)).flat; # OUTPUT: «(1 2 3 a => 42)␤»

Note that L<Arrays|/type/Array> containerize their elements by default, and so
C<flat> will not flatten them. You can use
L<hyper method call|/language/operators#index-entry-postfix_».> to call
L«C<.List>|/routine/List» method on all the inner L<Iterables|/type/Iterable>
and so de-containerize them, so that C<flat> can flatten them:

    say [[1, 2, 3], [(4, 5), 6, 7]]      .flat; # OUTPUT: «([1 2 3] [(4 5) 6 7])␤»
    say [[1, 2, 3], [(4, 5), 6, 7]]».List.flat; # OUTPUT: «(1 2 3 4 5 6 7)␤»

For more fine-tuned options, see L<deepmap|/routine/deepmap>,
L<duckmap|/routine/duckmap>, and
L<signature destructuring|/type/Signature#Destructuring_Parameters>

=head2 method eager

Defined as:

    method eager(--> Seq:D) is nodal

Interprets the invocant as a L<List|/type/List>, evaluates it eagerly, and returns that
L<List|/type/List>.

    my  $range = 1..5;
    say $range;         # OUTPUT: «1..5␤»
    say $range.eager;   # OUTPUT: «(1 2 3 4 5)␤»

=head2 method elems

Defined as:

    method elems(--> Int:D) is nodal

Interprets the invocant as a list, and returns the number of elements in the
list.

    say 42.elems;                   # OUTPUT: «1␤»
    say <a b c>.elems;              # OUTPUT: «3␤»

=head2 method end

    method end(--> Any:D) is nodal

Interprets the invocant as a list, and returns the last index of that list.

    say 6.end;                      # OUTPUT: «0␤»
    say <a b c>.end;                # OUTPUT: «2␤»

=head2 method pairup

Defined as:

    method pairup(--> Seq:D) is nodal

Interprets the invocant as a list, and constructs a list of
L<pairs|/type/Pair> from it, in the same way that assignment to a
L<Hash|/type/Hash> does.  That is, it takes two consecutive elements and
constructs a pair from them, unless the item in the key position already is a
pair (in which case the pair is passed through, and the next list item, if any,
is considered to be a key again).

    say (a => 1, 'b', 'c').pairup.perl;     # OUTPUT: «(:a(1), :b("c")).Seq␤»

=head2 sub item

X<|$ (item contextualizer)>

Defined as:

    proto sub item(|) is pure
    multi item(\x)
    multi item(|c)
    multi item(Mu $a)

Forces given object to be evaluated in item context and returns the value of it.

    say item([1,2,3]).perl;              # OUTPUT: «$[1, 2, 3]␤»
    say item( %( apple => 10 ) ).perl;   # OUTPUT: «${:apple(10)}␤»
    say item("abc").perl;                # OUTPUT: «"abc"␤»

You can also use C<$> as item contextualizer.

    say $[1,2,3].perl;                   # OUTPUT: «$[1, 2, 3]␤»
    say $("abc").perl;                   # OUTPUT: «"abc"␤»

=head2 method Array

Defined as:

    method Array(--> Array:D) is nodal

Coerces the invocant to L<Array|/type/Array>.

=head2 method List

Defined as:

    method List(--> List:D) is nodal

Coerces the invocant to L<List|/type/List>, using the L<list|/routine/list> method.

=head2 serial

Defined as

    proto method serial(|) is nodal
    multi method serial( --> Any)

Returns the self-reference to the instance itself:

=begin code
my $b; # defaults to Any
say $b.serial.^name; # OUTPUT: Any
=end code

=head2 method Hash

Defined as:

    proto method Hash(|) is nodal
    multi method Hash( --> Hash:D)

Coerces the invocant to L<Hash|/type/Hash>.

=head2 method hash

Defined as:

    proto method hash(|) is nodal
    multi method hash(Any:U: --> Hash:D)
    multi method hash(Any:D: --> Hash:D)

When called on a type object, returns an empty L<Hash|/type/Hash>. On instances,
equivalent to assigning the invocant to a C<%->sigilled variable and
returning that.

Subclasses of C<Any> may choose to return any I<core> type that does the
L<Associative|/type/Associative> role from L«C<.hash>|/routine/hash». Use L«C<.Hash>|/routine/Hash» to
coerce specifically to L<Hash|/type/Hash>.

=begin code
my $d; # $d is Any
say $d.hash; # OUTPUT: {}

my %m is Map = a => 42, b => 666;
say %m.hash;  # Map.new((a => 42, b => 666))
say %m.Hash;  # {a => 42, b => 666}
=end code

=head2 method Slip

Defined as:

    method Slip(--> Slip:D) is nodal

Coerces the invocant to L<Slip|/type/Slip>.

=head2 method Map

Defined as:

    method Map(--> Map:D) is nodal

Coerces the invocant to L<Map|/type/Map>.

=head2 method Bag

Defined as:

    method Bag(--> Bag:D) is nodal

Coerces the invocant to L<Bag|/type/Bag>, whereby L<Positionals|/type/Positional>
are treated as lists of values.

=head2 method BagHash

Defined as:

    method BagHash(--> BagHash:D) is nodal

Coerces the invocant to L<BagHash|/type/BagHash>, whereby L<Positionals|/type/Positional>
are treated as lists of values.

=head2 method Set

Defined as:

    method Set(--> Set:D) is nodal

Coerces the invocant to L<Set|/type/Set>, whereby L<Positionals|/type/Positional>
are treated as lists of values.

=head2 method SetHash

Defined as:

    method SetHash(--> SetHash:D) is nodal

Coerces the invocant to L<SetHash|/type/SetHash>, whereby L<Positionals|/type/Positional>
are treated as lists of values.

=head2 method Mix

Defined as:

    method Mix(--> Mix:D) is nodal

Coerces the invocant to L<Mix|/type/Mix>, whereby L<Positionals|/type/Positional>
are treated as lists of values.

=head2 method MixHash

Defined as:

    method MixHash(--> MixHash:D) is nodal

Coerces the invocant to L<MixHash|/type/MixHash>, whereby L<Positionals|/type/Positional>
are treated as lists of values.

=head2 method Supply

Defined as:

    method Supply(--> Supply:D) is nodal

Coerces the invocant first to a C<list> by applying its
L«C<.list>|/routine/list» method, and then to L<Supply|/type/Supply>.

=head2 method min

Defined as:

    multi method min(--> Any:D)
    multi method min(&filter --> Any:D)
    multi sub min(+args, :&by!)
    multi sub min(+args)

Coerces the invocant to L<Iterable|/type/Iterable> and returns the numerically smallest
element. In C<sub> form, the invocant is passed as an argument.

If a L<Callable|/type/Callable> positional argument is provided, each value is passed
into the filter, and its return value is compared instead of the
original value. The original value is still the one returned from
C<min>.

    say (1,7,3).min();              # OUTPUT:«1␤»
    say (1,7,3).min({1/$_});        # OUTPUT:«7␤»
    say min(1,7,3);                 # OUTPUT: «1␤»
    say min(1,7,3,:by( { 1/$_ } )); # OUTPUT: «7␤»

=head2 method max

Defined as:

    multi method max(--> Any:D)
    multi method max(&filter --> Any:D)
    multi sub max(+args, :&by!)
    multi sub max(+args)

Coerces the invocant to L<Iterable|/type/Iterable> and returns the numerically largest
element.

If a L<Callable|/type/Callable> positional argument is provided, each value is passed
into the filter, and the return value is compared instead of the
original value. The original value is still the one returned from
C<max>.

    say (1,7,3).max();              # OUTPUT:«7␤»
    say (1,7,3).max({1/$_});        # OUTPUT:«1␤»
    say max(1,7,3,:by( { 1/$_ } )); # OUTPUT: «1␤»
    say max(1,7,3);                 # OUTPUT: «7␤»

=head2 method minmax

Defined as:

    multi method minmax(--> Range:D)
    multi method minmax(&filter --> Range:D)
    multi sub minmax(+args, :&by!)
    multi sub minmax(+args)

Returns a C<Range> from the smallest to the largest element.

If a L<Callable|/type/Callable> positional argument is provided, each value is passed
into the filter, and its return value is compared instead of the
original value. The original values are still used in the returned
C<Range>.

    say (1,7,3).minmax();        # OUTPUT:«1..7␤»
    say (1,7,3).minmax({-$_});   # OUTPUT:«7..1␤»
    say minmax(1,7,3);           # OUTPUT: «1..7␤»
    say minmax(1,7,3,:by( -* )); # OUTPUT: «7..1␤»

=head2 method minpairs

Defined as:

    multi method minpairs(Any:D: --> Seq:D)

Calls L«C<.pairs>|/routine/pairs» and returns a L<Seq|/type/Seq> with
all of the Pairs with minimum values, as judged by the
L«C<cmp> operator|/routine/cmp»:

    <a b c a b c>.minpairs.perl.put; # OUTPUT: «(0 => "a", 3 => "a").Seq␤»
    %(:42a, :75b).minpairs.perl.put; # OUTPUT: «(:a(42),).Seq␤»

=head2 method maxpairs

Defined as:

    multi method maxpairs(Any:D: --> Seq:D)

Calls L«C<.pairs>|/routine/pairs» and returns a L<Seq|/type/Seq> with all of the
Pairs with maximum values, as judged by the L«C<cmp>
operator|/routine/cmp»:

    <a b c a b c>.maxpairs.perl.put; # OUTPUT: «(2 => "c", 5 => "c").Seq␤»
    %(:42a, :75b).maxpairs.perl.put; # OUTPUT: «(:b(75),).Seq␤»

=head2 method keys

Defined as:

    multi method keys(Any:U: --> List)
    multi method keys(Any:D: --> List)

For defined L<Any|/type/Any> returns its L<keys|/routine/keys> after calling C<list> on it,
otherwise calls C<list> and returns it.

    my $setty = Set(<Þor Oðin Freija>);
    say $setty.keys; # OUTPUT: «(Þor Oðin Freija)␤»

See also L<C<List.keys>|/type/List#routine_keys>.

Trying the same on a class will return an empty list, since most of them
don't really have keys.

=head2 method flatmap

Defined as:

    method flatmap(Any:U: &code --> Seq)

Coerces the invocant to a C<list> by applying its
L«C<.list>|/routine/list» method and uses
L«C<List.flatmap>|/type/List#method_flatmap» on it.

    say Any.flatmap({.reverse}); # OUTPUT: «((Any))␤»

=head2 method roll

Defined as:

    multi method roll(--> Any)
    multi method roll($n --> Seq)

Coerces the invocant to a C<list> by applying its
L«C<.list>|/routine/list» method and uses
L«C<List.roll>|/type/List#routine_roll» on it.

    my Mix $m = ("þ" xx 3, "ð" xx 4, "ß" xx 5).Mix;
    say $m.roll; # OUTPUT: «ð␤»
    say $m.roll; # OUTPUT: «(ß ß þ ß þ)␤»

C<$m>, in this case, is converted into a list and then a (weighted in
this case) dice is rolled on it. See also
L<C<List.roll>|/type/List#routine_roll> for more information.

=head2 method pick

Defined as:

    multi method pick(--> Any)
    multi method pick($n --> Seq)

Coerces the invocant to a C<list> by applying
its L«C<.list>|/routine/list» method and uses
L«C<List.pick>|/type/List#routine_pick» on it.

    my Range $rg = 'α'..'ω';
    say $rg.pick(3); # OUTPUT: «(β α σ)␤»


=head2 method skip

Defined as:

    multi method skip()
    multi method skip(Whatever)
    multi method skip(Callable:D $w)
    multi method skip(Int() $n)

Creates a L<Seq|/type/Seq> from 1-item list's iterator and uses
L«C<Seq.skip>|/type/Seq#method_skip» on it, please check that document for real
use cases; calling C<skip> without argument is equivalent to C<skip(1)>.

Calling it with C<Whatever> will return an empty iterator:

    say <1 2 3>.skip(*);   # OUTPUT: «()␤»

The multi that uses a Callable is intended mainly to be used this way:

    say <1 2 3>.skip(*-1); # OUTPUT: «(3)␤»

Instead of throwing away the first C<$n> elements, it throws away everything
I<but> the elements indicated by the WhateverCode, in this case all but the last
one.

=head2 method prepend

Defined as:

    multi method prepend(--> Array)
    multi method prepend(@values --> Array)

Called with no arguments on an empty variable, it initializes it as an
empty L<Array|/type/Array>; if called with arguments, it creates an array and then
applies  L«C<Array.prepend>|/type/Array#method_prepend» on it.

    my $a;
    say $a.prepend; # OUTPUT: «[]␤»
    say $a;         # OUTPUT: «[]␤»
    my $b;
    say $b.prepend(1,2,3); # OUTPUT: «[1 2 3]␤»

=head2 method unshift

Defined as:

    multi method unshift(--> Array)
    multi method unshift(@values --> Array)

Initializes L<Any|/type/Any> variable as empty L<Array|/type/Array> and calls
L«C<Array.unshift>|/type/Array#routine_unshift» on it.

    my $a;
    say $a.unshift; # OUTPUT: «[]␤»
    say $a;         # OUTPUT: «[]␤»
    my $b;
    say $b.unshift([1,2,3]); # OUTPUT: «[[1 2 3]]␤»

=head2 method first

Defined as:

    multi method first(Bool:D $t)
    multi method first(Regex:D $test, :$end, *%a)
    multi method first(Callable:D $test, :$end, *%a is copy)
    multi method first(Mu $test, :$end, *%a)
    multi method first(:$end, *%a)
    multi sub first(Bool:D $t, |)
    multi sub first(Mu $test, +values, *%a)

In general, coerces the invocant to a C<list> by applying its
L«C<.list>|/routine/list» method and uses
L«C<List.first>|/type/List#routine_first» on it.

However, there are several different methods, and they have (slightly) different
behavior. Using a C<Bool> as the argument will always return a L<Failure>. Using
it as a subroutine is equivalent to using it as a method with the second
argument as the object.

The form that uses a C<$test> will return the first element that smartmatches
it, starting from the end if C<:end> is used.

    say (3..33).first;           # OUTPUT: «3␤»
    say (3..33).first(:end);     # OUTPUT: «33␤»
    say (⅓,⅔…30).first( 0xF );   # OUTPUT: «15␤»
    say first 0xF, (⅓,⅔…30);     # OUTPUT: «15␤»
    say (3..33).first( /\d\d/ ); # OUTPUT: «10␤»

The third and fourth example use the C<Mu $test> forms which smartmatches and
returns the first element that does. The last example uses as a test a regex for
numbers with two figures, and thus the first that meets that criterion is number
10. This last form uses the C<Callable> multi:

    say (⅓,⅔…30).first( * %% 11, :end, :kv ); # OUTPUT: «(65 22)␤»

Besides, starts from the C<:end> and returns the C<:kv> in a list; the I<key> in
this case is simply the position it occupies in the C<Seq>.

=head2 method unique

Defined as:

    multi method unique()
    multi method unique( :&as!, :&with! )
    multi method unique( :&as! )
    multi method unique( :&with! )
    multi sub unique(+values, |c)

Creates a sequence of unique elements either of the object or of C<values> in
the case it's called as a C<sub>.

    <1 2 2 3 3 3>.unique.say; # OUTPUT: «(1 2 3)␤»
    say unique <1 2 2 3 3 3>; # OUTPUT: «(1 2 3)␤»

The C<:as> and C<:with> parameters receive functions that are used for
transforming the item before checking equality, and for checking equality, since
by default the L<C<===>|/routine/===> operator is used:

    ("1", 1, "1 ", 2).unique( as => Int, with => &[==] ).say; #OUTPUT: «(1 2)␤»

Please see L<C<List.unique>|/type/List#routine_unique> for additional examples.

=head2 method repeated

Defined as:

    multi sub    repeated(+values, |c)
    multi method repeated()
    multi method repeated( :&as!, :&with! )
    multi method repeated( :&as! )
    multi method repeated( :&with! )

Similarly to L<C<unique>|/type/Any#method_unique>, finds repeated elements in
C<values> (as a routine) or in the object, using the C<:as> associative argument
as a normalizing function and C<:with> as equality function.

    <1 -1 2 -2 3>.repeated(:as(&abs),:with(&[==])).say; # OUTPUT: «(-1 -2)␤»
    (3+3i, 3+2i, 2+1i).repeated(as => *.re).say;        # OUTPUT: «(3+2i)␤»

It returns the last repeated element before normalization, as shown in the
example above. See L<C<list.repeated>|/type/List#routine_repeated> for more
examples.

=head2 method squish

Defined as:

    method squish(:&as, :&with --> Seq)

Coerces the invocant to a C<list> by applying
its L«C<.list>|/routine/list» method and uses
L«C<List.squish>|/type/List#routine_squish» on it.

    say Any.squish; # OUTPUT: «((Any))␤»


=head2 method permutations

Defined as:

    method permutations(--> Seq)

Coerces the invocant to a C<list> by applying its
L«C<.list>|/routine/list» method and uses
L«C<List.permutations>|/type/List#routine_permutations» on it.

    say <a b c>.permutations;
    # OUTPUT: «((a b c) (a c b) (b a c) (b c a) (c a b) (c b a))␤»
    say set(1,2).permutations;
    # OUTPUT: «((2 => True 1 => True) (1 => True 2 => True))␤»

=head2 method categorize

Defined as:

    method categorize(&mapper --> Hash:D)

Coerces the invocant to a C<list> by applying
its L«C<.list>|/routine/list» method and uses
L«C<List.categorize>|/type/List#routine_categorize» on it.

    say Any.categorize({ $_ }); # OUTPUT: «{(Any) => [(Any)]}␤»

=head2 method classify

Defined as:

    method classify(&mapper -->Hash:D)

Coerces the invocant to a C<list> by applying
its L«C<.list>|/routine/list» method and uses
L«C<List.classify>|/type/List#routine_classify» on it.

    say Any.classify({ $_ }); # OUTPUT: «{(Any) => [(Any)]}␤»

=head2 method produce


=head2 method pairs

Defined as:

    multi method pairs(Any:U:  -->List)
    multi method pairs(Any:D:  -->List)

Converts the invocant to a L<List|/type/List> via the C<list> method and returns the result of L<List.pairs|/type/List#routine_pairs> on it.
Returns an empty L<List|/type/List> if the invocant is undefined:


    say Any.pairs; # OUTPUT: «()␤»
    my $a;
    say $a.pairs;  # OUTPUT: «()»
    $a = Any.new;
    say $a.pairs;  # OUTPUT: «(0 => Any.new)»


=head2 method antipairs

Defined as:

    multi method antipairs(Any:U:  -->List)
    multi method antipairs(Any:D:  -->List)

Converts the invocant to a L<List|/type/List> via the C<list> method and returns the result of
L<List.antipairs|/type/List#routine_antipairs> on it.
Returns an empty L<List|/type/List> if the invocant is undefined:

    my $a;
    say $a.antipairs;      # OUTPUT: «()»
    $a = Any.new;
    say $a.antipairs;      # OUTPUT: «(Any.new => 0)»


=head2 method kv

Defined as:

    multi method kv(Any:U:  -->List)
    multi method kv(Any:D:  -->List)

Invokes C<list> on the invocant and returns the result of
L<List.kv|/type/List#routine_kv> on it.
Returns an empty L<List|/type/List> if the invocant is undefined:

    my $a;
    say $a.kv;      # OUTPUT: «()»
    $a = Any.new;
    say $a.kv;      # OUTPUT: «(0 Any.new)»
    say Any.kv;     # OUTPUT: «()␤»

=head2 method toggle

Defined as:

    method toggle(Any:D: *@conditions where .all ~~ Callable:D, Bool :$off  --> Seq:D)

L<Iterates|/routine/iterator> over the invocant, producing a L<Seq|/type/Seq>,
toggling whether the received values are propagated to the result on and off,
depending on the results of calling L<Callables|/type/Callable> in
C<@conditions>:

=for code
say (1..15).toggle(* < 5, * > 10, * < 15); # OUTPUT: «(1 2 3 4 11 12 13 14)␤»
say (1..15).toggle(:off, * > 2, * < 5, * > 10, * < 15); # OUTPUT: «(3 4 11 12 13 14)␤»

Imagine a switch that's either on or off (C<True> or C<False>), and values are
produced if it's on. By default, the initial state of that switch is in "on"
position, unless C<:$off> is set to a true value, in which case the initial
state will be "off".

A L<Callable|/type/Callable> from the L<head|/routine/head> of C<@conditions> is
taken (if any are available) and it becomes the current tester. Each value from
the original sequence is tested by calling the tester L<Callable|/type/Callable>
with that value. The state of our imaginary switch is set to the return value
from the tester: if it's truthy, set switch to "on",  otherwise set it to "off".

Whenever the switch is I<toggled> (i.e. switched  from "off" to "on" or from
"on" to "off"), the current tester L<Callable|/type/Callable> is replaced by the
next L<Callable|/type/Callable> in C<@conditions>, if available, which will be
used to test any further values. If no more tester Callables are available, the
switch will remain in its current state until the end of iteration.

    =begin code
    # our original sequence of elements:
    say list ^10; # OUTPUT: «(0 1 2 3 4 5 6 7 8 9)␤»
    # toggled result:
    say ^10 .toggle: * < 4, * %% 2, &is-prime; # OUTPUT: «(0 1 2 3 6 7)␤»

    # First tester Callable is `* < 4` and initial state of switch is "on".
    # As we iterate over our original sequence:
    # 0 => 0 < 4 === True  switch is on, value gets into result, switch is
    #                      toggled, so we keep using the same Callable:
    # 1 => 1 < 4 === True  same
    # 2 => 2 < 4 === True  same
    # 3 => 3 < 4 === True  same
    # 4 => 4 < 4 === False switch is now off, "4" does not make it into the
    #                      result. In addition, our switch got toggled, so
    #                      we're switching to the next tester Callable
    # 5 => 5 %% 2 === False  switch is still off, keep trying to find a value
    # 6 => 6 %% 2 === True   switch is now on, take "6" into result. The switch
    #                        toggled, so we'll use the next tester Callable
    # 7 => is-prime(7) === True  switch is still on, take value and keep going
    # 8 => is-prime(8) === False switch is now off, "8" does not make it into
    #                            the result. The switch got toggled, but we
    #                            don't have any more tester Callables, so it
    #                            will remain off for the rest of the sequence.
    =end code

Since the toggle of the switch's state loads the next tester
L<Callable|/type/Callable>, setting C<:$off> to a C<True> value affects when
first tester is discarded:

    =begin code
    # our original sequence of elements:
    say <0 1 2>; # OUTPUT: «(0 1 2)␤»
    # toggled result:
    say <0 1 2>.toggle: * > 1; # OUTPUT: «()␤»

    # First tester Callable is `* > 1` and initial state of switch is "on".
    # As we iterate over our original sequence:
    # 0 => 0 > 1 === False  switch is off, "0" does not make it into result.
    #                      In addition, switch got toggled, so we change the
    #                      tester Callable, and since we don't have any more
    #                      of them, the switch will remain "off" until the end
    =end code

    =begin code
    # our original sequence of elements:
    say <0 1 2>; # OUTPUT: «(0 1 2)␤»
    # toggled result:
    say <0 1 2>.toggle: :off, * > 1; # OUTPUT: «(2)␤»

    # First tester Callable is `* > 1` and initial state of switch is "off".
    # As we iterate over our original sequence:
    # 0 => 0 > 1 === False  switch is off, "0" does not make it into result.
    #                       The switch did NOT get toggled this time, so we
    #                       keep using our current tester Callable
    # 1 => 1 > 1 === False  same
    # 2 => 2 > 1 === True   switch is on, "2" makes it into the result
    =end code


=head2 method tree

Defined as:

    method tree(--> Any)

Returns the class if it's undefined or if it's not L<Iterable|/type/Iterable>,
returns the result of applying the C<tree> method its invocant otherwise.

    say Any.tree; # OUTPUT: «Any␤»

C<.tree> has different prototypes for L<Iterable|/type/Iterable> elements.

    my @floors = ( 'A', ('B','C', ('E','F','G')));
    say @floors.tree(1).flat.elems; # OUTPUT: «6␤»
    say @floors.tree(2).flat.elems; # OUTPUT: «2␤»
    say @floors.tree( *.join("-"), *.join("—"), *.join("|" )); # OUTPUT: «A-B—C—E|F|G␤»

With a number, it iteratively applies C<tree> to every element in the
lower level; the first instance will apply C<.tree(0)> to every
element in the array, and likewise for the next example.

The second prototype applies the C<Whatever> code passed as arguments
to every level in turn; the first argument will go to level 1 and so
on. C<tree> can, thus, be a great way to process complex all levels of
complex, multi-level, data structures.

=head2 method nl-out

Defined as:

    method nl-out(--> Str)

Returns Str with the value of "\n". See
L«C<IO::Handle.nl-out>|/type/IO::Handle#method_nl-out» for the
details.

    say Any.nl-out; # OUTPUT: «␤␤»

=head2 method invert

Defined as:

    method invert(--> List)

Returns an empty List.

    say Any.invert; # OUTPUT: «()␤»

=head2 method combinations

Defined as:

    method combinations(--> Seq)

Coerces the invocant to a C<list> by applying its L«C<.list>|/routine/list»
method and uses L«C<List.combinations>|/type/List#routine_combinations» on it.

    say Any.combinations; # OUTPUT: «(() ((Any)))␤»

=head2 method grep

Defined as:

    method grep(Mu $matcher, :$k, :$kv, :$p, :$v --> Seq)

Coerces the invocant to a C<list> by applying
its L«C<.list>|/routine/list» method and uses
L«C<List.grep>|/type/List#routine_grep» on it.

Based on C<$matcher> value can be either C<((Any))> or empty List.

    my $a;
    say $a.grep({ True }); # OUTPUT: «((Any))␤»
    say $a.grep({ $_ });   # OUTPUT: «()␤»

=head2 method append

Defined as:

    proto method append(|) is nodal {*}
    multi method append(Any:U \SELF: |values --> Array)

In the case the instance is not a positional-thing, it instantiates it as a new
L<Array|/type/Array>, otherwise clone the current instance. After that, it
appends the values passed as arguments to the array obtained calling
L«C<Array.append>|/type/Array#method_append» on it.

    my $a;
    say $a.append; # OUTPUT: «[]␤»
    my $b;
    say $b.append((1,2,3)); # OUTPUT: «[1 2 3]␤»

=head2 method values

Defined as:

    multi method values(Any:U:)
    multi method values(Any:D:)

Will return an empty list for undefined or class arguments, and the object
converted to a list otherwise.

    say (1..3).values; # OUTPUT: «(1 2 3)␤»
    say List.values;   # OUTPUT: «()␤»

=head2 method collate

Defined as:

    method collate()

Collate sorts taking into account Unicode grapheme characteristics; that is,
sorting more or less as one would expect instead of using the order in which
their codepoints appear. C<collate> will behave this way if the object it is
applied to is C<Iterable>.

=begin code
say ('a', 'Z').sort; # (Z a)
say ('a', 'Z').collate; # (a Z)
say <ä a o ö>.collate; # (a ä o ö)
my %hash = 'aa' => 'value', 'Za' => 'second';
say %hash.collate; # (aa => value Za => second);
=end code

This method is affected by the X<B<$*COLLATION>|$*COLLATION> variable, which
configures the four X<collation levels>. While the Primary, Secondary and
Tertiary mean different things for different scripts, for the Latin script used
in English they mostly correspond with Primary being Alphabetic, Secondary being
Diacritics and Tertiary being Case.

In the example below you can see how when we disable tertiary collation which in
Latin script generally is for case, and also disable quaternary which breaks
any ties by checking the codepoint values of the strings, we get B<Same> back
for B<A> and B<a>:

    $*COLLATION.set(:quaternary(False), :tertiary(False));
    say 'a' coll 'A'; #OUTPUT: «Same␤»
    say ('a','A').collate == ('A','a').collate; # OUTPUT: «True␤»

The variable affects the L<C<coll>|/routine/coll> operator as shown as well as
this method.

=head2 method cache

Defined as:

    method cache()

Provides a L<List|/type/List> representation of the object itself, calling
the method C<list> on the instance.

=head2 method batch

Defined as:

    multi method batch(Int:D $batch --> Seq)
    multi method batch(Int:D :$elems --> Seq)

Coerces the invocant to a C<list> by applying
its L«C<.list>|/routine/list» method and uses
L«C<List.batch>|/type/List#method_batch» on it.

=end pod

# vim: expandtab softtabstop=4 shiftwidth=4 ft=perl6
