=begin pod

=TITLE class DateTime

=SUBTITLE Calendar date with time

    class DateTime does Dateish {}

For handling points in civil time, a C<DateTime> object stores year, month,
day, hour, minute (all L<Int|/type/Int>), second (potentially fractional) and
a time zone.

It provides methods for calculating with date and time.

C<DateTime> methods are immutable; if you are tempted to modify one, create a
modified copy instead.

Time zones are handled as L<Integers|/type/Int> in B<seconds> offset from UTC,
not by time zone name.

=begin code
use v6.c;
my $dt = DateTime.new(
    year    => 2015,
    month   => 11,
    day     => 21,
    hour    => 16,
    minute  => 1,
);

say $dt;                            # OUTPUT: «2015-11-21T16:01:00Z␤»
say $dt.later(days => 20);          # OUTPUT: «2015-12-11T16:01:00Z␤»
say $dt.truncated-to('hour');       # OUTPUT: «2015-11-21T16:00:00Z␤»
say $dt.in-timezone(-8 * 3600);     # OUTPUT: «2015-11-21T08:01:00-0800␤»

my $now = DateTime.now(formatter => { sprintf "%02d:%02d", .hour, .minute });
say $now;                           # 12:45 (or something like that)
=end code

=head1 Methods

=head2 method new

Defined as:

=for code :skip-test
multi method new(Int :$year!, Int :$month = 1, Int :$day = 1,
                 Int :$hour = 0, Int :$minute = 0, :$second = 0,
                 Int :$timezone = 0, :&formatter)
multi method new(Date :$date!,
                 Int :$hour = 0, Int :$minute = 0, :$second = 0,
                 Int :$timezone = 0, :&formatter)
multi method new(Int() $year, Int() $month, Int() $day,
                 Int() $hour, Int $minute, $second,
                 Int() :$timezone = 0, :&formatter)
multi method new(Instant:D $i,  :$timezone=0, :&formatter)
multi method new(Int:D $posix,  :$timezone=0, :&formatter)
multi method new(Str:D $format, :$timezone=0, :&formatter)

Creates a new C<DateTime> object. One option for creating a new DateTime object
is from the components (year, month, day, hour, ...) separately. Another is to
pass a L<Date|/type/Date> object for the date component, and specify the time
component-wise. Yet another is to obtain the time from an
L<Instant|/type/Instant>, and only supply the time zone and formatter. Or
instead of an Instant you can supply an L<Int|/type/Int> as a UNIX timestamp.

You can also supply a L<Str|/type/Str> formatted in ISO 8601 timestamp
notation or as a full L<RFC 3339|https://tools.ietf.org/html/rfc3339>
date and time.  Strings should be formatted as C<yyyy-mm-ddThh:mm:ssZ>
or C<yyyy-mm-ddThh:mm:ss+0100>.  We are somewhat less restrictive than the
ISO 8601 standard, as we allow Unicode digits and mixing of condensed
and extended time formats.

An invalid input string throws an exception of type
L<X::Temporal::InvalidFormat>. If you supply a string that includes a time
zone and supply the C<timezone> named argument, an exception of type
L<X::DateTime::TimezoneClash> is thrown.

    my $datetime = DateTime.new(year => 2015,
                                month => 1,
                                day => 1,
                                hour => 1,
                                minute => 1,
                                second => 1,
                                timezone => 1);
    $datetime = DateTime.new(date => Date.new('2015-12-24'),
                             hour => 1,
                             minute => 1,
                             second => 1,
                             timezone => 1);
    $datetime = DateTime.new(2015, 1, 1, # First January of 2015
                             1, 1, 1);   # Hour, minute, second with default timezone
    $datetime = DateTime.new(now);                       # Instant.
    # from a Unix timestamp
    say $datetime = DateTime.new(1470853583);            # OUTPUT: «2016-08-10T18:26:23Z␤»
    $datetime = DateTime.new("2015-01-01T03:17:30+0500") # Formatted string

=head2 method now

Defined as:

    method now(:$timezone = $*TZ, :&formatter --> DateTime:D)

Creates a new C<DateTime> object from the current system time. A custom
L<formatter> and L<timezone> can be provided. The C<:$timezone> is
the offset B<in seconds> from L<GMT|https://en.wikipedia.org/wiki/Greenwich_Mean_Time>
and defaults to the value of L«C<$*TZ> variable|/language/variables#index-entry-%24*TZ».

    say DateTime.now;

=head2 method clone

Defined as:

    method clone(:$year, :$month, :$day, :$hour, :$minute, :$second, :$timezone, :&formatter)

Creates a new C<DateTime> object based on the invocant, but with the given
arguments overriding the values from the invocant.

    say DateTime.new('2015-12-24T12:23:00Z').clone(hour => 0);
    # OUTPUT: «2015-12-24T00:23:00Z␤»

Note that this can lead to invalid dates in some circumstances:

    say DateTime.new("2012-02-29T12:34:56Z").clone(year => 2015);
    CATCH { default { put .^name, ': ', .Str } };
    # OUTPUT: «X::OutOfRange: Day out of range. Is: 29, should be in 1..28␤»

=head2 method hh-mm-ss

Defined as:

    method hh-mm-ss(DateTime:D: --> Str:D)

Returns the time represented by the object as a string in 24-hour HH:MM:SS format:

    say DateTime.new("2052-02-29T22:34:56Z").hh-mm-ss;
    # OUTPUT: «22:34:56␤»

=head2 method hour

Defined as:

    method hour(DateTime:D: --> Int:D)

Returns the hour component.

    say DateTime.new('2012-02-29T12:34:56Z').hour;      # OUTPUT: «12␤»

=head2 method minute

Defined as:

    method minute(DateTime:D: --> Int:D)

Returns the minute component.

    say DateTime.new('2012-02-29T12:34:56Z').minute;     # OUTPUT: «34␤»

=head2 method second

Defined as:

    method second(DateTime:D:)

Returns the second component, including potentially fractional seconds.

    say DateTime.new('2012-02-29T12:34:56Z').second;     # OUTPUT: «56␤»
    say DateTime.new('2012-02-29T12:34:56.789Z').second; # OUTPUT: «56.789␤»
    say DateTime.new('2012-02-29T12:34:56,789Z').second; # comma also ok

=head2 method whole-second

Defined as:

    method whole-second(DateTime:D:)

Returns the second component, rounded down to an L<Int|/type/Int>.

    say DateTime.new('2012-02-29T12:34:56.789Z').whole-second;      # OUTPUT: «56␤»

=head2 method timezone

Defined as:

    method timezone(DateTime:D: --> Int:D)

Returns the time zone B<in seconds> as an offset from UTC.

    say DateTime.new('2015-12-24T12:23:00+0200').timezone;          # OUTPUT: «7200␤»

=head2 method offset

Defined as:

    method offset(DateTime:D: --> Int:D)

Returns the time zone B<in seconds> as an offset from UTC. This is an alias for
L<#method timezone>.

    say DateTime.new('2015-12-24T12:23:00+0200').offset;            # OUTPUT: «7200␤»

=head2 method offset-in-minutes

Defined as:

    method offset-in-minutes(DateTime:D: --> Real:D)

Returns the time zone in minutes as an offset from UTC.

    say DateTime.new('2015-12-24T12:23:00+0200').offset-in-minutes; # OUTPUT: «120␤»

=head2 method offset-in-hours

Defined as:

    method offset-in-hours(DateTime:D: --> Real:D)

Returns the time zone in hours as an offset from UTC.

    say DateTime.new('2015-12-24T12:23:00+0200').offset-in-hours;   # OUTPUT: «2␤»

=head2 method Str

Defined as:

    method Str(DateTime:D: --> Str:D)

Returns a string representation of the invocant, as done by
L<the formatter|#method formatter>.  If no formatter was specified, an
ISO 8601 timestamp will be returned.

    say DateTime.new('2015-12-24T12:23:00+0200').Str; # OUTPUT: «2015-12-24T12:23:00+02:00␤»

=head2 method Instant

Defined as:

    method Instant(DateTime:D: --> Instant:D)

Returns an L<Instant|/type/Instant> object based on the invocant.

    say DateTime.new('2015-12-24T12:23:00+0200').Instant; # OUTPUT: «2015-12-24T12:23:00+02:00␤»

=head2 method posix

Defined as:

    method posix(DateTime:D: $ignore-timezone = False --> Int:D)

Returns the date and time as a POSIX/UNIX timestamp (seconds since the Epoch,
1st January 1970 UTC).

    say DateTime.new('2015-12-24T12:23:00Z').posix;       # OUTPUT: «1450959780␤»

=head2 method later

Defined as:

    method later(DateTime:D: *%unit)

Returns a DateTime object based on the current one, but with a time delta
applied. The time delta can be passed as a named argument where the argument
name is the unit.

Allowed units are C<second>, C<seconds>, C<minute>, C<minutes>, C<hour>,
C<hours>, C<day>, C<days>, C<week>, C<weeks>, C<month>, C<months>, C<year>,
C<years>.   Please note that the plural forms can only be used with
the C<later> method.

Please note that the special ":2nd" named parameter syntax can be a compact
and self-documenting way of specifying the delta

    say DateTime.new('2015-12-24T12:23:00Z').later(:2years); # OUTPUT: «2017-12-24T12:23:00Z␤»

Since addition of several different time units is not commutative, only one
unit may be passed.

    my $d = DateTime.new(date => Date.new('2015-02-27'));
    say $d.later(month => 1).later(:2days);  # OUTPUT: «2015-03-29T00:00:00Z␤»
    say $d.later(days => 2).later(:1month);  # OUTPUT: «2015-04-01T00:00:00Z␤»
    say $d.later(days => 2).later(:month);   # same, as +True === 1

Negative offsets are allowed, though L<#method earlier> is more idiomatic for
that.

=head2 method earlier

Defined as:

    method earlier(DateTime:D: *%unit)

Returns a DateTime object based on the current one, but with a time delta
towards the past applied. See L<#method later> for usage.

    my $d = DateTime.new(date => Date.new('2015-02-27'));
    say $d.earlier(month => 1).earlier(:2days);  # OUTPUT: «2015-01-25T00:00:00Z␤»

=head2 method truncated-to

Defined as:

    method truncated-to(DateTime:D: Cool $unit)

Returns a copy of the invocant, with everything smaller than the specified
unit truncated to the smallest possible value.

    my $d = DateTime.new("2012-02-29T12:34:56.946314Z");
    say $d.truncated-to('second');      # OUTPUT: «2012-02-29T12:34:56Z␤»
    say $d.truncated-to('minute');      # OUTPUT: «2012-02-29T12:34:00Z␤»
    say $d.truncated-to('hour');        # OUTPUT: «2012-02-29T12:00:00Z␤»
    say $d.truncated-to('day');         # OUTPUT: «2012-02-29T00:00:00Z␤»
    say $d.truncated-to('month');       # OUTPUT: «2012-02-01T00:00:00Z␤»
    say $d.truncated-to('year');        # OUTPUT: «2012-01-01T00:00:00Z␤»

DateTimes with fractional seconds can be truncated to whole seconds with
C<.truncated-to('second')>.

=head2 method Date

Defined as:

    multi method Date(DateTime:U --> Date:U)
    multi method Date(DateTime:D --> Date:D)

Converts the invocant to L«C<Date>|/type/Date».

    say DateTime.new("2012-02-29T12:34:56.946314Z").Date; # OUTPUT: «2012-02-29␤»
    say DateTime.Date;                                    # OUTPUT: «(Date)␤»

=head2 method DateTime

Defined as:

    method DateTime(--> DateTime)

Returns the invocant.

    say DateTime.new("2012-02-29T12:34:56.946314Z").DateTime; # 2012-02-29T12:34:56.946314Z
    say DateTime.DateTime;                                    # OUTPUT: «(DateTime)␤»

=head2 method utc

Defined as:

    method utc(DateTime:D: --> DateTime:D)

Returns a DateTime object for the same time, but in time zone UTC.

    say DateTime.new('2015-12-24T12:23:00+0200').utc;  # OUTPUT: «2015-12-24T10:23:00Z␤»

=head2 method in-timezone

Defined as:

    method in-timezone(DateTime:D: $timezone = 0 --> DateTime:D)

Returns a DateTime object for the same time, but in the specified C<$timezone>, which is
the offset B<in seconds> from L<GMT|https://en.wikipedia.org/wiki/Greenwich_Mean_Time>.

    say DateTime.new('2015-12-24T12:23:00Z').in-timezone(3600 + 1800); # OUTPUT: «2015-12-24T13:53:00+0130␤»

=head2 method local

Defined as:

    method local(DateTime:D: --> DateTime:D)

Returns a DateTime object for the same time, but in the local time zone
(L«C<$*TZ>|/language/variables#index-entry-%24*TZ»).

    my $*TZ = -3600;
    say DateTime.new('2015-12-24T12:23:00+0200').local; # OUTPUT: «2015-12-24T09:23:00-0100␤»

=head2 sub infix:<->

    multi sub infix:<-> (DateTime:D, Duration:D --> DateTime:D)
    multi sub infix:<-> (DateTime:D, DateTime:D --> Duration:D)

Takes a L«C<DateTime>|/type/DateTime» to subtract from and either a
L«C<Duration>|/type/Duration» or another C<DateTime> object. Returns a new
C<DateTime> object or the C<Duration> between the two dates, respectively. When
subtracting C<Duration>, timezone of the original C<DateTime> is preserved
in the returned C<DateTime> object.

    say perl DateTime.new(:2016year) - DateTime.new(:2015year):;           # OUTPUT: «Duration.new(31536001.0)␤»
    say DateTime.new(:2016year, :3600timezone) - Duration.new(31536001.0); # OUTPUT: «2015-01-01T00:00:00+01:00␤»

=head2 sub infix:<+>

    multi sub infix:<+> (DateTime:D, Duration:D --> DateTime:D)
    multi sub infix:<+> (Duration:D, DateTime:D --> DateTime:D)

Takes a L«C<DateTime>|/type/DateTime» and increases it by the given
L«C<Duration>|/type/Duration», preserving the timezone.

    say DateTime.new(:2015year) + Duration.new(31536001.0);        # OUTPUT: «2016-01-01T00:00:00Z␤»
    say Duration.new(42) + DateTime.new(:2015year, :3600timezone); # OUTPUT: «2015-01-01T00:00:42+01:00␤»

=end pod
