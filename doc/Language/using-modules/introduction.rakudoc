=begin pod :kind("Language") :subkind("Modules") :category("tutorial")

=TITLE Modules: An Introduction

=SUBTITLE Modules and How they Work

I<N.B.> "Module" is an overloaded term in Raku; this document
focuses on use of the C<module> declarator.

=head1 What are modules?

Modules, like classes and grammars, are a kind of
L<package|/language/packages>. Module objects are instances of the
C<ModuleHOW> metaclass; this provides certain capabilities useful for
creating namespaces, versioning, delegation and data encapsulation (see
also L<class|/syntax/class> and L<role|/syntax/role>).

To create a module, use the C<module> declarator:

    module M {}
    say M.HOW;   # OUTPUT: «Perl6::Metamodel::ModuleHOW.new␤»

Here we define a new module named C<M>; introspection with C<HOW>
confirms that the metaclass underlying C<M> is
C<Perl6::Metamodel::ModuleHOW>.


=head2 When to use modules

Modules are primarily useful for encapsulating code and data that
do not belong inside a class or role definition. Module contents
(classes, subroutines, variables, etc.) can be exported from a
module with the C<is export> trait; these are available in the
caller's namespace once the module has been imported with C<import>
or C<use>. A module can also selectively expose symbols within its
namespace for qualified reference via C<our>.

=head2 X<Working with modules|Language,import>

To illustrate module scoping and export rules, let's begin by
defining a simple module C<M>:

    module M {
      sub greeting ($name = 'Camelia') { "Greetings, $name!" }
      our sub loud-greeting (--> Str)  { greeting().uc       }
      sub friendly-greeting is export  { greeting('friend')  }
    }

Recall that subroutines are lexically scoped unless otherwise specified
(declarator L<C<sub>|/syntax/sub> is equivalent to C<my sub>), so
C<greeting> in the above example is lexically scoped to the module and
inaccessible outside of it. We've also defined C<loud-greeting> with the
C<our> declarator, which means that in addition to being lexically
scoped it is aliased in the module's symbol table. Finally,
C<friendly-greeting> is marked for export; it will be registered in the
I<caller's> symbol table when the module is imported:

=begin code :skip-test<needs dummy module>
import M;               # import the module
say M::loud-greeting;   # OUTPUT: «GREETINGS, CAMELIA!␤»
say friendly-greeting;  # OUTPUT: «Greetings, friend!␤»
=end code


=head1 More information about Modules

=item1 L<Using Modules: An Introduction|/language/using-modules/introduction> (this page)
=item2 L<Using Modules: Finding and Installing|/language/using-modules/finding-installing>
=item2 L<Using Modules: The Code|/language/using-modules/code>
=item2 L<Using Modules: The Tools|/language/using-modules/tools>

=item1 L<Making Modules: The Terminology|/language/making-modules/terminology>
=item2 L<Making Modules: The Tools|/language/making-modules/tools>
=item2 L<Making Modules: The Code|/language/making-modules/code>
=item2 L<Making Modules: The Configuration and Structure|/language/making-modules/configuration-structure>
=item2 L<Making Modules: Uploading|/language/making-modules/uploading>

=item1 Want to distribute your modules?
See L<Distributions: An introduction|/language/distributions/introduction> and
following pages.

=end pod
