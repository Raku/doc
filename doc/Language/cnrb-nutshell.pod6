=begin pod :tag<convert>

=TITLE 从Ruby到Perl6初步

=SUBTITLE 从Ruby到Perl6初步: 以最熟悉的方式使用?

本文档立足于列出Ruby和Perl6语法和语义上的差异。对Ruby中习惯用法，列举在Perl6
中对应的写法。（而对Perl6中的特性及习语不做论述）。

所以本文档不是为Perl6初学者指导书或者语法概述。预期的读者为具有Ruby语言基础
的开发者。用以指导其快速熟悉Perl6语法和迁移到Perl6开发。

=head1 基础语法

=head2  语句结束分号

Ruby中使用换行符号（有些例外情况），作为表达式的结束。通常在行结尾添加计算符
来使得表达式可以跨行。

    foo +     # Ruby语句结尾的计算符表示表达式跨行
      bar +
      baz

Perl6中表达式必须以C<;>结尾，这种方式能有更好的交互以及对多行语句的兼容性也更好。
这种方式下有两种情况是不需要C<;> 的：一种是用{}括起来的语句块的最后一条语句；还有
就是语句块后面仅有的一行语句。

    if 5 < $x < 10 {
      say "Yep!";
      $x = 17         # 不需要; 语句块}之前的语句。
    }               
    say "Done!"      #  不需要；此处也可以省略，因为}后只有一行的结束语句

=head2 空格

在空格的使用上Ruby的兼容性很强，甚至开启了strict和warnings模式下

    # 有点不和常规，但是在Ruby是合法的
    puts"Hello "+
    (people [ i]
        . name
        ) . upcase+"!"if$greeted[i]<1

Perl6中也非常倡导程序员的自由和创造力，但是平衡了语法兼容和设计目标：一致性、确定性
可扩展语法，支持单向语义分析和有用的错误信息，一些集成的特性，比如自定义操作符清理
，避免开发者偶然误解他们的意图。同时，“code高尔夫”实践被强调；Perl6设计在概念而上更简洁而
不是少敲键盘。

作为结果，Ruby中很多的地方的空格是可选择，在perl6中要么强制必须空格或者禁止使用。
很多这些限制不太可能涉及到很多实际的Perl代码（例如，数组变量和方括号之间的空格是不允许的）。
但是不幸的是有几个地方和Ruby惯用法是冲突地。

=begin item
I< 参数列表空格之前不能有空格>

    foo (3, 4, 1); # Ruby和Perl6中都不对 (Perl6中这表示传递给foo一个类型列表的单个参数
    foo(3, 4, 1);  # 正确方法
    foo 3, 4, 1;   # Ruby和Perl 6 - 可选的无括号风格

=end item

=begin item
I<关键词后B<需要>紧跟一个空格>

    if(a < 0); ...; end         # Ruby中ok
    if ($a < 0) { ... }         # Perl6
    if $a < 0 { ... }           # Perl6,更地道

    while(x > 5); ...; end      # Ruby
    while ($x > 5) { ... }      # Perl6
    while $x > 5 { ... }        # Perl6,更地道

=end item

=begin item
I<前缀或者后缀操作符之前（包括数组/哈希下标）之前不能有空格>

    seen [ :fish ] = 1    # Ruby, 不地道但是合法
    %seen< fish > = 1;    # Perl6, 'seen'后不能有空格
=end item

=begin item
I<如果和前缀/后缀操作符可能有冲突，中间操作符之前则必须有空格>

    n<1     # Ruby (Perl6中，这会和前缀操作符< >冲突)
    $n < 1; # Perl 6

=end item

=head2 C«.» 方法调用, C<.send>

和Ruby中一样方法调用使用．操作:

    person.name    # Ruby
    $person.name   # Perl6

对一个直到运行时才知道名字的对象，对其方法调用:

    object.send(methodname, args);  # Ruby
    $object."$methodname"(@args);   # Perl 6

如果漏掉引号，perl6期望 C<$methodname>为一个C<Method>对象，而不是简单地方法名字。

=head2 变量，标识符，范围以及通用类型

Ruby中，通过变量标识符来表示其作用范围，C<$>表示全局变量，C<@@> 表示类范围，
C<@> 表示实例范围，如果不带标识符则表示局部变量（包括参数）。C<&> 标识符用
来表示方法引用。符号前缀为C<:>,由于它就不是变量，所以不是真正意义上的标识符。

Perl6 标识符主要用来指示包含值的角色，指示值的类型（至少示接口）。无论变量
怎么使用，其标识符是不变的，你可以把他当成是变量名字的一部分。

变量的作用域通过定义是语句(C<my>,C<has>, C<our>, 等等)来指定的。

=head3 变量的作用域

对局部变量，Ruby通过分配时隐式申明，其作用范围限制为当前块。Ruby中C<if>和C<while>
内建的不被当做块或者范围。

Perl6使用显示范围指定，从不隐式创建变量。所有你看到地C<{ ... }>都被作为范围，
包括条件和循环结构的内部。最常用的范围定义如下：

    foo = 7        # Ruby变量，作用范围在第一赋值时候定义，其作用域到当前块的结束

    my  $foo = 7   # Perl6, 词法范围，限制为当前块
    our $foo = 7   # Perl6, 包范围
    has $!foo = 7  # Perl6, 实例范围 (属性)

=head3 C<$>标量

C<$>标识符一直作用于标量变量（例如C<$name>），这些变量都是单值容器。

这是最通常的变量类型，对他的内容没有任何限制。需要指出的是，也可以使用或者引用他
的内容，比如C<$x[1]>，C<$x{"foo"}>或者C<$f("foo")>。

=head3 C<@>数组

C<@>标识符，一直数组变量（例如C<@months>，C<@months[2]>, C<@months[2, 4]>用做
数组切片）。变量使用C<@>标识符，仅用来指明位置的角色，指示位置索引和切片的功能。

=begin item
I<索引>

    puts months[2]; # Ruby
    say @months[2]; # Perl 6

=end item

=begin item
I<值切片>

    puts months[8..11].join(',') # Ruby
    say @months[8..11].join(',') # Perl 6

=end item


=head3 C<%>哈希

C<%>标识符，一直用于哈希变量（例如C<%calories>，C<%calories<apple>>, C<%calories<pear plum>>）
变量使用C<%>标识符，仅能包含关联的角色（关联数组）。

Ruby用方括号来对数组和哈希取值。Perl6则是使用大括号来取哈希值。尖括号的版本也可用
，用来对其内容自动插值（字符串不用引号）：

副词可以用来控制切片的类型。

=begin item
I<索引>

    puts calories["apple"]  # Ruby
    say %calories{"apple"}; # Perl6

    puts calories["apple"]  # Ruby
    puts calories[:apple]   # Ruby, 符号作为键是普通的
    say %calories<apple>;   # Perl6 - 角括号代替单引号
    say %calories«"$key"»;  # Perl6 - 双角括号中双引号插值
=end item

=begin item
I<值切片>

    puts calories.values_at('pear', 'plum').join(',') # Ruby
    puts calories.values_at(%w(pear plum)).join(',')  # Ruby, 更好的方法?
    say %calories{'pear', 'plum'}.join(',');          # Perl 6
    say %calories<pear plum>.join(',');               # Perl 6 (更好的方法)
    my $keys = 'pear plum';
    say %calories«$keys».join(','); # Perl6, 变量插值切片
=end item

=begin item
I<键/值切片>

    say calories.slice('pear', 'plum').join(','); # Ruby,ActiveRecord
    say %calories{'pear', 'plum'}:kv.join(',');   # Perl 6 -使用 :kv副词
    say %calories<pear plum>:kv.join(',');        # Perl 6 (更好的方法)
=end item

=head3 C<&>函数

C<&>标识符和Ruby的类似，用来引用函数对象，一个未调用的命名子函数或操作符
例如，将该名字当做名词，而不是动词。变量使用C<&>标识符仅能包含可调用的角色。

    add = -> n, m { n + m } # Ruby lambda 定义加法函数
    add.(2, 3)              # => 5, Ruby调用lambda
    add.call(2, 3)          # => 5, Ruby调用lambda

    my &add = -> $n, $m { $n + $m } # Perl6加法函数
    &add(2, 3)                      # => 5, 可以用&标识符
    add(2, 3)                       # => 5, 也可以不带也能工作

    foo_method = &foo;     # Ruby
    my &foo_method = &foo; # Perl6

    some_func(&say) # Ruby传递一个函数引用
    some_func(&say) # Perl6用同样的方式，传递一个函数引用


Often in Ruby we pass a block as the last parameter, which is especially used
for DSLs. This can be an implicit parameter called by C<yield>, or an explicit
block prefixed with C<&>. In Perl 6 a C<Callable> parameter is always listed
and called by the variable name (instead of yield), and there are a variety of
ways of invoking the function.

    # Ruby, declare a method and call the implicit block argument
    def f
      yield 2
    end

    # Ruby, invoke f, pass it a block with 1 argument
    f do |n|
      puts "Hi #{n}"
    end

    # Perl 6, declare a method with an explicit block argument
    sub f(&g:($)) {
      g(2)
    }

    # Perl 6, invoke f, pass it a block with 1 argument
    # There are several other ways to do this
    f(-> $n { say "Hi {$n}" }) # Explicit argument
    f -> $n { say "Hi {$n}" }  # Explicit argument, no parenthesis
    f { say "Hi {$^n}" }       # Implicit argument

    # Additionally, if 'f' is a method on instance 'obj' you can use C<:>
    # instead of parenthesis
    obj.f(-> $n { say "Hi {$n}" })  # Explicit argument
    obj.f: -> $n { say "Hi {$n}" }  # Explicit argument, no parenthesis
    obj.f: { say "Hi {$^n}" }       # Implicit argument, no parenthesis

=head3 C<*> Slurpy params / argument expansion

In Ruby you can declare an argument to slurp the remainder of the passed
parameters into an array using a C<*> prefix. It works the same way in Perl 6:

    def foo(*args); puts "I got #{args.length} args!"; end # Ruby
    sub foo(*@args) { say "I got #{@args.elems} args!" }   # Perl 6

You might want to expand an array into a set of arguments. In Perl 6 this is
also done using the C<*> prefix:

    args = %w(a b c)         # Ruby
    foo(*args)

    my @args = <a b c>       # Perl 6
    foo(*@args)

Perl 6 has many more advanced ways of passing parameters and receiving
arguments, see L<Signatures|/language/functions#Signatures> and
L<Captures|/type/Capture>.

=head2 Twigils

Perl 6 additionally uses "twigils", which are further indicators about the
variable and go between the sigil and the rest of the variable name. Examples:

    $foo     # Scalar with no twigil
    $!foo    # Private instance variable
    $.foo    # Instance variable accessor
    $*foo    # Dynamically scoped variable
    $^foo    # A positional (placeholder) parameter to a block
    $:foo    # A named parameter
    $=foo    # POD (documentation) variables
    $?FILE   # Current source filename. The ? twigil indicates a compile-time value
    $~foo    # Sublanguage seen by parser, uncommon

Though each of these examples use the C<$> sigil, most could use C<@>
(Positional) or C<%> (Associative).

=head2 C<:> Symbols

Perl 6 generally uses strings in the places where Ruby uses symbols. A primary
example of this is in hash keys.

    address[:joe][:street] # Typical Ruby nested hash with symbol keys
    %address<joe><street>  # Typical Perl 6 nested hash with string keys

Perl 6 has I<colon-pair> syntax, which can sometimes look like Ruby symbols.

    :age            # Ruby symbol

    # All of these are equivalent for Perl 6
    :age            # Perl 6 pair with implicit True value
    :age(True)      # Perl 6 pair with explicit True value
    age => True     # Perl 6 pair using arrow notation
    "age" => True   # Perl 6 pair using arrow notation and explicit quotes

You could probably get away with using a colon-pair without an explicit value
and pretend that it is a Ruby symbol a lot of the time, but it isn't idiomatic
Perl 6.

=head1 Operators

Many operators have a similar usage in both Ruby and Perl 6:

=item C<,> List Separator
=item C<+> Numeric Addition
=item C<-> Numeric Subtraction
=item C<*> Numeric Multiplication
=item C</> Numeric Division
=item C<%> Numeric Modulus
=item C<**> Numeric Exponentiation
=item C<! && ||> Booleans, high-precedence
=item C<not and or> Booleans, low-precedence

You may use C<$x++> instead of C<x += 1> as a shortcut for incrementing a
variable. This can be used as a pre-increment C<++$x> (increment, return new
value) or post-increment C<$x++> (increment, return old value).

You may use C<$x--> instead of C<x -= 1> as a shortcut for decrementing a
variable. This can be used as a pre-decrement C<--$x> (decrement, return new
value) or post-decrement C<$x--> (decrement, return old value).

=head2 C«== != < > <= >=» Comparisons

Comparisons in Perl 6 are separated between numeric and string to avoid common
errors.

=item C«== != < > <= >=» Comparisons
=item C<eq ne lt gt le ge> String comparisons

For example, using C<==> tries to convert the values to numbers, and C<eq>
tries to convert the values to strings.

=head2 C«<=>» Three-way comparisons

In Ruby, the C«<=>» operator returns -1, 0, or 1.
In Perl 6, they return C<Order::Less>, C<Order::Same>, or C<Order::More>.

C«<=>» forces numeric context for the comparison.

C«leg» ("Less, Equal, or Greater?") forces string context for the comparison.

C«cmp» does either C«<=>» or C<leg>, depending on the existing type of its
arguments.

=head2 C<~~> Smart-match operator

This is a very common matching operator which doesn't exist in Ruby. Here are
some examples:

    say "match!" if $foo ~~ /bar/;      # Regex match
    say "match!" if $foo ~~ "bar";      # String match
    say "match!" if $foo ~~ :(Int, Str) # Signature match (destructure)

See L<S03/Smart matching|https://design.perl6.org/S03.html#Smart_matching>

=head2 C<& | ^> Numeric Bitwise ops
=head2 C<& | ^> Boolean ops

In Perl 6, these single-character ops have been removed, and replaced by
two-character ops which coerce their arguments to the needed context.

    # Infix ops (two arguments; one on each side of the op)
    +&  +|  +^  And Or Xor: Numeric
    ~&  ~|  ~^  And Or Xor: String
    ?&  ?|  ?^  And Or Xor: Boolean

    # Prefix ops (one argument, after the op)
    +^  Not: Numeric
    ~^  Not: String
    ?^  Not: Boolean (same as the ! op)

=head2 C<&.> Conditional chaining operator

Ruby uses the C<&.> operator to chain methods without raising an error if one
invocation returns nil. In Perl 6 use C<.?> for the same purpose.

=head2 C«<< >>» Numeric shift left, right ops, shovel operator

Replaced by C«+<» and C«+>» .

    puts 42 << 3  # Ruby
    say  42 +< 3; # Perl 6

Note that Ruby often uses the C«<<» operator as the "shovel operator", which is
similar to C<.push>. This usage isn't common in Perl 6.

=head2 C«=>» and C<:> Key-Value Separators

In Ruby, C«=>» is used in the context of key/value pairs for Hash literal
declaration and parameter passing. C<:> is used as a shorthand when the left
side is a symbol.

In Perl 6, C«=>» is the Pair operator, which is quite different in
principle, but works the same in many situations.

If you are using C«=>» in a hash literal, then the usage is very similar:

    hash = { "AAA" => 1, "BBB" => 2 }  # Ruby, though symbol keys are more common
    my %hash = ( AAA => 1, BBB => 2 ); # Perl 6, uses ()'s though {} usually work

=head2 C<? :> Ternary operator

In Perl 6, this is spelled with two question marks instead of one question
mark, and two exclamation points instead of one colon. This deviation from the
common ternary operators disambiguates several situations and makes the
false-case stand out more.

    result     = (  score > 60 )  ? 'Pass'  : 'Fail'; # Ruby
    my $result = ( $score > 60 ) ?? 'Pass' !! 'Fail'; # Perl 6

=head2 C<+> String Concatenation

Replaced by the tilde. Mnemonic: think of "stitching" together the two strings with needle and thread.

    $food = 'grape' + 'fruit'  # Ruby
    $food = 'grape' ~ 'fruit'; # Perl 6

=head2 String interpolation

In Ruby, C<"#{foo}s"> deliminates a block embedded in a double-quoted string.
In Perl 6 drop the C<#> prefix: C<"{$foo}s">. As in Ruby, you can place
arbitrary code into the embedded block and it will be rendered in string
context.

Simple variables can be interpolated into a double-quoted string without using the block syntax:

    # Ruby
    name = "Bob"
    puts "Hello! My name is #{name}!"

    # Perl 6
    my $name = "Bob"
    say "Hello! My name is $name!"

The result of an embedded block in Ruby uses C<.to_s> to get string context.
Perl 6 uses C<.Str>, or C<.gist> for the same affect.

=head1 Compound Statements

=head2 Conditionals

=head3 C<if> C<elsif> C<else> C<unless>

This work very similarly between Ruby and Perl 6, but Perl 6 uses C<{ }> to
clearly delineate the blocks.

    # Ruby
    if x > 5
        puts "Bigger!"
    elsif x == 5
        puts "The same!"
    else
        puts "Smaller!"
    end

    # Perl 6
    if x > 5 {
        say "Bigger!"
    } elsif x == 5 {
        puts "The same!"
    } else {
        puts "Smaller!"
    }

Binding the conditional expression to a variable is a little different:

    if x = dostuff(); ...; end   # Ruby
    if dostuff() -> $x {...}     # Perl 6, block-assignment uses arrow

The C<unless> conditional only allows for a single block in Perl 6;
it does not allow for an C<elsif> or C<else> clause.

=head3 C<case>-C<when>

The Perl 6 C<given>-C<when> construct is like a chain of C<if>-C<elsif>-C<else>
statements or like the C<case>-C<when> construct in Ruby. A big difference is
that Ruby uses the C<==> comparison for each condition, but Perl 6 uses the
more general smart-match C<~~> operator.

It has the
general structure:

    given EXPR {
        when EXPR { ... }
        when EXPR { ... }
        default { ... }
    }

In its simplest form, the construct is as follows:

    given $value {
        when "a match" {
            do-something();
        }
        when "another match" {
            do-something-else();
        }
        default {
            do-default-thing();
        }
    }

This is simple in the sense that a scalar value is matched in the C<when>
statements. More generally, the matches are actually smart-matches on the
input value such that lookups using more complex entities such as regexps
can be used instead of scalar values.

=head2 Loops

=head3 C<while> C<until>

Mostly unchanged; parentheses around the conditions are optional, but if used, must
not immediately follow the keyword, or it will be taken as a function call
instead. Binding the conditional expression to a variable is also a little
different:

    while x = dostuff(); ...; end    # Ruby
    while dostuff() -> $x {...}      # Perl 6

=head3 C<for> C<.each>

C<for> loops are rare in Ruby, instead we typically use C<.each> on an
enumerable. The most direct translation to Perl 6 would be to use C<.map> for
both C<.each> and C<.map>, but we typically use a C<for> loop directly.

    # Ruby for loop
    for n in 0..5
        puts "n: #{n}"
    end

    # Ruby, more common usage of .each
    (0..5).each do |n|
        puts "n: #{n}"
    end

    # Perl 6
    for 0..5 -> $n {
        say "n: $n";
    }

    # Perl 6, misusing .map
    (0..5).map: -> $n {
        say "n: $n";
    }

In Ruby, the iteration variable for C<.each> is a copy of the list element, and
modifying it does nothing to the original list. Note that it is a copy of the
REFERENCE, so you can still change the values to which it refers.

In Perl 6, that alias is read-only (for safety) and thus behaves exactly like
Ruby, unless you change C«->» to C«<->».

    cars.each { |car| ... }    # Ruby; read-only reference
    for @cars  -> $car   {...} # Perl 6; read-only
    for @cars <-> $car   {...} # Perl 6; read-write

=head2 Flow Interruption statements

Same as Ruby:

=item C<next>
=item C<redo>

=item2 C<break>

This is C<last> in Perl 6.

=head1 Regular Expressions ( Regex / Regexp )

Regular expressions in Perl 6 are significantly different, and more powerful,
than in Ruby. By default whitespace is ignored and all characters must be
escaped, for example. Regexes can be easily combined and declared in ways to
build efficient grammars.

There are many powerful features of Perl 6 regexes, especially defining entire
grammars using the same syntax. See L<Regexes|/language/regexes> and
L<Grammars|/language/grammars>.

=head2 C<.match> method and C<=~> operator

In Ruby, regex matches can be done against a variable using the C<=~> regexp
match operator or the C<.match> method. In Perl 6, the C<~~> smartmatch op is
used instead, or the C<.match> method.

    next if line   =~ /static/   # Ruby
    next if $line  ~~ /static/;  # Perl 6

    next if line  !~  /dynamic/ ; # Ruby
    next if $line !~~ /dynamic/ ; # Perl 6

    next if line.match(/static/)    # Ruby
    next if $line.match(/static/);  # Perl 6

Alternately, the C<.match> and C<.subst> methods can be used. Note that
C<.subst> is non-mutating. See
L<S05/Substitution|https://design.perl6.org/S05.html#Substitution>.

=head2 C<.sub> and C<.sub!>

In Perl 6 you typically use the C<s///> operator to do regex substitution.

    fixed = line.sub(/foo/, 'bar')        # Ruby, non-mutating
    my $fixed = $line.subst(/foo/, 'bar') # Perl 6, non-mutating

    line.sub!(/foo/, 'bar')   # Ruby, mutating
    $line ~~ s/foo/bar/;      # Perl 6, mutating

=head2 Regex options

Move any options from the end of the regex to the beginning. This may
require you to add the optional C<m> on a plain match like C«/abc/».

    next if $line =~    /static/i # Ruby
    next if $line ~~ m:i/static/; # Perl 6

=head2 Whitespace is ignored, most things must be quoted

In order to aid in readability and reusability, whitespace is not significant
in Perl 6 regexes.

    /this is a test/ # Ruby, boring string
    /this.*/         # Ruby, possibly interesting string

    / this " " is " " a " " test / # Perl 6, each space is quoted
    / "this is a test" / # Perl 6, quoting the whole string
    / this .* /          # Perl 6, possibly interesting string

=head2 Special matchers generally fall under the <> syntax

There are many cases of special matching syntax that Perl 6 regexes support.
They won't all be listed here, but often instead of being surrounded by C<()>,
the assertions will be surrounded by C«<>».

For character classes, this means that:

=item C<[abc]> becomes C«<[abc]>»

=item C<[^abc]> becomes C«<-[abc]>»

=item C<[a-zA-Z]> becomes C«<[a..zA..Z]>»

=item C<[[:upper:]]> becomes C«<:upper>»

=item C<[abc[:upper:]]> becomes C«<[abc]+:Upper>»

For look-around assertions:

=item C<(?=[abc])> becomes C«<?[abc]>»

=item C<(?=ar?bitrary* pattern)> becomes C«<before ar?bitrary* pattern>»

=item C<(?!=[abc])> becomes C«<![abc]>»

=item C<(?!=ar?bitrary* pattern)> becomes C«<!before ar?bitrary* pattern>»

=item C«(?<=ar?bitrary* pattern)» becomes C«<after ar?bitrary* pattern>»

=item C«(?<!ar?bitrary* pattern)» becomes C«<!after ar?bitrary* pattern>»

(Unrelated to <> syntax, the "lookaround" C</foo\Kbar/> becomes C«/foo <( bar )> /»

=item C<(?(?{condition))yes-pattern|no-pattern)> becomes C«[ <?{condition}>
      yes-pattern | no-pattern ]»

=head2 Longest token matching (LTM) displaces alternation

In Perl 6 regexes, C<|> does Longest Token Match (LTM), which decides which
alternation wins an ambiguous match based off of a set of rules, rather than
about which was written first in the regex.

To avoid the new logic, change any C<|> in your Ruby regex to a C<||>.

=head1 File-related operations

=head2 Reading the lines of a text file into an array

Both Ruby and Perl 6 make it easy to read all of the lines in a file into a
single variable, and in both cases each line has the newline removed.

    lines = File.readlines("file")   # Ruby
    my @lines = "file".IO.lines;     # Perl 6, create an IO object from a string

=head2 Iterating over the lines of a text file

Reading the entire file into memory isn't recommended. The C<.lines> method in
Perl 6 returns a lazy sequence, but assigning to an array forces the file to be
read. It is better to iterate over the results:

    # Ruby
    File.foreach("file") do |line|
        puts line
    end

    # Perl 6
    for "file".IO.lines -> $line {
        say $line
    }

=head1 Object Orientation

=head2 Basic classes, methods, attributes

Classes are defined similarly between Ruby and Perl 6, using the C<class>
keyword. Ruby uses C<def> for methods, whereas Perl 6 uses C<method>.

    # Ruby
    class Foo
        def greet(name)
            puts "Hi #{name}!"
        end
    end

    # Perl 6
    class Foo {
        method greet($name) {
            say "Hi $name!"
        }
    }

In Ruby you can use an attribute without declaring it beforehand, and you can
tell it is an attribute because of the C<@> sigil. You can also easily create
accessors using C<attr_accessor> and it's variants. In Perl 6 you use a C<has>
declaration and a variety of sigils. You can use the C<!> twigil for private
attributes or C<.> to create an accessor.

    # Ruby
    class Person
        attr_accessor :age    # Declare .age as an accessor method for @age
        def initialize
            @name = 'default' # Assign default value to private instance var
        end
    end

    # Perl 6
    class Person
        has $.age;              # Declare $!age and accessor methods
        has $!name = 'default'; # Assign default value to private instance var
    end

Creating a new instance of the class uses the C<.new> method. In Ruby you must
manually assign instance variables as needed inside C<initialize>. In Perl 6
you get a default constructor that accepts key/value pairs of accessor
attributes, and can do further setup in the C<BUILD> method. Like with Ruby,
you can override C<new> itself for more advanced functionality, but this is
rare.

    # Ruby
    class Person
        attr_accessor :name, :age
        def initialize(attrs)
            @name = attrs[:name] || 'Jill'
            @age  = attrs[:age] || 42
            @birth_year = Time.now.year - @age
        end
    end
    p = Person.new( name: 'Jack', age: 23 )

    # Perl 6
    class Person
        has $.name = 'Jill';
        has $.age  = 42;
        has $!birth_year;
        method BUILD {
            $!birth_year = now.Date.year - $.age;
        }
    }
    p = Person.new( name => 'Jack', age => 23 )

=head2 Private Methods

Private methods in Perl 6 are declared with a C<!> prefixed in their name, and
are invoked with a C<!> instead of a C<.>.

    # Ruby
    class Foo
        def visible
            puts "I can be seen!"
            hidden
        end

        private
        def hidden
            puts "I cannot easily be called!"
        end
    end

    # Perl 6
    class Foo {
        method visible {
            say "I can be seen!"
            self!hidden
        }

        method !hidden {
            say "I cannot easily be called!"
        }
    }

An important note is that in Ruby child objects can see parent private methods
(so they are more like "protected" methods in other languages). In Perl 6 child
objects cannot call parent private methods.

=head2 Going Meta

Here are a few examples of meta-programming. Note that Perl 6 separates the
meta-methods from the regular methods.

    person = Person.new       # Ruby, create a new person
    my $person = Person.new   # Perl 6, create a new person

    person.class              # Ruby, returns Person (class)
    $person.WHAT              # Perl 6, returns Person (class)

    person.methods            # Ruby
    $person.^methods          # Perl 6, using .^ syntax to access meta-methods

    person.instance_variables # Ruby
    $person.^attributes       # Perl 6

Like Ruby, in Perl 6, everything is an object, but not all operations are
equivalent to C<.send>. Many operators are global functions that use typed
multi-dispatch (function signatures with types) to decide which implementation
to use.

    5.send(:+, 3)    # => 8, Ruby
    &[+](5, 3)       # => 8, Perl 6, reference to infix addition operator

    &[+].^candidates # Perl 6, lists all signatures for the + operator

See L<Meta-Object Protocol|/language/mop> for lots of further details.

=head1 Environment variables

=head2 Perl module library path

In Ruby, one of the environment variables to specify extra search paths for
modules is C<RUBYLIB>.

    $ RUBYLIB="/some/module/lib" ruby program.rb

In Perl 6 this is similar, you merely needs to change the name. As you probably
guessed, you just need to use C<PERL6LIB>:

    $ PERL6LIB="/some/module/lib" perl6 program.p6

As with Ruby, if you don't specify C<PERL6LIB>, you need to specify the
library path within the program via the C<use lib> pragma:

    # Ruby and Perl 6
    use lib '/some/module/lib';

=head1 Misc.

=head2 Importing specific functions from a module

In Ruby there is no built-in way to selectively import/export methods from a
module.

In Perl 6 you specifies the functions which are to be exported by using the
C<is export> role on the relevant subs and I<all> subs with this role are
then exported. Hence, the following module C<Bar> exports the subs C<foo>
and C<bar> but not C<baz>:

    unit module Bar; # remainder of the file is in module Bar { ... }

    sub foo($a) is export { say "foo $a" }
    sub bar($b) is export { say "bar $b" }
    sub baz($z) { say "baz $z" }

To use this module, simply C<use Bar> and the functions C<foo> and C<bar>
will be available

    use Bar;
    foo(1);    #=> "foo 1"
    bar(2);    #=> "bar 2"

If you tries to use C<baz> an "Undeclared routine" error is raised at compile time.

Some modules allow for selectively importing functions, which would look like:

    use Bar <foo>; # Import only foo
    foo(1);        #=> "foo 1"
    bar(2);        # Error!

=head2 C<OptionParser>, parsing command-line flags

Command line argument switch parsing in Perl 6 is done by the parameter list of
the C<MAIN> subroutine.

    # Ruby
    require 'optparse'
    options = {}
    OptionParser.new do |opts|
        opts.banner = 'Usage: example.rb --length=abc'
        opts.on("--length", "Set the file") do |length|
            raise "Length must be > 0" unless length.to_i > 0
            options[:length] = length
        end
        opts.on("--filename", "Set the file") do |filename|
            options[:file] = filename
        end
        opts.on("--verbose", "Increase verbosity") do |verbose|
            options[:verbose] = true
        end
    end.parse!

    puts options[:length]
    puts options[:filename]
    puts 'Verbosity ', (options[:verbose] ? 'on' : 'off')

    ruby example.rb --filename=foo --length=42 --verbose
        42
        foo
        Verbosity on

    ruby example.rb --length=abc
        Length must be > 0

    # Perl 6
    sub MAIN ( Int :$length where * > 0, :filename = 'file.dat', Bool :$verbose ) {
        say $length;
        say $data;
        say 'Verbosity ', ($verbose ?? 'on' !! 'off');
    }

    perl6 example.p6 --file=foo --length=42 --verbose
        42
        foo
        Verbosity on
    perl6 example.p6 --length=abc
        Usage:
          example.p6 [--length=<Int>] [--file=<Any>] [--verbose]

Note that Perl 6 auto-generates a full usage message on error in
command-line parsing.

=head1 RubyGems, External Libraries

See L<https://modules.perl6.org/>, where a growing number of Perl 6 libraries
are available along with the tools to manage them.

If the module that you were using has not been converted to Perl 6, and no
alternative is listed in this document, then its use under Perl 6 may not
have been addressed yet.

You can experiment with L<Inline::Ruby|https://github.com/awwaiid/Inline-Ruby/>
to call existing Ruby code from your Perl 6 programs. This uses an embedded
instance of the C<ruby> interpreter to run Ruby code called from your Perl 6
script. Note that this is an EXPERIMENTAL library. You can similarly call other
language's libraries with Inline::Perl5, Inline::Python, and others.

=end pod

=begin comments

### Guidelines for contributions:

Headers should contain the text that a Ruby user might search for, since
those headings will be in the Table of Contents generated for the top of
the document.

We use POD =item instead of =head3 or =head4 for identical bits that need not
appear in the table of contents.

This article does not describe in detail language features that Ruby doesn't
have at all, instead referring to other documents.

Example code and links to other documents should be favored over long
explanations of details better found elsewhere.

Finally, if a real user asks a Ruby to Perl 6 question that is not being
answered here, please add it to the document. Even if we do not have a good
answer yet, that will be better than losing the information about a real need.

=end comments
