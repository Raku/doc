=begin pod :tag<convert>

=TITLE 从Ruby到Perl6初步

=SUBTITLE 从Ruby到Perl6初步: 以最熟悉的方式使用?

本文档立足于列出Ruby和Perl6语法和语义上的差异。对Ruby中习惯用法，列举在Perl6
中对应的写法。（而对Perl6中的特性及习语不做论述）。

所以本文档不是为Perl6初学者指导书或者语法概述。预期的读者为具有Ruby语言基础
的开发者。用以指导其快速熟悉Perl6语法和迁移到Perl6开发。

=head1 基础语法

=head2  语句结束分号

Ruby中使用换行符号（有些例外情况），作为表达式的结束。通常在行结尾添加计算符
来使得表达式可以跨行。

    foo +     # Ruby语句结尾的计算符表示表达式跨行
      bar +
      baz

Perl6中表达式必须以C<;>结尾，这种方式能有更好的交互以及对多行语句的兼容性也更好。
这种方式下有两种情况是不需要C<;> 的：一种是用{}括起来的语句块的最后一条语句；还有
就是语句块后面仅有的一行语句。

    if 5 < $x < 10 {
      say "Yep!";
      $x = 17         # 不需要; 语句块}之前的语句。
    }               
    say "Done!"      #  不需要；此处也可以省略，因为}后只有一行的结束语句

=head2 空格

在空格的使用上Ruby的兼容性很强，甚至开启了strict和warnings模式下

    # 有点不和常规，但是在Ruby是合法的
    puts"Hello "+
    (people [ i]
        . name
        ) . upcase+"!"if$greeted[i]<1

Perl6中也非常倡导程序员的自由和创造力，但是平衡了语法兼容和设计目标：一致性、确定性
可扩展语法，支持单向语义分析和有用的错误信息，一些集成的特性，比如自定义操作符清理
，避免开发者偶然误解他们的意图。同时，“code高尔夫”实践被强调；Perl6设计在概念而上更简洁而
不是少敲键盘。

作为结果，Ruby中很多的地方的空格是可选择，在perl6中要么强制必须空格或者禁止使用。
很多这些限制不太可能涉及到很多实际的Perl代码（例如，数组变量和方括号之间的空格是不允许的）。
但是不幸的是有几个地方和Ruby惯用法是冲突地。

=begin item
I< 参数列表空格之前不能有空格>

    foo (3, 4, 1); # Ruby和Perl6中都不对 (Perl6中这表示传递给foo一个类型列表的单个参数
    foo(3, 4, 1);  # 正确方法
    foo 3, 4, 1;   # Ruby和Perl 6 - 可选的无括号风格

=end item

=begin item
I<关键词后B<需要>紧跟一个空格>

    if(a < 0); ...; end         # Ruby中ok
    if ($a < 0) { ... }         # Perl6
    if $a < 0 { ... }           # Perl6,更地道

    while(x > 5); ...; end      # Ruby
    while ($x > 5) { ... }      # Perl6
    while $x > 5 { ... }        # Perl6,更地道

=end item

=begin item
I<前缀或者后缀操作符之前（包括数组/哈希下标）之前不能有空格>

    seen [ :fish ] = 1    # Ruby, 不地道但是合法
    %seen< fish > = 1;    # Perl6, 'seen'后不能有空格
=end item

=begin item
I<如果和前缀/后缀操作符可能有冲突，中间操作符之前则必须有空格>

    n<1     # Ruby (Perl6中，这会和前缀操作符< >冲突)
    $n < 1; # Perl 6

=end item

=head2 C«.» 方法调用, C<.send>

和Ruby中一样方法调用使用．操作:

    person.name    # Ruby
    $person.name   # Perl6

对一个直到运行时才知道名字的对象，对其方法调用:

    object.send(methodname, args);  # Ruby
    $object."$methodname"(@args);   # Perl 6

如果漏掉引号，perl6期望 C<$methodname>为一个C<Method>对象，而不是简单地方法名字。

=head2 变量，标识符，范围以及通用类型

Ruby中，通过变量标识符来表示其作用范围，C<$>表示全局变量，C<@@> 表示类范围，
C<@> 表示实例范围，如果不带标识符则表示局部变量（包括参数）。C<&> 标识符用
来表示方法引用。符号前缀为C<:>,由于它就不是变量，所以不是真正意义上的标识符。

Perl6 标识符主要用来指示包含值的角色，指示值的类型（至少示接口）。无论变量
怎么使用，其标识符是不变的，你可以把他当成是变量名字的一部分。

变量的作用域通过定义是语句(C<my>,C<has>, C<our>, 等等)来指定的。

=head3 变量的作用域

对局部变量，Ruby通过分配时隐式申明，其作用范围限制为当前块。Ruby中C<if>和C<while>
内建的不被当做块或者范围。

Perl6使用显示范围指定，从不隐式创建变量。所有你看到地C<{ ... }>都被作为范围，
包括条件和循环结构的内部。最常用的范围定义如下：

    foo = 7        # Ruby变量，作用范围在第一赋值时候定义，其作用域到当前块的结束

    my  $foo = 7   # Perl6, 词法范围，限制为当前块
    our $foo = 7   # Perl6, 包范围
    has $!foo = 7  # Perl6, 实例范围 (属性)

=head3 C<$>标量

C<$>标识符一直作用于标量变量（例如C<$name>），这些变量都是单值容器。

这是最通常的变量类型，对他的内容没有任何限制。需要指出的是，也可以使用或者引用他
的内容，比如C<$x[1]>，C<$x{"foo"}>或者C<$f("foo")>。

=head3 C<@>数组

C<@>标识符，一直数组变量（例如C<@months>，C<@months[2]>, C<@months[2, 4]>用做
数组切片）。变量使用C<@>标识符，仅用来指明位置的角色，指示位置索引和切片的功能。

=begin item
I<索引>

    puts months[2]; # Ruby
    say @months[2]; # Perl 6

=end item

=begin item
I<值切片>

    puts months[8..11].join(',') # Ruby
    say @months[8..11].join(',') # Perl 6

=end item


=head3 C<%>哈希

C<%>标识符，一直用于哈希变量（例如C<%calories>，C<%calories<apple>>, C<%calories<pear plum>>）
变量使用C<%>标识符，仅能包含关联的角色（关联数组）。

Ruby用方括号来对数组和哈希取值。Perl6则是使用大括号来取哈希值。尖括号的版本也可用
，用来对其内容自动插值（字符串不用引号）：

副词可以用来控制切片的类型。

=begin item
I<索引>

    puts calories["apple"]  # Ruby
    say %calories{"apple"}; # Perl6

    puts calories["apple"]  # Ruby
    puts calories[:apple]   # Ruby, 符号作为键是普通的
    say %calories<apple>;   # Perl6 - 角括号代替单引号
    say %calories«"$key"»;  # Perl6 - 双角括号中双引号插值
=end item

=begin item
I<值切片>

    puts calories.values_at('pear', 'plum').join(',') # Ruby
    puts calories.values_at(%w(pear plum)).join(',')  # Ruby, 更好的方法?
    say %calories{'pear', 'plum'}.join(',');          # Perl 6
    say %calories<pear plum>.join(',');               # Perl 6 (更好的方法)
    my $keys = 'pear plum';
    say %calories«$keys».join(','); # Perl6, 变量插值切片
=end item

=begin item
I<键/值切片>

    say calories.slice('pear', 'plum').join(','); # Ruby,ActiveRecord
    say %calories{'pear', 'plum'}:kv.join(',');   # Perl 6 -使用 :kv副词
    say %calories<pear plum>:kv.join(',');        # Perl 6 (更好的方法)
=end item

=head3 C<&>函数

C<&>标识符和Ruby的类似，用来引用函数对象，一个未调用的命名子函数或操作符
例如，将该名字当做名词，而不是动词。变量使用C<&>标识符仅能包含可调用的角色。

    add = -> n, m { n + m } # Ruby lambda 定义加法函数
    add.(2, 3)              # => 5, Ruby调用lambda
    add.call(2, 3)          # => 5, Ruby调用lambda

    my &add = -> $n, $m { $n + $m } # Perl6加法函数
    &add(2, 3)                      # => 5, 可以用&标识符
    add(2, 3)                       # => 5, 也可以不带也能工作

    foo_method = &foo;     # Ruby
    my &foo_method = &foo; # Perl6

    some_func(&say) # Ruby传递一个函数引用
    some_func(&say) # Perl6用同样的方式，传递一个函数引用

Ruby中最后一个参数通常传递一个块，主要用于DSLs。这个DSLs块可以为C<yield>的隐式参数，
或者以C<&>为前缀的显式的块。Perl6中可调用参数要明确列出，并且通过变量名调用（而不是
yield），有很多种方法可以调用这个函数。

    # Ruby,定义一个方法，调用隐式块参数
    def f
      yield 2
    end

    # Ruby, 调用f,快递给他一个参数的块
    f do |n|
      puts "Hi #{n}"
    end

    # Perl6, 显式的块参数定一个方法
    sub f(&g:($)) {
      g(2)
    }

    # Perl 6, 调用f,传递给她一个参数的块，有多种方法对其调用
    
    f(-> $n { say "Hi {$n}" }) # 显式参数
    f -> $n { say "Hi {$n}" }  # 显式参数, 没有空格
    f { say "Hi {$^n}" }       # 隐式参数

    # 同时, 如果'f'是一个对象的实例方法，你可以使用C<:>，而不是大括号
    obj.f(-> $n { say "Hi {$n}" })  # 显式参数
    obj.f: -> $n { say "Hi {$n}" }  # 显式参数, 没有空格
    obj.f: { say "Hi {$^n}" }       # 隐式参数

=head3 C<*> Slurpy参数/参数扩展

在Ruby中，你可以定义一个 C<*>为前缀参数获取其他传递的参数到一个数组，
Perl 6中也类似。

    def foo(*args); puts "I got #{args.length} args!"; end # Ruby
    sub foo(*@args) { say "I got #{@args.elems} args!" }   # Perl 6

你可能想扩展一个数组为一个参数集。Perl 6也支持通过C<*>前缀这样操作。

    args = %w(a b c)         # Ruby
    foo(*args)

    my @args = <a b c>       # Perl 6
    foo(*@args)

Perl 6支持更先进的方式传递和处理参数。详细请浏览L<Signatures|/language/functions#Signatures>
和L<Captures|/type/Capture>。

=head2 Twigils

除此之外，Perl 6 还支持"twigils"语法，它位于变量和标识符之间，对变量做更多修饰。例如：

    $foo     # Scalar ,无twigil
    $!foo    # 私有实例变量
    $.foo    # 实例变量操作符
    $*foo    # 动态范围变量
    $^foo    # 块中一个位置参数（占位）
    $:foo    # 一个命名参数
    $=foo    # POD（文档）变量
    $?FILE   # 当前源文件名。? twigil表示一个编译时值
    $~foo    # 子语言解析器r, 不常用

尽管上面的例子都用了C<$>标识符，同样适用于C<@>或者C<%>

=head2 C<:> Symbols

Perl 6 通常使用字符串，而Ruby使用symbols。一个最基本的例子就是哈希键。

    address[:joe][:street] # 典型地Ruby嵌套哈希，其键为symbol
    %address<joe><street>  # 典型地Perl 6嵌套哈希，键为字符串

Perl6 中有I<colon-pair>语法，这在一定程度上和Ruby的symbol比较相似。

    :age            # Ruby symbol

    # Perl 6 中可以使用一下各种语法代替

    :age            # Perl 6 pair,使用隐式True值 
    :age(True)      # Perl 6 pair,使用显式True值 
    age => True     # Perl 6 pair，使用箭头语法
    "age" => True   # Perl 6 pair，使用箭头语法和显式分号 

你大概不想使用一个隐式值得colon-pair，而兼顾和Ruby symbol语法一致，因为这不是
很地道的Perl 6 语法。

=head1 操作符

很多操作符在Ruby和Perl 6中是类似的

=item C<,> 列表分隔符
=item C<+> 数字加
=item C<-> 数字减
=item C<*> 数字乘
=item C</> 数字整除
=item C<%> 数字求余
=item C<**> 数字求幂
=item C<! && ||> 逻辑运算符，高优先级
=item C<not and or> 逻辑运算符，低优先级

你可能会使用 C<$x++>而不是C<x += 1>作为变量自增的快捷方式。这可以作为一个
预增操作符C<++$x>（递增，返回一个新值）或者后增C<$x++>操作（递增，返回旧值）。

你可能会使用 C<$x-->而不是C<x -= 1>作为变量自增的快捷方式。这可以作为一个
预增操作符C<--$x>（递增，返回一个新值）或者后增C<$x-->操作（递增，返回旧值）。

=head2 C«== != < > <= >=» 比较

为了避免犯错，Perl 6 中数字和字符的比较是分开的：

=item C«== != < > <= >=» 比较
=item C<eq ne lt gt le ge> 字符串比较

例如，使用C<==>时候会把变量值转化为数字， C<eq>则会把值转为字符串。

=head2 C«<=>» 三目比较

Ruby中，C«<=>»操作符返回-1, 0或者1。

Perl 6中，返回 C<Order::Less>, C<Order::Same>或者C<Order::More>。

C«<=>» 强制数字上下云做比较

C«leg» ("Less, Equal, or Greater?") 强制字符上下文比较

C«cmp»兼容 C«<=>»或 C<leg>, 具体取决于实际的比较对象的类型
arguments.

=head2 C<~~> 智能匹配符

这是一个很普通的匹配操作符，但是Ruby中不支持。下面是一些例子：

    say "match!" if $foo ~~ /bar/;      # 模式匹配
    say "match!" if $foo ~~ "bar";      # 字符匹配
    say "match!" if $foo ~~ :(Int, Str) # 签名匹配（解构）

更多细节，请浏览L<S03/Smart matching|https://design.perl6.org/S03.html#Smart_matching>

=head2 C<& | ^> 字符位操作符
=head2 C<& | ^> 布尔操作符

Perl 6中，这些单字符操作符都被去除，用双字符操作符取代，是的他们
的参数更符合所需的上下文。

    # 中缀操作符 (两个参数;一边一个)
    +&  +|  +^  与 或 异或: 数字
    ~&  ~|  ~^  与 或 异或: 字符
    ?&  ?|  ?^  与 或 异或: 布尔型

    # 前缀操作符 (一个参数，在操作符后)
    +^  非: 数字
    ~^  非: 字符
    ?^  非: 布尔型 (和!一样)

=head2 C<&.> 有条件的连结操作符

Ruby 使用C<&.>操作符连结操作，当任何一个返回错误时候不会触发错误。Perl 6中使用
C<.?>实现同样的功能。

=head2 C«<< >>» 数字左移,右移操作符,shovel操作符

Perl6中用C«+<»和C«+>»代替。

    puts 42 << 3  # Ruby
    say  42 +< 3; # Perl 6
需要注意的是，Ruby中常用的C«<<»做为和 C<.push>类似的装填（shovel）操作符，Perl 6
中并不支持。

=head2 C«=>»和C<:>健值分割符

Ruby中C«=>»使用在哈希健值对定义和参数传递时候。C<:> 用在标记随后的变量为symbol。

Perl6 中，C«=>» 是Pair操作符，使用了完全不一样的原理，但是大多数情况下工作是一样的。

如果C«=>»用于哈希定义，用法非常相似

    hash = { "AAA" => 1, "BBB" => 2 }  # Ruby, 尽管symbol的键更常用
    my %hash = ( AAA => 1, BBB => 2 ); # Perl 6, 使用了()，尽管通常用{}

=head2 C<? :> 三元运算符

Perl 6中，使用了两个问号，而不是一个问号，对应地分号也是使用两个。这常见的三元运算
符不同，可能会导致误用情况比较突出。

    result     = (  score > 60 )  ? 'Pass'  : 'Fail'; # Ruby
    my $result = ( $score > 60 ) ?? 'Pass' !! 'Fail'; # Perl 6

=head2 C<+> 字符连结符

Perl6中用波浪线取代。象形记忆下，把连个字符串用针和线穿了起来。

    $food = 'grape' + 'fruit'  # Ruby
    $food = 'grape' ~ 'fruit'; # Perl 6

=head2 字符串插值

Ruby中，C<"#{foo}s">消除嵌入在双引号字符串中的块。Perl6中去除了C<#>前缀,用C<"{$foo}s">。
和Ruby中一样，你可以把代码嵌入块中，它会在在字符形式呈现。 

变量可以简单地在双引号子串中直接内插，而不需要使用块语法。

    # Ruby
    name = "Bob"
    puts "Hello! My name is #{name}!"

    # Perl 6
    my $name = "Bob"
    say "Hello! My name is $name!"

Ruby中使用的C<.to_s>用来返回字符上下文结果。Perl 6 中使用C<.Str>或者C<.gist>得到同样
结果。

=head1 复合语句

=head2 条件语句

=head3 C<if> C<elsif> C<else> C<unless>

Ruby和Perl6中用法类似，但是Perl6使用C<{ }>清晰地标识执行块。

    # Ruby
    if x > 5
        puts "Bigger!"
    elsif x == 5
        puts "The same!"
    else
        puts "Smaller!"
    end

    # Perl 6
    if x > 5 {
        say "Bigger!"
    } elsif x == 5 {
        puts "The same!"
    } else {
        puts "Smaller!"
    }

将一个条件表达式绑定到变量语法有少许不同：

    if x = dostuff(); ...; end   # Ruby
    if dostuff() -> $x {...}     # Perl 6, 块赋值要用箭头

C<unless>条件语句Perl6中仅允许在单块模式下执行；不能用C<elsif>和C<else>语句。

=head3 C<case>-C<when>

Perl6中C<given>-C<when>结构和Ruby中C<if>-C<elsif>-C<else>语句链结构相似。
最大的不同是Ruby用C<==>比较分支条件，而Perl6使用了更普遍的智能匹配符C<~~>。
其一般结构是：

    given EXPR {
        when EXPR { ... }
        when EXPR { ... }
        default { ... }
    }

其最精简的模式，结构如下：

    given $value {
        when "a match" {
            do-something();
        }
        when "another match" {
            do-something-else();
        }
        default {
            do-default-thing();
        }
    }

这是标量值匹配C<when>最简单的语句，更通常情况下，实际的匹配是智能匹配输入值。
在更复杂的情况下可能正则表达式，而不单单是标量值。

=head2 循环语句

=head3 C<while> C<until>

Mostly unchanged; parentheses around the conditions are optional, but if used, must
not immediately follow the keyword, or it will be taken as a function call
instead. Binding the conditional expression to a variable is also a little
different:

    while x = dostuff(); ...; end    # Ruby
    while dostuff() -> $x {...}      # Perl 6

=head3 C<for> C<.each>

C<for> loops are rare in Ruby, instead we typically use C<.each> on an
enumerable. The most direct translation to Perl 6 would be to use C<.map> for
both C<.each> and C<.map>, but we typically use a C<for> loop directly.

    # Ruby for loop
    for n in 0..5
        puts "n: #{n}"
    end

    # Ruby, more common usage of .each
    (0..5).each do |n|
        puts "n: #{n}"
    end

    # Perl 6
    for 0..5 -> $n {
        say "n: $n";
    }

    # Perl 6, misusing .map
    (0..5).map: -> $n {
        say "n: $n";
    }

In Ruby, the iteration variable for C<.each> is a copy of the list element, and
modifying it does nothing to the original list. Note that it is a copy of the
REFERENCE, so you can still change the values to which it refers.

In Perl 6, that alias is read-only (for safety) and thus behaves exactly like
Ruby, unless you change C«->» to C«<->».

    cars.each { |car| ... }    # Ruby; read-only reference
    for @cars  -> $car   {...} # Perl 6; read-only
    for @cars <-> $car   {...} # Perl 6; read-write

=head2 Flow Interruption statements

Same as Ruby:

=item C<next>
=item C<redo>

=item2 C<break>

This is C<last> in Perl 6.

=head1 Regular Expressions ( Regex / Regexp )

Regular expressions in Perl 6 are significantly different, and more powerful,
than in Ruby. By default whitespace is ignored and all characters must be
escaped, for example. Regexes can be easily combined and declared in ways to
build efficient grammars.

There are many powerful features of Perl 6 regexes, especially defining entire
grammars using the same syntax. See L<Regexes|/language/regexes> and
L<Grammars|/language/grammars>.

=head2 C<.match> method and C<=~> operator

In Ruby, regex matches can be done against a variable using the C<=~> regexp
match operator or the C<.match> method. In Perl 6, the C<~~> smartmatch op is
used instead, or the C<.match> method.

    next if line   =~ /static/   # Ruby
    next if $line  ~~ /static/;  # Perl 6

    next if line  !~  /dynamic/ ; # Ruby
    next if $line !~~ /dynamic/ ; # Perl 6

    next if line.match(/static/)    # Ruby
    next if $line.match(/static/);  # Perl 6

Alternately, the C<.match> and C<.subst> methods can be used. Note that
C<.subst> is non-mutating. See
L<S05/Substitution|https://design.perl6.org/S05.html#Substitution>.

=head2 C<.sub> and C<.sub!>

In Perl 6 you typically use the C<s///> operator to do regex substitution.

    fixed = line.sub(/foo/, 'bar')        # Ruby, non-mutating
    my $fixed = $line.subst(/foo/, 'bar') # Perl 6, non-mutating

    line.sub!(/foo/, 'bar')   # Ruby, mutating
    $line ~~ s/foo/bar/;      # Perl 6, mutating

=head2 Regex options

Move any options from the end of the regex to the beginning. This may
require you to add the optional C<m> on a plain match like C«/abc/».

    next if $line =~    /static/i # Ruby
    next if $line ~~ m:i/static/; # Perl 6

=head2 Whitespace is ignored, most things must be quoted

In order to aid in readability and reusability, whitespace is not significant
in Perl 6 regexes.

    /this is a test/ # Ruby, boring string
    /this.*/         # Ruby, possibly interesting string

    / this " " is " " a " " test / # Perl 6, each space is quoted
    / "this is a test" / # Perl 6, quoting the whole string
    / this .* /          # Perl 6, possibly interesting string

=head2 Special matchers generally fall under the <> syntax

There are many cases of special matching syntax that Perl 6 regexes support.
They won't all be listed here, but often instead of being surrounded by C<()>,
the assertions will be surrounded by C«<>».

For character classes, this means that:

=item C<[abc]> becomes C«<[abc]>»

=item C<[^abc]> becomes C«<-[abc]>»

=item C<[a-zA-Z]> becomes C«<[a..zA..Z]>»

=item C<[[:upper:]]> becomes C«<:upper>»

=item C<[abc[:upper:]]> becomes C«<[abc]+:Upper>»

For look-around assertions:

=item C<(?=[abc])> becomes C«<?[abc]>»

=item C<(?=ar?bitrary* pattern)> becomes C«<before ar?bitrary* pattern>»

=item C<(?!=[abc])> becomes C«<![abc]>»

=item C<(?!=ar?bitrary* pattern)> becomes C«<!before ar?bitrary* pattern>»

=item C«(?<=ar?bitrary* pattern)» becomes C«<after ar?bitrary* pattern>»

=item C«(?<!ar?bitrary* pattern)» becomes C«<!after ar?bitrary* pattern>»

(Unrelated to <> syntax, the "lookaround" C</foo\Kbar/> becomes C«/foo <( bar )> /»

=item C<(?(?{condition))yes-pattern|no-pattern)> becomes C«[ <?{condition}>
      yes-pattern | no-pattern ]»

=head2 Longest token matching (LTM) displaces alternation

In Perl 6 regexes, C<|> does Longest Token Match (LTM), which decides which
alternation wins an ambiguous match based off of a set of rules, rather than
about which was written first in the regex.

To avoid the new logic, change any C<|> in your Ruby regex to a C<||>.

=head1 File-related operations

=head2 Reading the lines of a text file into an array

Both Ruby and Perl 6 make it easy to read all of the lines in a file into a
single variable, and in both cases each line has the newline removed.

    lines = File.readlines("file")   # Ruby
    my @lines = "file".IO.lines;     # Perl 6, create an IO object from a string

=head2 Iterating over the lines of a text file

Reading the entire file into memory isn't recommended. The C<.lines> method in
Perl 6 returns a lazy sequence, but assigning to an array forces the file to be
read. It is better to iterate over the results:

    # Ruby
    File.foreach("file") do |line|
        puts line
    end

    # Perl 6
    for "file".IO.lines -> $line {
        say $line
    }

=head1 Object Orientation

=head2 Basic classes, methods, attributes

Classes are defined similarly between Ruby and Perl 6, using the C<class>
keyword. Ruby uses C<def> for methods, whereas Perl 6 uses C<method>.

    # Ruby
    class Foo
        def greet(name)
            puts "Hi #{name}!"
        end
    end

    # Perl 6
    class Foo {
        method greet($name) {
            say "Hi $name!"
        }
    }

In Ruby you can use an attribute without declaring it beforehand, and you can
tell it is an attribute because of the C<@> sigil. You can also easily create
accessors using C<attr_accessor> and it's variants. In Perl 6 you use a C<has>
declaration and a variety of sigils. You can use the C<!> twigil for private
attributes or C<.> to create an accessor.

    # Ruby
    class Person
        attr_accessor :age    # Declare .age as an accessor method for @age
        def initialize
            @name = 'default' # Assign default value to private instance var
        end
    end

    # Perl 6
    class Person
        has $.age;              # Declare $!age and accessor methods
        has $!name = 'default'; # Assign default value to private instance var
    end

Creating a new instance of the class uses the C<.new> method. In Ruby you must
manually assign instance variables as needed inside C<initialize>. In Perl 6
you get a default constructor that accepts key/value pairs of accessor
attributes, and can do further setup in the C<BUILD> method. Like with Ruby,
you can override C<new> itself for more advanced functionality, but this is
rare.

    # Ruby
    class Person
        attr_accessor :name, :age
        def initialize(attrs)
            @name = attrs[:name] || 'Jill'
            @age  = attrs[:age] || 42
            @birth_year = Time.now.year - @age
        end
    end
    p = Person.new( name: 'Jack', age: 23 )

    # Perl 6
    class Person
        has $.name = 'Jill';
        has $.age  = 42;
        has $!birth_year;
        method BUILD {
            $!birth_year = now.Date.year - $.age;
        }
    }
    p = Person.new( name => 'Jack', age => 23 )

=head2 Private Methods

Private methods in Perl 6 are declared with a C<!> prefixed in their name, and
are invoked with a C<!> instead of a C<.>.

    # Ruby
    class Foo
        def visible
            puts "I can be seen!"
            hidden
        end

        private
        def hidden
            puts "I cannot easily be called!"
        end
    end

    # Perl 6
    class Foo {
        method visible {
            say "I can be seen!"
            self!hidden
        }

        method !hidden {
            say "I cannot easily be called!"
        }
    }

An important note is that in Ruby child objects can see parent private methods
(so they are more like "protected" methods in other languages). In Perl 6 child
objects cannot call parent private methods.

=head2 Going Meta

Here are a few examples of meta-programming. Note that Perl 6 separates the
meta-methods from the regular methods.

    person = Person.new       # Ruby, create a new person
    my $person = Person.new   # Perl 6, create a new person

    person.class              # Ruby, returns Person (class)
    $person.WHAT              # Perl 6, returns Person (class)

    person.methods            # Ruby
    $person.^methods          # Perl 6, using .^ syntax to access meta-methods

    person.instance_variables # Ruby
    $person.^attributes       # Perl 6

Like Ruby, in Perl 6, everything is an object, but not all operations are
equivalent to C<.send>. Many operators are global functions that use typed
multi-dispatch (function signatures with types) to decide which implementation
to use.

    5.send(:+, 3)    # => 8, Ruby
    &[+](5, 3)       # => 8, Perl 6, reference to infix addition operator

    &[+].^candidates # Perl 6, lists all signatures for the + operator

See L<Meta-Object Protocol|/language/mop> for lots of further details.

=head1 Environment variables

=head2 Perl module library path

In Ruby, one of the environment variables to specify extra search paths for
modules is C<RUBYLIB>.

    $ RUBYLIB="/some/module/lib" ruby program.rb

In Perl 6 this is similar, you merely needs to change the name. As you probably
guessed, you just need to use C<PERL6LIB>:

    $ PERL6LIB="/some/module/lib" perl6 program.p6

As with Ruby, if you don't specify C<PERL6LIB>, you need to specify the
library path within the program via the C<use lib> pragma:

    # Ruby and Perl 6
    use lib '/some/module/lib';

=head1 Misc.

=head2 Importing specific functions from a module

In Ruby there is no built-in way to selectively import/export methods from a
module.

In Perl 6 you specifies the functions which are to be exported by using the
C<is export> role on the relevant subs and I<all> subs with this role are
then exported. Hence, the following module C<Bar> exports the subs C<foo>
and C<bar> but not C<baz>:

    unit module Bar; # remainder of the file is in module Bar { ... }

    sub foo($a) is export { say "foo $a" }
    sub bar($b) is export { say "bar $b" }
    sub baz($z) { say "baz $z" }

To use this module, simply C<use Bar> and the functions C<foo> and C<bar>
will be available

    use Bar;
    foo(1);    #=> "foo 1"
    bar(2);    #=> "bar 2"

If you tries to use C<baz> an "Undeclared routine" error is raised at compile time.

Some modules allow for selectively importing functions, which would look like:

    use Bar <foo>; # Import only foo
    foo(1);        #=> "foo 1"
    bar(2);        # Error!

=head2 C<OptionParser>, parsing command-line flags

Command line argument switch parsing in Perl 6 is done by the parameter list of
the C<MAIN> subroutine.

    # Ruby
    require 'optparse'
    options = {}
    OptionParser.new do |opts|
        opts.banner = 'Usage: example.rb --length=abc'
        opts.on("--length", "Set the file") do |length|
            raise "Length must be > 0" unless length.to_i > 0
            options[:length] = length
        end
        opts.on("--filename", "Set the file") do |filename|
            options[:file] = filename
        end
        opts.on("--verbose", "Increase verbosity") do |verbose|
            options[:verbose] = true
        end
    end.parse!

    puts options[:length]
    puts options[:filename]
    puts 'Verbosity ', (options[:verbose] ? 'on' : 'off')

    ruby example.rb --filename=foo --length=42 --verbose
        42
        foo
        Verbosity on

    ruby example.rb --length=abc
        Length must be > 0

    # Perl 6
    sub MAIN ( Int :$length where * > 0, :filename = 'file.dat', Bool :$verbose ) {
        say $length;
        say $data;
        say 'Verbosity ', ($verbose ?? 'on' !! 'off');
    }

    perl6 example.p6 --file=foo --length=42 --verbose
        42
        foo
        Verbosity on
    perl6 example.p6 --length=abc
        Usage:
          example.p6 [--length=<Int>] [--file=<Any>] [--verbose]

Note that Perl 6 auto-generates a full usage message on error in
command-line parsing.

=head1 RubyGems, External Libraries

See L<https://modules.perl6.org/>, where a growing number of Perl 6 libraries
are available along with the tools to manage them.

If the module that you were using has not been converted to Perl 6, and no
alternative is listed in this document, then its use under Perl 6 may not
have been addressed yet.

You can experiment with L<Inline::Ruby|https://github.com/awwaiid/Inline-Ruby/>
to call existing Ruby code from your Perl 6 programs. This uses an embedded
instance of the C<ruby> interpreter to run Ruby code called from your Perl 6
script. Note that this is an EXPERIMENTAL library. You can similarly call other
language's libraries with Inline::Perl5, Inline::Python, and others.

=end pod

=begin comments

### Guidelines for contributions:

Headers should contain the text that a Ruby user might search for, since
those headings will be in the Table of Contents generated for the top of
the document.

We use POD =item instead of =head3 or =head4 for identical bits that need not
appear in the table of contents.

This article does not describe in detail language features that Ruby doesn't
have at all, instead referring to other documents.

Example code and links to other documents should be favored over long
explanations of details better found elsewhere.

Finally, if a real user asks a Ruby to Perl 6 question that is not being
answered here, please add it to the document. Even if we do not have a good
answer yet, that will be better than losing the information about a real need.

=end comments
