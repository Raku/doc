=begin pod :kind("Language") :subkind("Language") :category("reference")

=TITLE Rakudoc - formerly POD6

=SUBTITLE An easy-to-use markup language for documenting Raku modules and programs

Rakudoc is an easy-to-use markup language. It can be used for
writing language documentation, for documenting programs and modules, as
well as for other types of document composition.

Every Rakudoc document has to begin with C<=begin pod> and end with C<=end pod>.
Everything between these two delimiters will be processed and used to generate
documentation.

=begin code
=begin pod

A very simple Rakudoc document

=end pod
=end code

=head1 Block structure

A Rakudoc document may consist of multiple Rakudoc blocks (also called pod locks). There are four ways to
define a block: delimited, paragraph, abbreviated, and declarator; the first three
yield the same result but the fourth differs. You can use whichever form is most
convenient for your particular documentation task.

=head2 Delimited blocks

Delimited blocks are bounded by C<=begin> and C<=end> markers, both of
which are followed by a valid Raku identifier, which is the
C<typename> of the block. Typenames that are entirely lowercase (for
example: C<=begin head1>) or entirely uppercase (for example: C<=begin
SYNOPSIS>) are reserved. Indentation of the =begin/=end lines is
required to be the same to create a valid block; otherwise, an error
or unexpected results will occur.

=begin code
=begin head1
Top Level Heading
=end head1
=end code

=head2 Configuration information

After the typename, the rest of the C<=begin> marker line is treated as
configuration information for the block. This information is used in
different ways by different types of blocks, but is always specified using
Raku-ish option pairs. That is, any of:

=begin table
 Value is...       Specify with...           Or with...           Or with...
 ===============   ===================       ==============       ===========
 List              :key[$e1, $e2, ...]       :key($e1, $e2, ...)  :key<$e1 $e2 ...>
 Hash              :key{$k1=>$v1, $k2=>$v2}
 Boolean (true)    :key                      :key(True)           :key[True]
 Boolean (false)   :!key                     :key(False)          :key[False]
 String            :key<str>                 :key('str')          :key("str")
 Int               :key(42)                  :key[42]             :42key
 Number            :key(2.3)                 :key[2.3]
=end table

Where '$e1, $e2, ...' are list elements of type String, Int, Number, or
Boolean. Lists may have mixed element types. Note that one-element
lists are converted to the type of their element (String, Int, Number, or
Boolean). Also note that big integers can be used if required.

For hashes, '$k1, $k2, ...' are keys of type Str and '$v1, $v2, ...'
are values of type String, Int, Number, or Boolean.

Strings are delimited by single or double quotes. Whitespace is not significant
outside of strings. Hash keys need not be quote-delimited unless they contain
significant whitespace. Strings entered inside angle brackets become lists if
any whitespace is used inside the angle brackets.

All option keys and values must be constants since Rakudoc is a
specification language, not a programming language. Specifically, option
values cannot be closures.

The configuration section may be extended over subsequent
lines.
Each subsequent line must start
with an C<=> in the first virtual column, meaning that it must vertically
align with the C<=> of the Rakudoc Block declaration,
and it must be followed
by at least one horizontal whitespace character.

For example:
=begin code
     =for head1 :a-first-line-key<firstvalue> :another-first-line-key<xyz>
     =          :a-second-line-key(42)
     = :a-third-line-key<third>
     Content for the header block
=end code

=head2 Standard configuration options

Rakudoc predefines a small number of standard configuration options that can be applied
appropriate block types. These include:
C<:numbered>
=begin nested
This option specifies that the block is to be numbered. This option is to
create L<numbered headings|#Numbered headings> and L<ordered lists|#Ordered lists>,
but it can be applied to any block if the Renderer provides a way to do so (eg. via a
specific template).

The numbering conventions for headings and lists are specified in those sections,
but it is up to individual renderers to decide how to display any numbering associated
with other types of blocks.

Note that numbering is never explicit; it is always implied by context.
=end nested

C<:nested>
=begin nested
This option specifies that the block is to be nested within its current context. For example,
nesting might be applied to block quotes, to textual examples, or to commentaries.
In addition the C<=code>, <C<=item>, <C<=input>, and C<=output> blocks all have implicit nesting.

Nesting of blocks is usually rendered by adding extra indentation to the block contents,
but may also be indicated in other ways: by boxing the contents, by changing the font or size of the nested text,
or even by folding the text (so long as a visible placeholder is provided).

Occasionally it is desirable to nest content by more than one level:
=begin code
=begin para :nested
=begin para :nested
=begin para :nested
"We're going deep, deep, I<deep> undercover!"
=end para
=end para
=end para
=end code

This can be simplified by giving the C<:nested> option a positive integer value:
=begin code
=begin para :nested(3)
"We're going deep, deep, I<deep> undercover!"
=end para
=end code

=end nested

C<:formatted>
=begin nested
This option specifies that the contents of the block should be treated as if they had one or more
L<formatting codes|#Formatting codes> placed around them.

For example, instead of:
=begin code
=for comment
The next para is both important and fundamental, so doubly emphasize it...

=begin para B<I< Warning: Do not immerse in water. Do not expose to bright light. Do not feed after midnight. >>
=end para
=end code

you can just write:

=begin code :allow<B>
=begin para B<:formatted<B I>>
Warning: Do not immerse in water. Do not expose to bright light. Do not feed after midnight.
=end para
=end code
The internal representations of these two versions are exactly the same, except that the second one
retains the C<:formatted> option information as part of the resulting block object.

Like all formatting codes, codes applied via a C<:formatted> are inherently cumulative.
For example, if the block itself is already inside a formatting code, that formatting code will still apply,
in addition to the extra "basis" and "important" formatting specified by C<:formatted<B I>>.
=end nested

C<:like>
=begin nested
This option specifies that a block or config has the same formatting properties as the type named by its value.
This is useful for creating related L<configurations|#Block pre-configuration> or for making user-defined synonyms
for existing types. For example:
=begin code
=config head2 :like<head1> :formatted<I>
=config Subhead :like<head2>
=end code
=end nested

C<:allow>
=begin nested
This option expects a list of formatting codes that are to be recognized within any C<V<>> codes that appear in
(or are implicitly applied to) the current block. The option is most often used on C<=code> blocks to allow mark-up
within those otherwise verbatim blocks, though it can be used in I<any> block that contains verbatim text.
See L<#Formatting within code blocks>.
=end nested

C<:margin>
=begin nested
This option specifies a character that indicates the left margin of the contents of the block. Normally this left
margin is determined by the column at which the C<=> of the opening block-delimiter occurs. For example:
=begin code
=head1 Indenting Pod blocks

=begin para This text is flush with the (virtual) left margin of the Pod block because that margin is implicitly specified
by the C<=> of the C<=begin> =end para =end code However, by using the C<:margin> option it is possible to specify a
character that acts like an explicit margin when it occurs as the first non-whitespace character on any line within the block.
For example:
=begin code
=head1 Indenting Pod blocks
=begin para :margin<|>
    |This text is flush with the (virtual) left margin of
    |the Pod block because that margin is explicitly marked
    |by the C<|>, as specified by the block's C<:margin<|>> option.
=end para
=end code

The virtual margin can even be to the left of the opening delimiter, which can be convenient to guide subsequent indentations.
For example:
=begin code
    sub foo {
        V<=begin> pod :margin<|>
    |=head1 Hey Look: Indented Rakudoc!
    |
    |You can indent Rakudoc in Raku
    |which makes code look cleaner
    |when documentation is interspersed
    | | my $this is Code;
    | |
        =end pod
    ...
    }
=end code

When a C<:margin> option is used, each subsequent line (until the corresponding closing delimiter is encountered)
simply has any text matching C</^^ \s* $margin_char/> automatically removed. This may include a line that then becomes the
closing delimiter, as in the above example.

Any line from which such a margin marker is removed automatically resets the implicit margin for subsequent
lines of the block, setting it to the length of the "marginalized" indent that was just removed. This implicit margin is then
used until the next line with an explicit margin marker is encountered, or the block terminates.
=end nested

Some of these options have a predetermined value; specifically, C<:numbered>
is used to specify that the block item or lines will be numbered.

This configuration option can be abbreviated by a hash mark

=begin code
=para #
We
Need
Numbers

say $=pod[0].config<numbered>; # OUTPUT: «1␤»
=end code

=head2 Block pre-configuration

The =config directive allows you to prespecify standard configuration information that is applied to every block of a particular type.

For example, to specify particular formatting for different levels of heading, you could preconfigure all the heading blocks with appropriate formatting schemes:
=begin code
    =config head1              :formatted<B U>  :numbered
    =config head2 :like<head1> :formatted<I>
    =config head3              :formatted<U>
    =config head4 :like<head3> :formatted<I>
=end code

The general syntax for configuration directives is:
=begin code
    =config BLOCK_TYPE  CONFIG OPTIONS
    =                   OPTIONAL EXTRA CONFIG OPTIONS
=end code
A C<=config> is a directive, not a block. Hence, there is no paragraph or delimited form of the C<=config> directive.
Each C<=config> specification is lexically scoped to the surrounding block in which it is specified.

Note that, if a particular block later explicitly specifies a configuration option with the same key,
that option overrides the pre-configured option. For example, given the heading configurations in the previous example,
to specify a non-basic second-level heading:
=begin code
    =for head2 :formatted<I U>
    Details
=end code

=head2 Paragraph blocks

Paragraph blocks begin by a C<=for> marker and end by
the next Rakudoc directive or the first blank line.
The C<=for> marker is followed by the C<typename> of the block
plus, optionally, any configuration data as in the delimited
blocks described above.

=begin code
=for head1
Top Level Heading
=end code

=head2 Abbreviated blocks

Abbreviated blocks begin by an C<'='> sign, which is followed immediately by the
C<typename> of the block. All following data are part of the contents of the
block, thus configuration data B<cannot> be specified for an I<abbreviated>
block. The block ends at the next Rakudoc directive or the first blank line.

=begin code
=head1 Top level heading
=end code

X<|Syntax,#|>X<|Syntax,#=>
=head2 Declarator blocks

Declarator blocks differ from the others by not having a specific type,
instead they are attached to some source code.

Declarator blocks are introduced by a special comment: either C<#|> or C<#=>,
which must be immediately followed by either a space or an opening curly brace.
If followed by a space, the block is terminated by the end of line;
if followed by one or more opening curly braces, the block is terminated by
the matching sequence of closing curly braces.

Blocks starting with C<#|> are attached to the code after them,
and blocks starting with C<#=> are attached to the code before them.

Since declarator blocks are attached to source code, they can be used to
document classes, roles, subroutines and in general any statement or block.

The C<WHY> method can be used on these classes, roles, subroutines etc. to
return the attached Rakudoc value.

=begin code
#| Base class for magicians
class Magician {
  has Int $.level;
  has Str @.spells;
}

#| Fight mechanics
sub duel(Magician $a, Magician $b) {
}
#= Magicians only, no mortals.

say Magician.WHY; # OUTPUT: «Base class for magicians␤»
say &duel.WHY.leading; # OUTPUT: «Fight mechanics␤»
say &duel.WHY.trailing; # OUTPUT: «Magicians only, no mortals.␤»
=end code

These declarations can extend multiple blocks:

=begin code
#|( This is an example of stringification:
    * Numbers turn into strings
    * Regexes operate on said strings
    * C<with> topicalizes and places result into $_
)
sub search-in-seq( Int $end, Int $number ) {
    with (^$end).grep( /^$number/ ) {
        .say for $_<>;
    }
}
#=« Uses
    * topic
    * decont operator
»
=end code

By using a matched pair of parenthesis constructs such as C<()> or C<«»> the
comments can extend multiple lines. This format will not normally translate to
a multi-line display by C<raku --doc>. However, since Rakudo version 2020.01,
there is a method to accomplish that, I<for leading declarator blocks only>,
by defining a special environment variable: B<C<RAKUDO_POD_DECL_BLOCK_USER_FORMAT>>.
When that value is set, running C<raku> with the C<--doc> option should show text
from leading declarator blocks in its original format. See the test for the capability
in the file
L<S26-documentation/block-leading-user-format.t|https://github.com/Raku/roast/blob/master/S26-documentation/block-leading-user-format.t>.

=head1 Block types

Rakudoc offers a wide range of standard block types.

=head2 Headings

Headings can be defined using C<=headN>,
where N is greater than zero (e.g., C<=head1>, C<=head2>, …).

=begin code
=head1 A top level heading

=head2 A second level heading

=head3 A third level heading
=end code

=head2 Numbered headings

You can specify that a heading is numbered using the C<:numbered> option. For example:
=begin code
    =for head1 :numbered
    The Problem

    =for head1 :numbered
    The Solution

        =for head2 :numbered
        Analysis

            =for head3
            Overview

            =for head3
            Details

        =for head2 :numbered
        Design

    =for head1 :numbered
    The Implementation
=end code

which would produce:

=begin code
1. The Problem

2. The Solution

    2.1. Analysis

        Overview

        Details

    2.2: Design

3. The Implementation
=end code

It is usually better to preset a numbering scheme for each heading level, in a series of configuration blocks:
=begin code
    =config head1 :numbered
    =config head2 :numbered
    =config head3 :!numbered

    =head1 The Problem
    =head1 The Solution
    =head2   Analysis
    =head3     Overview
    =head3     Details
    =head2   Design
    =head1 The Implementation
=end code

Alternatively, as a short-hand, if the first whitespace-delimited word in a heading
consists of a single literal B<#> character, the B<#> is removed and the heading is
treated as if it had a C<:numbered> option:
=begin code
    =head1 # The Problem
    =head1 # The Solution
    =head2   # Analysis
    =head3       Overview
    =head3       Details
    =head2   # Design
    =head1 # The Implementation
=end code

Note that, even though renderers are not required to distinctly render more than the
first four levels of heading, they are required to correctly honour arbitrarily
nested numberings. That is:
=begin code
    =head6 # The Rescue of the Kobayashi Maru
=end code

should produce something like:
=begin code
2.3.8.6.1.9. The Rescue of the Kobayashi Maru
=end code

=head2 Ordinary paragraphs

An ordinary paragraph consists of text that is to be formatted into a document
at the current level of nesting, with whitespace squeezed, lines filled, and any
special inline mark-up applied.

Ordinary paragraphs consist of one or more consecutive lines of text,
each of which starts with a non-whitespace character.
The paragraph is terminated by the first blank line or block directive.

For example:

=begin code
=head1 This is a heading block

This is an ordinary paragraph.
Its text  will   be     squeezed     and
short lines filled. It is terminated by
the first blank line.

This is another ordinary paragraph.
Its     text    will  also be squeezed and
short lines filled. It is terminated by
the trailing directive on the next line.

=head2 This is another heading block

This is yet another ordinary paragraph,
at the first virtual column set by the
previous directive
=end code

Ordinary paragraphs do not require an explicit marker or delimiters.

Alternatively, there is also an explicit C<=para> marker that can be used
to explicitly mark a paragraph.

=begin code
=para
This is an ordinary paragraph.
Its text  will   be     squeezed     and
short lines filled.
=end code

which is rendered as:

=para
This is an ordinary paragraph.
Its text  will   be     squeezed     and
short lines filled.

In addition, the longer C<=begin para> and C<=end para> form can be used.

For example:

=begin code

=begin para
This is an ordinary paragraph.
Its text  will   be     squeezed     and
short lines filled.

This is still part of the same paragraph,
which continues until an...
=end para
=end code

As demonstrated by the previous example, within a delimited C<=begin para> and
C<=end para> block, any blank lines are preserved.

=head2 Code blocks

Code blocks are used to specify pre-formatted text (typically source code), which should be rendered without rejustification,
without whitespace-squeezing, and without recognizing any inline formatting codes. Code blocks also have an
implicit nesting associated with them. Typically these blocks are used to show examples of code, mark-up, or
other textual specifications, and are rendered using a fixed-width font.

A code block may be implicitly specified as one or more lines of text, each of which starts with a
whitespace character at the block's virtual left margin. The implicit code block is then terminated by a blank line.
For example:
=begin code
    This ordinary paragraph introduces a code block:

        $this = 1 * code('block');
        $which.is_specified(:by<indenting>);
=end code

Implicit code blocks may only be used within C<=pod>, C<=item>, C<=defn>, C<=nested>, or semantic blocks.

There is also an explicit C<=code> block (which can be specified within any other block type, not just C<=pod>, C<=item>, etc.):
=begin code
     The C<loud_update()> subroutine adds feedback:

        =begin code

        sub loud_update ($who, $status) {
            say "$who -> $status";

            silent_update($who, $status);
        }

        =end code
=end code
As the previous example demonstrates, within an explicit C<=code> block the code can start at the (virtual) left margin.
Furthermore, lines that start with whitespace characters after that margin have subsequent whitespace preserved exactly
(in addition to the implicit nesting of the code). Explicit C<=code> blocks may also contain empty lines.

=head3 Formatting within code blocks

Although C<=code> blocks automatically disregard all formatting codes, occasionally you may still
need to specify some formatting within a code block. For example, you may wish to
emphasize a particular keyword in an example (using a C<B<>> code). Or you may want to indicate that
part of the example is metasyntactic (using the C<R<>> code). Or you might need to insert a non-ASCII
character (using the C<E<>> code).

You can specify a list of formatting codes that should still be recognized within a code block using
the C<:allow> option. The value of the C<:allow> option must be a list of the (single-letter)
names of one or more formatting codes. Those codes will then remain active inside the code block.
For example:
=begin code
    =begin code :allow< B R >
    sub demo {
        B<say> 'Hello R<name>';
        I<note> 'The I format is not recognised';
    }
    =end code
=end code

would be rendered:

=begin code :allow< B R >
sub demo {
    B<say> 'Hello R<name>';
    I<note> 'The I format is not recognised';
    }
=end code

=head2 I/O blocks

Rakudoc provides blocks for specifying the input and output of programs.

=for nested
B<Note> The Rakudo compiler does not (yet) produce C<Pod::Block>s for Input or Output
and instead produces C<Pod::Block::Code> for C<=code>, C<=input> and C<=output>.

The C<=input> block is used to specify pre-formatted keyboard input,
which should be rendered without re-justification or squeezing of whitespace.

The C<=output> block is used to specify pre-formatted terminal or file output,
which should also be rendered without re-justification or whitespace-squeezing.
=begin code

    =begin output
            Name:    Baracus, B.A.
            Rank:    Sgt
            Serial:  1PTDF007

            Do you want additional personnel details? K<y>

            Height:  180cm/5'11"
            Weight:  104kg/230lb
            Age:     49

            Print? K<n>
        =end output

=end code

=head2 Lists

Lists in Rakudoc are specified as a series of contiguous C<=item> blocks.
No special "container" directives or other delimiters are required to enclose the entire list.

Note that C<=item> is just an abbreviation for C<=item1>.

Item blocks within the same list are not physically nested.
That is, lower-level items should not be specified inside higher-level items:
=begin code
    =comment WRONG...
    =begin item1          --------------
    The choices are:                    |
    =item2 Liberty        ==< Level 2   |==<  Level 1
    =item2 Death          ==< Level 2   |
    =item2 Beer           ==< Level 2   |
    =end item1            --------------

    =comment CORRECT...
    =begin item1          ---------------
    The choices are:                     |==< Level 1
    =end item1            ---------------
    =item2 Liberty        ==================< Level 2
    =item2 Death          ==================< Level 2
    =item2 Beer           ==================< Level 2
=end code

=head3 Unordered lists

Lists in Rakudoc are by default unordered. For example:

=begin code
The three suspects are:

=item  Happy
=item  Sleepy
=item  Grumpy
=end code

The three suspects are:

=item  Happy
=item  Sleepy
=item  Grumpy

The bulletting strategy used for different levels within a nested list is entirely up to the renderer.

=head3 Ordered lists

An item is part of an ordered list if the item has a :numbered configuration option:
=begin code
     =for item1 :numbered
     Visito

     =for item2 :numbered
     Veni

     =for item2 :numbered
     Vidi

     =for item2 :numbered
     Vici
=end code
This would produce something like:
=begin code
1. Visito

1.1. Veni

1.2. Vidi

1.3. Vici
=end code

although the numbering scheme is entirely at the discretion of the renderer.

Alternatively, if the first word of the item consists of a single B<#> character,
the item is treated as having a C<:numbered> option:
=begin code
     =item1  # Visito
     =item2     # Veni
     =item2     # Vidi
     =item2     # Vici
=end code

To specify an unnumbered list item that starts with a literal B<>, either make
the octothorpe verbatim:
=begin code
    =item V<#> introduces a comment
=end code

or explicitly mark the item itself as being unnumbered:
=begin code
    =for item :!numbered
    # introduces a comment
=end code

The numbering of successive C<=item1> list items increments automatically,
but is reset to 1 whenever any other kind of non-ambient Pod block appears
between two C<=item1> blocks. For example:
=begin code
    The options are:

    =item1 # Liberty
    =item1 # Death
    =item1 # Beer

    The tools are:

    =item1 # Revolution
    =item1 # Deep-fried peanut butter sandwich
    =item1 # Keg
=end code
would produce:
=begin code
The options are:

1. Liberty

2. Death

3. Beer

The tools are:

1. Revolution

2. Deep-fried peanut butter sandwich

3. Keg
=end code
The numbering of nested items (C<=item2>, C<=item3>, etc.) only resets (to 1) when
the higher-level item's numbering either resets or increments.

To prevent a numbered C<=item1> from resetting after a non-item block,
you can specify the C<:continued> option:
=begin code
     =for item1
     # Retreat to remote Himalayan monastery

     =for item1
     # Learn the hidden mysteries of space and time

     I<????>

     =for item1 :continued
     # Prophet!
=end code
which produces:
=begin code
1. Retreat to remote Himalayan monastery

2. Learn the hidden mysteries of space and time

????

3. Prophet!

=end code

=head3 Definition lists

Lists that define terms or commands use C<=defn>, equivalent to the C<DL> lists
in HTML

=begin code
=defn Happy
When you're not blue.

=defn Blue
When you're not happy.
=end code

will be rendered as

=defn Happy
When you're not blue.

=defn Blue
When you're not happy.

=head3 Multi-level lists

Lists may be multi-level, with items at each level specified using the
C<=item1>, C<=item2>, C<=item3>, etc. blocks.
(The indentation depends on the rendering engine and does not need to be included
in the Rakudoc markup.) Upto four levels are normally differentiated.

For example:

=begin code
=item1  Animal
=item2     Vertebrate
=item3     Mammals
=item4     Primates
=item2     Invertebrate

=item1  Phase
=item2     Solid
=item3        Crystaline
=item3        Amorphous
=item2     Liquid
=item2     Gas
=end code

=item1  Animal
=item2     Vertebrate
=item3     Mammals
=item4     Primates
=item2     Invertebrate

=item1  Phase
=item2     Solid
=item3        Crystaline
=item3        Amorphous
=item2     Liquid
=item2     Gas

=head3 Multi-paragraph lists

Using the delimited form of the C<=item> block (C<=begin item> and C<=end item>),
we can specify items that contain multiple paragraphs.

For example:

=begin code
Let's consider two common proverbs:

=begin item
I<The rain in Spain falls mainly on the plain.>

This is a common myth and an unconscionable slur on the Spanish
people, the majority of whom are extremely attractive.
=end item

=begin item
I<The early bird gets the worm.>

In deciding whether to become an early riser, it is worth
considering whether you would actually enjoy annelids
for breakfast.
=end item

As you can see, folk wisdom is often of dubious value.
=end code
Renders as:

Let's consider two common proverbs:

=begin item
I<The rain in Spain falls mainly on the plain.>

This is a common myth and an unconscionable slur on the Spanish
people, the majority of whom are extremely attractive.
=end item

=begin item
I<The early bird gets the worm.>

In deciding whether to become an early riser, it is worth
considering whether you would actually enjoy annelids
for breakfast.
=end item

As you can see, folk wisdom is often of dubious value.

=head2 Nested blocks

Rakudoc provides a C<=nested> block that marks all its contents as being nested:
=begin code
    =begin nested
    We are all of us in the gutter,

    but some of us are looking at the stars!
        =begin nested
        -- Oscar Wilde
        =end nested
    =end nested
=end code

=begin nested
We are all of us in the gutter,

but some of us are looking at the stars!
    =begin nested
    -- Oscar Wilde
    =end nested
=end nested

Nesting blocks can contain any other kind of block, including implicit paragraph and code blocks.
Note that the relative physical indentation of the blocks plays no role in determining
their ultimate nesting. The preceding example could equally have been specified:
=begin code
    =begin nested
    We are all of us in the gutter,

    but some of us are looking at the stars!
    =begin nested
    -- Oscar Wilde
    =end nested
    =end nested
=end code

=begin nested
We are all of us in the gutter,

but some of us are looking at the stars!
=begin nested
-- Oscar Wilde
=end nested
=end nested

=head2 Tables

Check out this page for documentation related to L<Tables|/language/tables>
Z<Eventually copy everything from tables.rakudoc and put it here>

=head2 Rakudoc comments

Rakudoc comments are comments that Rakudoc renderers ignore.

Comments are useful for I<meta>documentation (documenting the documentation).
Single-line comments use the C<=comment> marker:

=begin code
=comment Add more here about the algorithm
=end code

For multi-line comments, use a delimited C<comment> block:

=begin code
=begin comment
This comment is
multi-line.
=end comment
=end code

=head2 Semantic blocks

All uppercase block typenames are reserved for specifying standard
documentation, publishing, source components, or metainformation.

=begin code
=NAME
=AUTHOR
=VERSION
=TITLE
=SUBTITLE
=end code

=head1 Formatting codes

Formatting codes provide a way to add inline mark-up to a piece of text.

All Rakudoc formatting codes consist of a single capital letter followed immediately
by a set of single or double angle brackets; Unicode double angle brackets may
be used.

Formatting codes may nest other formatting codes.

The following codes are available: B<B>, B<C>, B<E>, B<I>, B<K>, B<L>, B<N>,
B<P>, B<R>, B<T>, B<U>, B<V>, B<X>, and B<Z>.

=head2 Bold

To format a text in bold enclose it in C<B< >>
=for code
Raku is B<awesome>

Raku is B<awesome>

=head2 Italic

To format a text in italic enclose it in C<I< >>
=for code
Raku is I<awesome>

Raku is I<awesome>

=head2 Underlined

To underline a text enclose it in C<U< >>
=for code
Raku is U<awesome>

Raku is U<awesome>

=head2 Code

To flag text as code and treat it verbatim enclose it in C<C< >>
=for code
C<my $var = 1; say $var;>

C<my $var = 1; say $var;>

=head2 Links

To create a link enclose it in C<L< >>

A vertical bar (optional) separates label and target.

The target location can be an URL (first example) or a local Rakudoc document
(second example). Local file names are relative to the base of the project, not
the current document.

=for code
Raku homepage L<https://raku.org>
L<Raku homepage|https://raku.org>

Raku homepage L<https://raku.org>

L<Raku homepage|https://raku.org>

=for code
Structure L</language/about#Structure|/language/about#Structure>
L<Structure|/language/about#Structure>

Structure L</language/about#Structure|/language/about#Structure>

L<Structure|/language/about#Structure>

To create a link to a section in the same document:
=for code
Comments L<#Comments>
L<Comments|#Comments>

Comments L<#Comments>

L<Comments|#Comments>

Alongside the normal way of describing a path, viz. C«L<Some reference|path/to/filename>», it is also
possible to use the module-style notation, e.g., C«L<Some reference|path::to::filename>».

=head2 Placement links

This code is not implemented in C<Pod::To::HTML>, but it is implemented
in C<Raku::Pod::Render>.

A second kind of link E<mdash> the C<P<>> or B<placement link> E<mdash> works
in the opposite direction. Instead of directing focus out to another
document, it allows you to assimilate the contents of another document
into your own.

In other words, the C<P<>> formatting code takes a URI and (where possible)
inserts the contents of the corresponding document inline in place of the
code itself.

C<P<>> codes are handy for breaking out standard elements of
your documentation set into reusable components that can then be
incorporated directly into multiple documents. For example:

=begin code
=COPYRIGHT
P<file:/shared/docs/std_copyright.rakudoc>

=DISCLAIMER
P<http://www.MegaGigaTeraPetaCorp.com/std/disclaimer.txt>
=end code

might produce:

=begin nested
B<Copyright>

=nested This document is copyright (c) MegaGigaTeraPetaCorp, 2006. All rights reserved.

B<Disclaimer>

=begin nested
ABSOLUTELY NO WARRANTY IS IMPLIED. NOT EVEN OF ANY KIND. WE HAVE SOLD
YOU THIS SOFTWARE WITH NO HINT OF A SUGGESTION THAT IT IS EITHER USEFUL
OR USABLE. AS FOR GUARANTEES OF CORRECTNESS...DON'T MAKE US LAUGH! AT
SOME TIME IN THE FUTURE WE MIGHT DEIGN TO SELL YOU UPGRADES THAT PURPORT
TO ADDRESS SOME OF THE APPLICATION'S MANY DEFICIENCIES, BUT NO PROMISES
THERE EITHER. WE HAVE MORE LAWYERS ON STAFF THAN YOU HAVE TOTAL
EMPLOYEES, SO DON'T EVEN *THINK* ABOUT SUING US. HAVE A NICE DAY.
=end nested
=end nested

If a renderer cannot find or access the external data source for a
placement link, it must issue a warning and render the URI directly in
some form, possibly as an outwards link. For example:

=begin nested
B<Copyright>

=nested See: C<file:/shared/docs/std_copyright.rakudoc>

B<Disclaimer>

=nested See: L<http://www.MegaGigaTeraPetaCorp.com/std/disclaimer.txt>
=end nested

You can use any of the following URI forms (see L<#Links>) in a
placement link.

=head2 Comments

A comment is text that is never rendered.

To create a comment enclose it in C<Z< >>
=for code
Raku is awesome Z<Of course it is!>

Raku is awesome Z<Of course it is!>

=head2 Notes

Notes are rendered as footnotes.

To create a note enclose it in C<N< >>
=for code
Raku is multi-paradigmatic N<Supporting Procedural, Object Oriented, and Functional programming>

Raku is multi-paradigmatic N<Supporting Procedural, Object Oriented, and Functional programming>

=head2 Keyboard input

To flag text as keyboard input enclose it in C<K< >>
=for code
Enter your name K<John Doe>

Enter your name K<John Doe>

=head2 Replaceable

The C<R<>> formatting code specifies that the contained text is a
B<replaceable item>, a placeholder, or a metasyntactic variable. It is
used to indicate a component of a syntax or specification that should
eventually be replaced by an actual value. For example:

=begin code
The basic C<ln> command is: C<ln> R<source_file> R<target_file>
=end code

The basic C<ln> command is: C<ln> R<source_file> R<target_file>

=head2 Terminal output

To flag text as terminal output enclose it in C<T< >>
=for code :lang<rakudoc>
Hello T<John Doe>

Hello T<John Doe>

=head2 Unicode

To include Unicode code points or HTML5 character references in a Rakudoc document,
enclose them in C<E< >>

C<E< >> can enclose a number, which is treated as the decimal Unicode
value for the desired code point. It can also enclose explicit binary, octal,
decimal, or hexadecimal numbers using the Raku notations for explicitly based
numbers.

=begin code
Raku makes considerable use of the E<171> and E<187> characters.

Raku makes considerable use of the E<laquo> and E<raquo> characters.

Raku makes considerable use of the E<0b10101011> and E<0b10111011> characters.

Raku makes considerable use of the E<0o253> and E<0o273> characters.

Raku makes considerable use of the E<0d171> and E<0d187> characters.

Raku makes considerable use of the E<0xAB> and E<0xBB> characters.
=end code

Raku makes considerable use of the « and » characters.

=head2 Verbatim text

This code is not implemented by C<Pod::To::HTML>, but is implemented in
C<Raku::Pod::Render>.

The C<V<>> formatting code treats its entire contents as being B<verbatim>,
disregarding every apparent formatting code within it. For example:

=for code
The B<V< V<> >> formatting code disarms other codes
such as V< I<>, C<>, B<>, and M<> >.

Note, however that the C<V<>> code only changes the way its
contents are parsed, I<not> the way they are rendered. That is, the
contents are still wrapped and formatted like plain text, and the
effects of any formatting codes surrounding the C<V<>> code
are still applied to its contents. For example the previous example
is rendered as:

=nested
The B<V< V<> >> formatting code disarms other codes
such as V< I<>, C<>, B<>, and M<> >.

=head2 Indexing terms

Anything enclosed in an C<X<>> code is an B<index entry>. The contents
of the code are both formatted into the document and used as the
(case-insensitive) index entry:

=begin code :allow<B> :lang<rakudoc>
An B<X<array>> is an ordered list of scalars indexed by number,
starting with 0. A B<X<hash>> is an unordered collection of scalar
values indexed by their associated string key.
=end code

You can specify an index entry in which the indexed text and the index
entry are different, by separating the two with a vertical bar:

=begin code :allow<B> :lang<rakudoc>
An B<X<array|arrays>> is an ordered list of scalars indexed by number,
starting with 0. A B<X<hash|hashes>> is an unordered collection of
scalar values indexed by their associated string key.
=end code

In the two-part form, the index entry comes after the bar and is
case-sensitive.

You can specify hierarchical index entries by separating indexing levels
with commas:

=begin code :allow<B> :lang<rakudoc>
An X<array|B<arrays, definition of>> is an ordered list of scalars
indexed by number, starting with 0. A X<hash|B<hashes, definition of>>
is an unordered collection of scalar values indexed by their
associated string key.
=end code

You can specify two or more entries for a single indexed text, by separating
the entries with semicolons:

=begin code :allow<B> :lang<rakudoc>
A X<hash|B<hashes, definition of; associative arrays>>
is an unordered collection of scalar values indexed by their
associated string key.
=end code

The indexed text can be empty, creating a "zero-width" index entry:

=begin code :allow<B> :lang<rakudoc>
B<X<|puns, deliberate>>This is called the "Orcish Maneuver"
because you "OR" the "cache".
=end code

=head1 Accessing Pod

In order to access Rakudoc documentation from within a Raku program the
special C<=> twigil, as documented
in the L<variables section|/language/variables#The_=_twigil>, must be used.

The C<=> twigil provides the introspection over the Rakudoc structure,
providing a L<Pod::Block|/type/Pod::Block> tree root from which it is possible
to access the whole structure of the Rakudoc document.

As an example, the following piece of code introspects
its own Rakudoc documentation:

=begin code
=begin pod

=head1 This is a head1 title

This is a paragraph.

=head2 Subsection

Here some text for the subsection.

=end pod

for $=pod -> $pod-item {
    for $pod-item.contents -> $pod-block {
      $pod-block.raku.say;
    }
}
=end code

producing the following output:

=for code
Pod::Heading.new(level => 1, config => {}, contents => [Pod::Block::Para.new(config => {}, contents => ["This is a head1 title"])]);
Pod::Block::Para.new(config => {}, contents => ["This is a paragraph."]);
Pod::Heading.new(level => 2, config => {}, contents => [Pod::Block::Para.new(config => {}, contents => ["Subsection"])]);
Pod::Block::Para.new(config => {}, contents => ["Here some text for the subsection."]);

=head1 Rendering Rakudoc

Rakudoc is rendered into an output format, such as HTML, MarkDown, and epub by Renderers.

There are several renderers available as modules. They are listed below.

=head2 C<Pod::To::Text>

This is a part of the Rakudo compiler and so does not need to be separately installed.

Using the terminal, run the following command:
=begin code :lang<shell>
raku --doc=Text input.rakudoc > output.txt
=end code

You can omit the C<=Text> portion:

=begin code :lang<shell>
raku --doc input.rakudoc > output.txt
=end code

You can even embed Rakudoc directly in your program and add the
traditional Unix command line "--man" option to your program with a
multi MAIN subroutine like this:

=begin code
multi MAIN(Bool :$man) {
    run $*EXECUTABLE, '--doc', $*PROGRAM;
}
=end code

Now C<myprogram --man> will output your Rakudoc rendered as a man page.

=head2 C<Pod::To::HTML>

This was the first renderer and is installed using zef:

    zef install Pod::To::HTML

It does not implement all of the Rakudoc specification as above. Most of the blocks and format codes
are hard coded. Some of the file structure, such as page headers, is supplied using Templates.

This means that Pod can be rendered quickly. But it is not extensible.

=head2 C<Raku::Pod::Render>

This began life as a drop-in replacement for `Pod::To::HTML` but with all Blocks and
Format Codes rendered using templates that can be supplied externally.

The Raku documentation site is rendered into HTML using this renderer.

It offers a number of extensions of Rakudoc as described above, but does not implement some
Block level standard metadata, namely C<:formatted>, <:margin>, <:nested>.

=head3 Metadata available to all blocks

C<:template<my-special> >
=begin nested
This option is a C<Raku::Pod::Render> extension and subsumes the specified C<:formatted>, <:nested> and <:margin> options.

A pod-block is normally rendered using default templates. It is possible to add new templates to the
template list, and for the code block to be rendered using the new template.

This option tells the Renderer to render the pod-block with the C<my-special> template.
See L<Adding new templates for existing Pod::Blocks |#Adding_new_templates_for_existing_Pod::Blocks>
for an example.
=end nested

C<:toc>
=begin nested
By default C<Nested> and C<Para> blocks are NOT placed in the Table of Contents. If it is desired
to place one of these blocks in the Table of contents, then C<:toc> can be set. It is probably best
also to set C<:toc-caption> as well (see below).

By default Named pod-blocks are placed in the Table of Contents. By setting C<:!toc> (note that a
False value is being specified), the
contents section of the Name block is not placed in the Table of Contents.

See below in L<Custom blocks distributed with C<Raku::Pod::Render>|#Custom_blocks_distributed_with_Raku::Pod::Render>
for some examples.
=end nested

C<:headlevel(dd)>
=begin nested
Named pod-blocks are by default considered to be the same level (significantly for the Table of Contents)
as C<=head1>. For custom blocks this may not be desired.

For example a diagram may be "inside" a section with C<=head2> block. So by setting C<:headlevel(3)>
as the metadata for the Custom block, it will appear in the Table of Contents at the appropriate
level.

C<:headlevel> takes precedence over C<:toc>. If C<:toc> is set and C<:headlevel> is not set, then
C<:toc> sets C<$headlevel> to 1, and C<:!toc> sets C<$headlevel> to 0.

=end nested

C<:toc-caption<A caption text> >
=begin nested
Some Custom blocks (eg., Latex below) expect the contents of the block to be used for the custom
behaviour. Normally, C<:!toc> would be included with the metadata to exclude the contents from
being included in the Table of Contents.

If it is desired to include a reference to the block in the Table of Contents, but not the contents
then C<:toc-caption> can be included in the block meta data.

This option is not valid for a C<=head> type block.

=end nested

=head3 Block pre-configuration

The C<=config> directive (as for specified Rakudoc) has the form

=begin code
    =config block-name :metadata<some-value>
=end code

C<=config> directives apply from the time they are encountered until the end of the enclosing Pod-block.

For example, to specify particular formatting for different levels of heading, you could preconfigure all the heading blocks with appropriate formatting schemes:
=begin code
    =config head1 :template<SerifHeaderBold>  :numbered
    =config head2 :template<SansHeader>
    =config head3 :template<SerifHeader>
    =config head4 :template<SerifHeader>
=end code

where I<SerifHeaderBold> etc are new templates provided by the user.

The data is provided to each template in the parameter C<config>. C<config> is a hash whose keys are the name
of the block, eg., head1, item1, code. The values associated with a key are also hashes,
containing the pair values of the metadata.

=head3 Outermost pod configuration

C<Raku::Pod::Render> provides some file-specific data to all Pod-blocks, and also the meta data specified in
the outermost Pod::Block::Named `pod`. The following data are provided:
=item name => basename of the Rakudoc file (without extension)
=item path => relative url to file from root of collection (with extension)
=item lang => language (or En by default)
=item all metadata associated with the outer C<=begin rakudoc> or C<=begin pod> block is considered
Config data too.

In addition the following metadata associated with the outermost pod block are treated specially:

=begin item
B<:no-toc>

=for nested
Do not create a Table of Contents

=end item
=begin item
B<:no-glossary>
=for nested
Do not create a Glossary (aka Index) for the document (a glossary contains all the items that are
marked up with the V<X<>> format code.

=end item
=begin item
B<:no-footnotes>
=for nested
Do not generate any footnotes on the page even if they is a V<N<>> markup in the source.

=end item

=head3 Examples of Custom blocks

The following are some Custom blocks distributed with C<Raku::Pod::Render>.

=head3 Colourful line breaks

The block was developed as a simple custom block to show how new CSS can be
associated with common HTML elements.

=begin code
=for HR :class<yellowish-dots> :!toc

=for HR :class<bluish-dots> :!toc

=for HR :class<greenish-dots> :!toc

=end code

renders as

=for HR :class<yellowish-dots> :!toc

=for HR :class<bluish-dots> :!toc

=for HR :class<greenish-dots> :!toc

=head3 Adding new templates for existing Pod::Blocks

Suppose you want a different template to act on an existing block, like Para,
which is coded as HTML C< <p> >. For example,
=begin code :allow< V >
I like this sonnet:
=for para :template<quotation> V<:author<William Shakespeare> > V<:citation<Sonnet 116>> :!toc
Let me not to the marriage of true minds\n
Admit impediments; love is not love\n
Which alters when it alteration finds,\n
Or bends with the remover to remove.
=end code

I like this sonnet:
=for para :template<quotation> :author<William Shakespeare> :citation<Sonnet 116> :!toc
Let me not to the marriage of true minds\n
Admit impediments; love is not love\n
Which alters when it alteration finds,\n
Or bends with the remover to remove.

=head3 FontAwesome icons

The difference between a B<Pod-block> and a B<FormatCode> is that a block is line oriented,
where as format codes are word/character oriented and can appear inside a line.

Since Raku treats all Unicode characters the same, Chinese/Arabic/Cyrillic glyphs can now be
specified to repeat or alias the predefined codes of C<B C I K T U E Z X N L P V >.
This means a character/glyph more appropriate in another language can be used in place of,
for example B<B> for bold.

Here V< F<> > is used to include a Fontawesome icon.
See L<font search page|https://fontawesome.com/icons>.
Make sure to filter for the free icons.

=begin code
Some FontAwesome icons

F<fas fa-ambulance> Example of ambulance

F<fas fa-car> Example of automobile

F<fas fa-bicycle> Example of bicycle

F<fas fa-bus> Example of bus

F<fas fa-truck> Example of truck

F<fas fa-wheelchair> Example of wheelchair

F<fas fab-accessible-icon> Example of accessible-icon (was wheelchair-alt in fontawesom v4)
=end code

Generates
Some FontAwesome icons

F<fas fa-ambulance> Example of ambulance

F<fas fa-car> Example of automobile

F<fas fa-bicycle> Example of bicycle

F<fas fa-bus> Example of bus

F<fas fa-truck> Example of truck

F<fas fa-wheelchair> Example of wheelchair

F<fab fa-accessible-icon> Example of accessible-icon (was wheelchair-alt in fontawesome v4)

FontAwesome has some other options.
=begin code

Train normal size F<fas fa-train> Triple size train F<fas fa-train|fa-3x>

An animated spinner F<fas fa-sync|fa-spin fa-3x fa-fw>
=end code
Generates

Train normal size F<fas fa-train> Triple size train F<fas fa-train|fa-3x>

An animated spinner F<fas fa-sync|fa-spin fa-3x fa-fw>

=head3 Graphviz

This block introduces a directed graph in the dot language. It is rendered into HTML as an svg using the
dot program. Since a graph data is require, only the delimited form of the block (starting with =begin/=end)
will be used.

The following diagraph comes from the C<dot> documentation. The following Rakudoc
=begin code
=begin Graphviz :toc-caption<Digraph example> :headlevel(4)
    digraph G {
        main -> parse -> execute;
        main -> init;
        main -> cleanup;
        execute -> make_string;
        execute -> printf
        init -> make_string;
        main -> printf;
        execute -> compare;
    }
=end Graphviz
=end code

produces

=begin Graphviz :toc-caption<Digraph example> :headlevel(4)
    digraph G {
        main -> parse -> execute;
        main -> init;
        main -> cleanup;
        execute -> make_string;
        execute -> printf
        init -> make_string;
        main -> printf;
        execute -> compare;
    }
=end Graphviz

=head3 Latex

This plugin block sends the Latex markup to the CodeCogs online equation editor. For example,

=begin code
=for Latex :!toc
\begin{align*}
\sum_{i=1}^{k+1} i^{3}
&= \biggl(\sum_{i=1}^{n} i^{3}\biggr) +  i^3\\
&= \frac{k^{2}(k+1)^{2}}{4} + (k+1)^3 \\
&= \frac{k^{2}(k+1)^{2} + 4(k+1)^3}{4}\\
&= \frac{(k+1)^{2}(k^{2} + 4k + 4)}{4}\\
&= \frac{(k+1)^{2}(k+2)^{2}}{4}
\end{align*}
=end code

=for Latex :!toc
\begin{align*}
\sum_{i=1}^{k+1} i^{3}
&= \biggl(\sum_{i=1}^{n} i^{3}\biggr) +  i^3\\
&= \frac{k^{2}(k+1)^{2}}{4} + (k+1)^3 \\
&= \frac{k^{2}(k+1)^{2} + 4(k+1)^3}{4}\\
&= \frac{(k+1)^{2}(k^{2} + 4k + 4)}{4}\\
&= \frac{(k+1)^{2}(k+2)^{2}}{4}
\end{align*}

=head2 Markdown

In order to generate Markdown from Pod, you need
the L<Pod::To::Markdown module|https://github.com/softmoth/perl6-pod-to-markdown>.

If it is not already installed, install it by running the following command:
C<zef install Pod::To::Markdown>

Once installed, run the following command in the terminal:
=begin code :lang<shell>
raku --doc=Markdown input.rakudoc > output.md
=end code

If the C<Raku::Pod::Render> distribution is installed, then it contains a C<Pod::To::MarkDown2>
module. This allows for

    raku --doc=MarkDown2 input.rakudoc > output.md

=end pod
