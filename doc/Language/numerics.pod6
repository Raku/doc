=begin pod :tag<perl6>

=TITLE Numerics

=SUBTITLE Numeric types available in PerlÂ 6

=head1 C<Int>

The C<Int> type offers arbitrary-size integer numbers. They can get as big
as your computer memory allows, although some implementations choose to
throw a numeric overflow error when asked to produce integers of truly
staggering size:

=begin code :skip-test<compile-time constant folding will throw example error>
say 10**600**600
# OUTPUT: Â«Numeric overflowâ¤Â»
=end code

Unlike some languages, division performed using
L<CÂ«/Â» operator|/routine/$SOLIDUS> when both operands are of L<Int>
type, would produce a fractional number, without any rounding performed.

=begin code
say 4/5; # OUTPUT: Â«0.8â¤Â»
=end code

The type produced by this division is either a L<Rat> or a L<Num> type. The
L<Rat> is produced if, after reduction, the fraction's denominator is smaller
than 64 bits, otherwise a L<Num> type is produced.

The L<div> and L<narrow> routines can be helpful if you wish to end
up with an L<Int> result, whenever possible. The L<div> operator performs
integer division, discarding the remainder, while L<narrow> fits the number
into the narrowest type it'll fit:

=begin code
say 5 div 2; # OUTPUT: Â«2â¤Â»

# Result `2` is narrow enough to be an Int:
say (4/2).narrow; # OUTPUT: Â«2â¤Â»
say (4/2).narrow.^name; # OUTPUT: Â«Intâ¤Â»

# But 2.5 has fractional part, so it ends up being a Rat type:
say (5/2).narrow.^name; # OUTPUT: Â«Ratâ¤Â»
say (5/2).narrow;       # OUTPUT: Â«2.5â¤Â»

# Denominator is too big for a Rat, so a Num is produced:
say 1 / 10â¹â¹; # OUTPUT: Â«1e-99â¤Â»
=end code

PerlÂ 6 has L<FatRat> type that offers arbitrary precision fractions. How come
a limited-precision L<Num> is produced instead of a L<FatRat> type in the
last example above? The reason is: performance. Most operations are fine
with a little bit of precision lost and so do not require the use of a more
expensive L<FatRat> type. You'll need to instantiate one yourself if you wish
to have the extra precision.

=head1 C<Num>

The L<Num> type offers
L<double-precision floating-point|https://en.wikipedia.org/wiki/Double-precision_floating-point_format> decimal numbers, sometimes called "doubles" in other languages.

A L<Num> literal is written with the exponent separated using letter C<e>. Keep
in mind that letter C<e> B<is required> even if the exponent is zero, as
otherwise you'll get a L<Rat> or L<MidRat> rational literal instead:

=begin code
say 42e0.^name; # OUTPUT: Â«Numâ¤Â»
say 42.0.^name; # OUTPUT: Â«Ratâ¤Â»
=end code

Case-sensitive words L<Inf> and L<NaN> represent special values infinity and
not-a-number respectively. The U+221E INFINITY (C<âˆ>) character can be used
instead of L<Inf>:

PerlÂ 6 follows the
L<IEEE 754-2008 Standard for Floating-Point Arithmetic|https://en.wikipedia.org/wiki/IEEE_754> as much as possible, with
more conformance planned to be implemented in later language versions. The
language guarantees the closest representable number is chosen for any given
L<Num> literal and does offer support for negative zero and
L<denormals|https://en.wikipedia.org/wiki/Denormal_number> (also known as
"subnormals").

Keep in mind that output routines like L<say> or L<put> do not try very hard to
distinguish between how L<Numeric> types are output and may choose to display
a L<Num> as an L<Int> or a L<Rat> number. For a more definitive string to
output, use the L<perl> method:

=begin code
say  1e0;      # OUTPUT: Â«1â¤Â»
say .5e0;      # OUTPUT: Â«0.5â¤Â»
say  1e0.perl; # OUTPUT: Â«1e0â¤Â»
say .5e0.perl; # OUTPUT: Â«0.5e0â¤Â»
=end code

=head1 C<Complex>

The L<Complex> type numerics of the
L<complex plane|https://en.wikipedia.org/wiki/Complex_plane>. The L<Complex>
objects consist of two L<Num> objects representing the
L<real|/routine/re> and L<imaginary|/routine/im> portions of the complex number.

To create a L<Complex>, you can use the LÂ«postfix C<i> operator|/routine/iÂ»
on any other non-complex number, optionally setting the real part with
addition. To use the C<i> operator on C<NaN> or C<Inf> literals, separate it
from them with a backslash.

=begin code
say 42i;      # OUTPUT: Â«0+42iâ¤Â»
say 73+42i;   # OUTPUT: Â«73+42iâ¤Â»
say 73+Inf\i; # OUTPUT: Â«73+Inf\iâ¤Â»
=end code

Keep in mind the above syntax is just an addition expression and precedence
rules apply. It also cannot be used in places that forbit expressions, such
as literals in routine parameters.

=begin code
# Precedence of `*` is higher than that of `+`
say 2 * 73+10i; # OUTPUT: Â«146+10iâ¤Â»
=end code

To avoid these issues, you can choose to use the L<Complex> literal syntax
instead, which involves surrounding the real and imaginary parts with angle
brackets, I<without any spaces>:

=begin code
say 2 * <73+10i>; # OUTPUT: Â«146+20iâ¤Â»

multi how-is-it (<2+4i>) { say "that's my favorite number!" }
multi how-is-it (|)      { say "meh"                        }
how-is-it 2+4i;  # OUTPUT: Â«that's my favorite number!â¤Â»
how-is-it 3+2i;  # OUTPUT: Â«mehâ¤Â»
=end code

=head1 C<Rational>

The types that do the L<Rational> role offer high-precision and
arbitrary-precision decimal numbers. Since the higher the precision the
larger the performance penalty, the L<Rational> types come in three flavours:
L<Rat>, L<MidRat>, and L<FatRat>. The L<Rat> is the most oft-used variant
that degrades into a L<Num> when it can no longer hold all of the requested
precision. The L<FatRat> is the arbitrary-precision variant that keeps growing
to provide all of the requested precision. Lastly, the L<MidRat> type is
somewhat in-between of a L<Rat> and L<FatRat>: offering arbitrary-precision
but degrading like a L<Rat>, when used in lower-precision operations.

=head2 C<Rat>

The most common of L<Rational> types. It supports rationals with denominators
as large as 64 bits (after reduction of the fraction to the lowest denominator).

The L<Rat> literals use syntax similar to L<Num> literals in many other
languages, using the dot to indicate the number is a decimal:

=begin code
say .1 + .2 == .3; # OUTPUT: Â«Trueâ¤Â»
=begin code

If you try to execute a statement similar to the above in many common
languages, you'll get C<False> as the answer, due to imprecision of
floating point math. To get the same result in PerlÂ 6, you'd have to use
L<Num> literals instead:

=begin code
say .1e0 + .2e0 == .3e0; # OUTPUT: Â«Falseâ¤Â»
=begin code

You can also use LÂ«C</> division operator|/routine/$SOLIDUSÂ» with L<Int> or
L<Rat> objects to produce a L<Rat>:

=begin code
say 3/4;     # OUTPUT: Â«0.75â¤Â»
say 3/4.2;   # OUTPUT: Â«0.714286â¤Â»
say 1.1/4.2; # OUTPUT: Â«0.261905â¤Â»
=end code

Keep in mind the above syntax is just a division expression and precedence
rules apply. It also cannot be used in places that forbit expressions, such
as literals in routine parameters.

=begin code
# Precedence of power operators is higher than division
say 3/2Â²; # OUTPUT: Â«0.75â¤Â»
=end code

To avoid these issues, you can choose to use the L<Rational> literal syntax
instead, which involves surrounding the numerator and denominator with angle
brackets, I<without any spaces>:

=begin code
say <3/2>Â²; # OUTPUT: Â«2.25â¤Â»

multi how-is-it (<3/2>) { say "that's my favorite number!" }
multi how-is-it (|)     { say "meh"                        }
how-is-it 3/2;  # OUTPUT: Â«that's my favorite number!â¤Â»
how-is-it 1/3;  # OUTPUT: Â«mehâ¤Â»
=end code

Lastly, any Unicode character with property C<No> that represents a fractional
number can be used as a L<Rat> literal:

=begin code
say Â½ + â…“ + â… + â…™; # OUTPUT: Â«1.625â¤Â»
=end code

=head3 Degradation to C<Num>

If a I<mathematical operation> that produces a L<Rat> answer would produce
a L<Rat> with denominator larger than 64 bits, that operation would instead
return a L<Num> object. When I<constructing> a L<Rat> (i.e. when it is not
a result of some mathematical expression), however, in similar
circumstances a L<MidRat> type is produced instead.

=head2 C<MidRat>

The L<MidRat> type is the
L<allomorph|/language/glossary#index-entry-Allomorph>
of a L<Rat> and L<FatRat> types: it's used when construction of a L<Rat> object
is attempted, but too much precision is requested. The L<MidRat> can hold
all of the given precision, just like a L<FatRat> would, but it doesn't have
the same "infectiousness" so if it's not used in high-precision operations with
other L<FatRat> objects, it'll degrade to a L<Num>, just like a L<Rat> object
would.

Attempts to I<construct> a L<Rat> with denominator larger (after reduction)
than 64 bits in size produce a L<MidRat>
object (L<MidRatStr> allomorph for L<RatStr> allomorph constructon). Such
construction occurs when a L<Rational> literal is typed in the code, the
LÂ«C<Str.Rat>|Â» or LÂ«C<Str.Numeric>|/type/Str#method_NumericÂ» methods are
used, or a L<RatStr> allomorph is created using L<val>,
L<angle brackets|/language/quoting#index-entry-<_>_word_quote>, or other
allomorph-producing means, such as arguments to
LÂ«C<MAIN> routine|/language/functions#sub_MAINÂ» or calling
LÂ«C<RatStr.new>|/type/RatStr#method_newÂ». Mathematical operations are B<NOT>
subject to this rule and instead degrade their result to a L<Num> instead.

=head2 C<FatRat>

The last L<Rational> typeâ€”L<FatRat>â€”keeps all of the precision you ask of
it, storing the numerator and denominator as two L<Int> objects. A L<FatRat>
is more infectious than a L<Rat>, so many math operations with a L<FatRat> will
produce another L<FatRat>, preserving all of the available precision. Where
a L<Rat> degrades to a L<Num>, math with a L<FatRat> keeps chugging along:

=begin code
say ((42 + Rat.new(1,2))/999999999999999999).^name;         # OUTPUT: Â«Ratâ¤Â»
say ((42 + Rat.new(1,2))/9999999999999999999).^name;        # OUTPUT: Â«Numâ¤Â»
say ((42 + FatRat.new(1,2))/999999999999999999).^name;      # OUTPUT: Â«FatRatâ¤Â»
say ((42 + FatRat.new(1,2))/99999999999999999999999).^name; # OUTPUT: Â«FatRatâ¤Â»
=end code

There's no special operator or syntax available for construction of L<FatRat>
objects. Simply use LÂ«C<FatRat.new> method|/type/FatRat#(Rational)_method_newÂ»,
giving numerator as first positional argument and denominator as the second.

If your program requires a significant amount of L<FatRat> creation, you could
create your own custom operator:

=begin code
sub infix:<ğŸ™¼> { FatRat.new: $^a, $^b }
say (1ğŸ™¼3).perl; # OUTPUT: Â«FatRat.new(1, 3)â¤Â»
=end code

=head2 Printing Rationals

Keep in mind that output routines like L<say> or L<put> do not try very hard to
distinguish between how L<Numeric> types are output and may choose to display
a L<Num> as an L<Int> or a L<Rat> number. For a more definitive string to
output, use the L<perl> method:

=begin code
say 1.0;        # OUTPUT: Â«1â¤Â»
say â…“;          # OUTPUT: Â«0.333333â¤Â»
say 1.0.perl;   # OUTPUT: Â«1.0â¤Â»
say â…“.perl;     # OUTPUT: Â«<1/3>â¤Â»
=end code

For even more information, you may choose see the L<Rational> object in
the L<nude>, displaying its B<nu>merator and B<de>nominator:

=begin code
say â…“;          # OUTPUT: Â«0.333333â¤Â»
say 4/2;        # OUTPUT: Â«2â¤Â»
say â…“.perl;     # OUTPUT: Â«<1/3>â¤Â»
say <4/2>.nude; # OUTPUT: Â«(2 1)â¤Â»
=end code

=head1 Allomorphs

=head2 C<IntStr>
=head2 C<NumStr>
=head2 C<ComplexStr>
=head2 C<RatStr>
=head2 C<MidRatStr>

=head1 Native

=head2 C<int>, C<int8>, C<int16>, C<int32>, and C<int64>

=head2 C<num>, C<num32>, and C<int64>

=head1 Numeric Infectiousness

=end pod

# vim: expandtab softtabstop=4 shiftwidth=4 ft=perl6
