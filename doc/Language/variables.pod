=begin pod

=TITLE Variables

=SUBTITLE Variables in Perl 6

Variable names start with a special character called a I<sigil>, followed
optionally by a second special character named I<twigil> and then an
I<identifier>.

=head1 Sigils

The sigil serves both as a rough type constraint and as an indicator as to
whether the contents of the variable flatten in list context. See also the
documentation in L<List>.

=begin table

    Sigil   Type constraint          Default type  Flattens  Assignment
    =====   ===============          ============  ========  ==========
    $       Mu (no type constraint)  Any           No        item
    &       Callable                 Callable      No        item
    @       Positional               Array         Yes       list
    %       Associative              Hash          Yes       list

=end table

Examples:

    my $square = 9 ** 2;
    my @array  = 1, 2, 3;   # Array variable with three elements
    my %hash   = London => 'UK', Berlin => 'Germany';

Variables without sigils are also possible, see
L<sigilless variables|#Sigilless variables>.

=head2 Item and List Assignment

There are two types of assignment, I<item assignment> and I<list
assignment>.  Both use the equal sign C<=> as operator. The distinction
whether an C<=> means item or list assignment is based on the syntax of the
left-hand side.

Item assignment places the value from the right-hand side into the variable
(container) on the left.

List assignment leaves the choice of what to do to the variable on the left.

For example, L<Array> variables (C<@> sigil) empty themselves on list
assignment and then put all the values from the right-hand side into
themselves.

The type of assignment (item or list) is decided by the first context
seen in the current expression or declarator:

    my $foo = 5;            # item assignment
    say $foo.perl;          # 5

    my @bar = 7, 9;         # list assignment
    say @bar.WHAT;          # Array
    say @bar.perl;          # [7, 9]<>

    (my $baz) = 11, 13;     # list assignment
    say $baz.WHAT;          # (List)
    say $baz.perl;          # (11, 13)

Thus, the behavior of an assignment contained within a list assignment depends
on the expression or declarator that contains it.

For instance, if the internal assignment is a declarator, item assignment
is used, which has tighter precedence than both the comma and the list
assignment:

    my @array;
    @array = my $num = 42, "str";   # item assignment: uses declarator
    say @array.perl;                # [42, "str"]<> (an Array)
    say $num.perl;                  # 42 (a Num)

Similarly, if the internal assignment is an expression that is being
used as an initializer for a declarator, the context of the internal
expression determines the type of assignment:

    my $num;
    my @array = $num = 42, "str";    # item assignment: uses expression
    say @array.perl;                 # [42, "str"]<> (an Array)
    say $num.perl;                   # 42 (a Num)

    my ( @foo, $bar );
    @foo = ($bar) = 42, "str";       # list assignment: uses parens
    say @foo.perl;                   # [42, "str"]<> (an Array)
    say $bar.perl;                   # $(42, "str")  (a List)

However, if the internal assignment is neither a declarator nor an
expression, but is part of a larger expression, the context of the
larger expression determines the type of assignment:

    my ( @array, $num );
    @array = $num = 42, "str";    # list assignment
    say @array.perl;              # [42, "str"]<> (an Array)
    say $num.perl;                # [42, "str"]<> (an Array)

This is because the whole expression is C<@array = $num = 42, "str">, while
C<$num = 42> is not is own separate expression.

See L<operators|Language/operators> for more details on precedence.

=head2 Sigilless variables

It is possible to create "variables" in Perl 6 that do not have sigils:

    my \degrees = pi / 180;
    my \θ       = 15 * degrees;

Note, however, that these do not create L<containers>. That means C<degrees>
and C<θ> above actually directly represent C<Num>s. To illustrate, try
assigning to one after you've defined it:

    θ = 3; # Dies with the error "Cannot modify an immutable Num"

Sigilless variables do not enforce context, so they can be used to pass
something on as-is:

    sub logged(&f, |args) {
        say('Calling ' ~ &f.name ~ ' with arguments ' ~ args.perL)
        my \result = f(|args);
        #  ^^^^^^^ not enforcing any context here
        say(&f.name ~ ' returned ' ~ result.perl)
        return |result;
    }

=head1 Twigils

Twigils influence the scoping of a variable. Please be aware that twigils
have no influence over whether the primary sigil interpolates. That is, if
C<$a> interpolates, so do C<$^a>, C<$*a>, C<$=a>, C<$?a>, C<$.a>, etc.  It
only depends on the C<$>.

=begin table

    Twigil  Scope
    ======  =====
     *      dynamic
     !      attribute (class member)
     ?      compile-time variable
     .      method (not really a variable)
     <      index into match object (not really a variable)
     ^      self-declared formal positional parameter
     :      self-declared formal named parameter
     =      Pod variables
     ~      the sublanguage seen by the parser at this lexical spot

=end table

=head2 The C<*> Twigil

Dynamic variables are looked up through the caller, not through the outer
scope. For example:

    =begin code
    my $lexical   = 1;
    my $*dynamic1 = 10;
    my $*dynamic2 = 100;

    sub say-all() {
        say "$lexical, $*dynamic1, $*dynamic2";
    }

    # prints 1, 10, 100
    say-all();

    {
        my $lexical   = 2;
        my $*dynamic1 = 11;
        $*dynamic2    = 101;

        # prints 1, 11, 101
        say-all();
    }

    # prints 1, 10, 101
    say-all();
    =end code

The first time C<&say-all> is called, it prints "C<1, 10, 100>" just as one
would expect. The second time though, it prints "C<1, 11, 101>". This is
because C<$lexical> isn't looked up in the caller's scope but in the scope
C<&say-all> was defined in. The two dynamic variables are looked up in the
caller's scope and therefore have the values C<11> and C<101>. The third
time C<&say-all> is called C<$*dynamic1> isn't C<11> anymore, but
C<$*dynamic2> is still C<101>. This stems from the fact that we declared a
new dynamic variable C<$*dynamic1> in the block and did not assign to the
old variable as we did with C<$*dynamic2>.

The dynamic variables differ from other variable types in that refering
to an undeclared dynamic variable is not a compile time error but a
runtime L<failure|/type/Failure>, so a dynamic variable variable can be
used undeclared as long as it is checked for definedness or used in a
boolean context before using it for anything else:

    =begin code
    sub foo() {
        $*FOO // 'foo';
    }

    say foo; # -> 'foo'

    my $*FOO = 'bar';

    say foo; # -> 'bar'
    =end code


=head2 The C<!> Twigil

Attributes are variables that exist per instance of a class. They may be
directly accessed from within the class via C<!>:

    =begin code
    class Point {
        has $.x;
        has $.y;

        method Str() {
            "($!x, $!y)"
        }
    }
    =end code

Note how the attributes are declared as C<$.x> and C<$.y> but are still
accessed via C<$!x> and C<$!y>. This is because in Perl 6 all attributes are
private and can be directly accessed within the class by using
C<$!attribute-name>. Perl 6 may automatically generate accessor methods for
you though. For more details on objects, classes and their attributes see
L<object orientation|/language/objects>.

=head2 The C<?> Twigil

Compile-time variables may be addressed via the C<?> twigil. They are known
to the compiler and may not be modified after being compiled in. A popular
example for this is:

    say "$?FILE: $?LINE"; # prints "hello.pl: 23" if this is the 23 line of a
                          # file named "hello.pl".

Although they may not be changed at runtime, the user is allowed to
(re)define such variables.

    constant $?TABSTOP = 4; # this causes leading tabs in a heredoc or in a POD
                            # block's virtual margin to be counted as 4 spaces.

For a list of these special variables see L<#Compile-time variables>.

=head2 The C<.> Twigil

The C<.> twigil isn't really for variables at all. In fact, something along
the lines of

    =begin code
    class Point {
        has $.x;
        has $.y;

        method Str() {
            "($.x, $.y)" # note that we use the . instead of ! this time
        }
    }
    =end code

just calls the methods C<x> and C<y> on C<self>, which are automatically
generated for you because you used the C<.> twigil when the attributes were
declared.  Note, however, that subclasses may override those methods. If you
don't want this to happen, use C<$!x> and C<$!y> instead.

The fact that the C<.> twigil just does a method call also implies that the
following is possible too:

    =begin code
    class SaySomething {
        method a() { say "a"; }
        method b() { $.a; }
    }

    SaySomething.b; # prints "a"
    =end code

For more details on objects, classes and their attributes and methods see
L<object orientation|/language/objects>.

=head2 The C«<» Twigil

The C<< < >> twigil is just an alias for C<< $/<...> >> where C<$/> is the
match variable. For more information about the match variable see L<$/> and
L<type Match|/type/Match>.

=head2 The C<^> Twigil

The C<^> twigil declares a formal positional parameter to blocks or
subroutines.  Variables of the form C<$^variable> are a type of placeholder
variable. They may be used in bare blocks to declare formal parameters to
that block. So the block in the code

    =for code :allow<B>
    for ^4 {
        say "B<$^second> follows B<$^first>";
    }

which prints

    1 follows 0
    3 follows 2

has two formal parameters, namely C<$first> and C<$second>. Note that even
though C<$^second> appears before C<$^first> in the code, C<$^first> is
still the first formal parameter to that block. This is because the
placeholder variables are sorted in Unicode order. If you have self-declared
a parameter using C<$^a> once, you may refer to it using only C<$a>
thereafter.

Subroutines may also make use of placeholder variables but only if they do
not have an explicit parameter list. This is true for normal blocks too.

    sub say-it    { say $^a; } # valid
    sub say-it()  { say $^a; } # invalid
                  { say $^a; } # valid
    -> $x, $y, $x { say $^a; } # invalid

Placeholder variables syntactically cannot have any type constraints. Be
also aware that one cannot have placeholder variables with a single
upper-case letter. This is disallowed in favor of being to able to catch
some Perl 5-isms.

=head2 The C<:> Twigil

The C<:> twigil declares a formal named parameter to a block or subroutine.
Variables declared using this form are a type of placeholder variable too.
Therefore the same things that apply to variables declared using the C<^>
twigil also apply here (with the exception that they are not positional and
therefore not ordered using Unicode order, of course). So this:

    =for code :allow<B>
    say { B<$:add> ?? $^a + $^b !! $^a - $^b }( 4, 5 ) :!add

Will print "C<-1>".

See L<^> for more details about placeholder variables.

=head2 The C<=> Twigil

The C<=> twigil is used to access Pod variables. Every Pod block in the
current file can be accessed via a Pod object, such as C<$=data>,
C<$=SYNOPSIS> or C<=UserBlock>. That is: a variable with the same name of
the desired block and a C<=> twigil.

    =begin code
    =begin Foo
    ...
    =end Foo

    #after that, $=Foo gives you all Foo-Pod-blocks
    =end code

You may access the Pod tree which contains all Pod structures as a
hierarchical data structure through C<$=pod>.

Note that all those C<$=someBlockName> support the C<Positional> and the
C<Associative> roles.

=head2 The C<~> Twigil

Note: Slangs are NYI in Rakudo.

The C<~> twigil is for referring to sublanguages (called slangs). The
following are useful:

    $~MAIN       the current main language (e.g. Perl statements)
    $~Quote      the current root of quoting language
    $~Quasi      the current root of quasiquoting language
    $~Regex      the current root of regex language
    $~Trans      the current root of transliteration language
    $~P5Regex    the current root of the Perl 5 regex language

You may C<supersede> or C<augment> these languages in your current lexical
scope by using

    augment slang Regex {  # derive from $~Regex and then modify $~Regex
        token backslash:std<\Y> { YY };
    }

or

    supersede slang Regex { # completely substitute $~Regex
        ...
    }

=head1 Variable Declarators and Scope

Most of the time it's enough to create a new variable using the C<my>
keyword:

    =for code :allow<B>
    B<my> $amazing-variable = "World";
    say "Hello $amazing-variable!"; # Hello World!

However, there are many declarators that change the details of scoping
beyond what L<#Twigils> can do.

=for table
    Declarator    Effect
    ==========    ======
    my            Introduces lexically scoped names
    our           Introduces package-scoped names
    has           Introduces attribute names
    anon          Introduces names that are private to the construct
    state         Introduces lexically scoped but persistent names
    augment       Adds definitions to an existing name
    supersede     Replaces definitions of an existing name

There are also two prefixes that resemble declarators but act on
predefined variables:

=for table
    Prefix  Effect
    ======  ======
    temp    Restores a variable's value at the end of scope
    let     Restores a variable's value at the end of scope if the block exits unsuccessfully

=head2 The C<my> Declarator

Declaring a variable with C<my> gives it lexical scope. This means it only
exists within the current block. For example:

    {
        my $foo = "bar";
        say $foo; # -> "bar"
    }
    say $foo; # !!! "Variable '$foo' is not declared"

This dies because C<$foo> is only defined as long as we are in the same
scope.

Additionally, lexical scoping means that variables can be temporarily
redefined in a new scope:

=begin code
my $location = "outside";

sub outer-location {
    # Not redefined:
    say $location;
}

outer-location; # -> "outside"

sub in-building {
    my $location = "inside";
    say $location;
}

in-building; # -> "inside"

outer-location; # -> "outside"
=end code

If a variable has been redefined, any code that referenced the outer
variable will continue to reference the outer variable. So here,
C<&outer-location> still prints the outer C<$location>:

=begin code
sub new-location {
    my $location = "nowhere"
    outer-location;
}

new-location; # -> "outside"
=end code

To make C<new-location()> print C<nowhere>, make C<$location> a dynamic
variable using L<the * twigil|#The_*_Twigil>.

C<my> is the default scope for subroutines, so C<my sub x() {}> and
C<sub x() {}> do exactly the same thing.

=head2 The C<our> Declarator

C<our> variables work just like C<my> variables, except that they also
introduce an alias into the symbol table.

    module M {
        our $Var;
        # $Var available here
    }

    # Available as $M::Var here.

=head2 The C<has> Declarator

C<has> scopes attributes to instances of a class or role, and methods to
classes or roles. C<has> is implied for methods, so C<has method x() {}>
and C<method x() {}> do the same thing.

See L<object orientation|/language/objects> for more documentation and some
examples.

=head2 The C<anon> Declarator

The C<anon> declarator prevents a symbol from getting installed in the lexical
scope, the method table and everywhere else.

For example you can use it to declare subroutines which know their own name,
but still aren't installed in a scope:

    my %operations =
        half   => anon sub half($x) { $x / 2 },
        square => anon sub square($x) { $x * $x },
        ;
    say %operations<square>.name;       # square
    say %operations<square>(8);         # 64

=head2 The C<state> Declarator

C<state> declares lexically scoped variables, just like C<my>. However,
initialization happens exactly once the first time the initialization
is encountered in the normal flow of execution. Thus, state variables
will retain their value across multiple executions of the enclosing
block or routine.

Therefore, the subroutine

=begin code

sub a {
    state @x;
    state $l = 'A';
    @x.push($l++);
};

say a for 1..6;

=end code

will continue to increment C<$l> and append it to C<@x> each time it is
called. So it will output

=begin code

[A]
[A B]
[A B C]
[A B C D]
[A B C D E]
[A B C D E F]

=end code

As seen in this example, C<$> can be used as an anonymous state variable
without an explicit C<state> declaration.

As with C<my>, declaring multiple C<state> variables must be placed
in parentheses and for declaring a single variable, parentheses may
be omitted.

=begin code

perl6 -e 'sub foo() { say ++$  }; foo() for ^3'

=end code

produces

=begin code

1
2
3

=end code

Furthermore, state variables are not required to exist in
subroutines. You could, for example, use C<$> in a one-liner to
number the lines in a file.

=begin code

perl6 -ne 'say ++$ ~ " $_"' example.txt

=end code

Finally, if you were to use multiple anonymous state variables, they would
fuction independently.

=begin code

perl6 -e '{ say ++$; say $++  } for ^5'

=end code

would produce

=begin code

1
0
2
1
3
2
4
3
5
4

=end code

=head2 The C<augment> Declarator

With C<augment>, you can add attributes and methods to existing classes and
grammars, provided you activated the C<MONKEY-TYPING> pragma first.

Since classes are usually C<our> scoped, and thus global, this means modifying
global state, which is strongly discouraged. For almost all situations, there
are better solutions.

    # don't do this
    use MONKEY-TYPING;
    augment class Int {
        method is-answer { self == 42 }
    }
    say 42.is-answer;       # True

(In this case, the better solution would be to use a
L<function|/language/functions>).

=head2 The C<supersede> Declarator

=comment TODO

=head2 The C<temp> Prefix

Like C<my>, C<temp> restores the old value of a variable at the end of its
scope. However, C<temp> does not create a new variable.

=begin code
my $cookies = 5;

sub buy-cookie { $cookies++ }

{
    my $cookies = 42;
    buy-cookie;   # Increments the outer $cookies variable
    say $cookies; # 42
                  # the outer $cookies variable is 6 now
}

{
    temp $cookies = 42;
    # Still the same $cookies, but a new value:
    buy-cookie;
    say $cookies; # -> 43
}

# Old value is restored
say $cookies; # -> 6
=end code

=head2 The C<let> Prefix

Restores the previous value if the block exits unsuccessfully. A
successful exit means the block returned a defined value or a list.

    my $answer = 42;

    {
        let $answer = 84;
        die if not Bool.pick;
        CATCH {
            default { say "it's been reset :(" }
        }
        say "we made it 84 sticks!";
    }

    say $answer;

In the above case, if the C<Bool.pick> returns true, the answer will
stay as 84 because the block returns a defined value (C<say> returns
true). Otherwise the C<die> statement will cause the block to exit
unsuccessfully, resetting the answer to 42.

=comment this is duplicated in operators.pod

=head1 Type Constraints and Initialization

Variables can have a type constraint, which goes between the declarator and
the variable name:

=begin code :allow<L>
    my Int $x = 42;
    $x = 'a string';    # throws an L<X::TypeCheck::Assignment|/type/X::TypeCheck::Assignment> error
=end code

If a scalar variable has a type constraint but no initial value, it is
initialized with the type object of the constraint type.

    my Int $x;
    say $x.^name;       # Int
    say $x.defined;     # False

Scalar variables without an explicit type constraint are typed as
L<Mu|/type/Mu> but default to the L<Any|/type/Any> type object.

Variables with the C<@> sigil are initialized with an empty
L<Array|/type/Array>; variables with the C<%> sigil are initialized with an
empty L<Hash|/type/Hash>.

The default value of a variable can be set with the C<is default> trait, and
re-applied by assigning C<Nil> to it:

    my Real $product is default(1);
    say $product;                       # 1
    $produce *= 5;
    say $product;                       # 5
    $product = Nil;
    say $product;                       # 1


=head1 Special Variables

Perl 5 is infamous for its many obscure special variables. Perl 6 also has
special variables but only has three that are extra short due to how often
they're used. Other special variables have longer, more descriptive names.

=head2 Pre-defined lexical variables

There are three special variables that are available in every block:

=begin table

    Variable    Meaning

    $_          topic variable
    $/          regex match
    $!          exceptions

=end table

=head3 The C<$_> Variable

C<$_> is the topic variable. It is the default parameter for blocks that do
not have an explicit signature, so constructs like C<for @array { ... }> and
C<given $var { ... }> bind to C<$_> simply by invoking the block.

    for <a b c> { say $_ }  # sets $_ to 'a', 'b' and 'c' in turn
    say $_ for <a b c>;     # same, even though it's not a block
    given 'a'   { say $_ }  # sets $_ to 'a'
    say $_ given 'a';       # same, even though it's not a block

C<CATCH> blocks set C<$_> to the exception that was caught. The C<~~>
smart-match operator sets C<$_> on the right-hand side expression to the
value of the left-hand side.

Calling a method on C<$_> can be shortened by leaving off the variable name:

    .say;                   # same as $_.say

C<m/regex/> and C</regex/> regex matches and C<s/regex/subst/> substitutions
work on C<$_>:

    say "Looking for strings with non-alphabetic characters...";
    for <ab:c d$e fgh ij*> {
        .say if m/<!alpha>/;
    }

This outputs:

    Looking for strings with non-alphabetic characters...
    ab:c
    d$e
    ij*

=head3 The C<$/> Variable

C<$/> is the match variable. It stores the result of the last L<Regex|regex>
match and so usually contains objects of type L<Match>.

    'abc 12' ~~ /\w+/;  # sets $/ to a Match object
    say $/.Str;         # abc

The C<Grammar.parse> method also sets the caller's C<$/> to the resulting
L<Match> object.

    use XML;
    XML.parse(slurp "filename.xml")
    say $/;

=head4 X«Positional Attributes|variable,$0;variable,$1;variable,@()»

C<$/> can have positional attributes if the L<Regex|regex> had
capture-groups in it, which are just formed with parentheses.

    'abbbbbcdddddeffg' ~~ / a (b+) c (d+ef+) g /;
    say $/[0]; # ｢bbbbb｣
    say $/[1]; # ｢dddddeff｣

These can also be accessed by the shortcuts C<$0>, C<$1>, C<$2>, etc.

    say $0; # ｢bbbbb｣
    say $1; # ｢dddddeff｣

To get all of the positional attributes, any of C<$/.list>, C<@$/>, or
C<@()> can be used.

    say @().join; # bbbbbdddddeff

=head4 X«Named Attributes|variable,$<named>;variable,%()»

C<$/> can have named attributes if the L<Regex|regex> had named
capture-groups in it, or if the Regex called out to another Regex.

    'I.... see?' ~~ / \w+ $<punctuation>=[ <-[\w\s]>+ ] \s* $<final-word> = [ \w+ . ] /;
    say $/<punctuation>; # ｢....｣
    say $/<final-word>;  # ｢see?｣

These can also be accessed by the shortcut C«$<named>».

    say $<punctuation>; # ｢....｣
    say $<final-word>;  # ｢see?｣

To get all of the named attributes, any of C<$/.hash>, C<%$/>, or C<%()> can
be used.

    say %().join;       # "punctuation     ....final-word  see?"

=head3 The C<$!> Variable

C<$!> is the error variable. If a C<try> block or statement prefix catches
an exception, that exception is stored in C<$!>. If no exception was caught,
C<$!> is set to the C<Any> type object.

Note that C<CATCH> blocks I<do not> set C<$!>. Rather they set C<$_> inside
the block to the caught exception.

=head2 Compile-time variables

=for table
    $?FILE      Which file am I in?
    $?LINE      Which line am I at?
    &?ROUTINE   Which routine am I in?
    &?BLOCK     Which block am I in?
    %?LANG      What is the current set of interwoven languages?

Other compile-time variables:

=for table
    $?SCOPE     Which lexical scope am I in?
    $?PACKAGE   Which package am I in?
    $?MODULE    Which module am I in?
    $?CLASS     Which class am I in? (as variable)
    $?ROLE      Which role am I in? (as variable)
    $?GRAMMAR   Which grammar am I in?
    $?TABSTOP   How many spaces is a tab in a heredoc or virtual margin?
    $?USAGE     The usage message generated from the signatures of MAIN subs.
    $?ENC       Default encoding of Str.encode/Buf.decode/various IO methods.

=head2 Dynamic variables

=comment There should be a better way get this table to be formatted
    properly, but if there is, Rakudo doesn't support it at the moment.

=for table
    $*ARGFILES         Magic command-line input handle.
    ==
    @*ARGS             Arguments from the command line.
    ==
    $*IN               Standard input filehandle.
    ==
    $*OUT              Standard output filehandle.
    ==
    $*ERR              Standard error filehandle.
    ==
    @*INC              Each repository is represented as an object with the CompUnitRepo
                       interface in the @*INC array
    ==
    $*TZ               The system's local timezone.
    ==
    $*CWD              The Current Working Directory.
    ==
    $*KERNEL           Which kernel am I compiled for?
    ==
    $*DISTRO           Which OS distribution am I compiling under?
    ==
    $*VM               Which virtual machine am I compiling under?
    ==
    $*PERL             Which Perl am I compiled for?
    ==
    $*PID              Process ID of the current process.
    ==
    $*PROGRAM-NAME     Path to the current executable as it was entered on the
                       command line, or C<-e> if perl was invoked with the -e flag.
    ==
    $*PROGRAM          Location (in the form of an C<IO::Path> object) of the
                       Perl program being executed.
    ==
    $*EXECUTABLE       Absolute path of the perl executable that is currently running.
    ==
    $*EXECUTABLE-NAME  The name of the perl executable that is currently running.
                       (e.g. perl6-p, perl6-m, Niecza.exe)
                       Favor $*EXECUTABLE because it is not guaranteed that the perl
                       executable is in PATH.
    ==
    $*USER             The user that is running the program. It is an object
                       that evaluates to "username (uid)".  It will evaluate
                       to the username only if treated as a string and the
                       numeric user id if treated as a number.
    ==
    $*GROUP           The primary group of the user who is running the program.
                      It is an object that evaluates to "groupname (gid)".
                      It will evaluate to the groupname only if treated as a
                      string and the numeric group id if treated as a number.
    ==
    $*HOME            An L<IO::Path> object representing the "home directory"
                      of the user that is running the program.  If the
                      "home directory" cannot be determined it will be L<Nil>
    ==
    $*SPEC            The appropriate L<IO::Spec> sub-class for the platform that
                      the program is running on.

=end pod
