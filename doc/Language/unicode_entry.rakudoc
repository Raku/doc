=begin pod :kind("Language") :subkind("Language") :category("tutorial")

=TITLE Entering unicode characters

=SUBTITLE Input methods for unicode characters in terminals, the shell, and editors

Raku allows the use of unicode characters as variable names.  Many
operators are defined with unicode symbols (in particular the L<set/bag
operators|/language/setbagmix#Operators_with_set_semantics>) as well as some quoting
constructs.  Hence it is good to know how to enter these symbols into editors,
the Raku shell and the command line, especially if the symbols aren't
available as actual characters on a keyboard.

General information about entering unicode under various operating systems
and environments can be found on the Wikipedia L<unicode input page|https://en.wikipedia.org/wiki/Unicode_input>.

=head1 XCompose (Linux)
X<|Reference,XCompose>

Xorg includes digraph support using a
L<I<Compose key>|https://en.wikipedia.org/wiki/Compose_key#GNU.2FLinux> .
The default of C<AltGr + Shift> can be remapped to something easier such as
C<Capslock>. In I<GNOME 2> and I<MATE> this can be setup under
C<Preferences ‚Üí Keyboard ‚Üí Layouts ‚Üí Options ‚Üí Position of Compose Key>.
So, for example, to input C<¬ª+¬´> you could type
C¬´CAPSLOCK > > + CAPSLOCK < <¬ª.

I<XCompose> allows customizing the digraph sequences using a C<.XCompose>
file and
L<https://github.com/kragen/xcompose/blob/master/dotXCompose> is an extremely
complete one. In I<GNOME>, I<XCompose> was overridden and replaced with a
hardcoded list, but it is possible to restore I<XCompose> by setting
C<GTK_IM_MODULE=xim> in your environment. It might be necessary to install
a xim bridge as well, such as C<uim-xim>.

=head2 Getting compose working in all programs

You may have issues using the compose key in all programs. In that case you can
try C<ibus>.

=for code :lang<shell>
input_module=xim
export GTK_IM_MODULE=$input_module
export XMODIFIERS=@im=$input_module
export QT_IM_MODULE=$input_module

If you want this to be for all users you can put this in a file C</etc/profile.d/compose.sh>,
which is the easiest way, since you won't have to deal with how different GUI
environments set up their environment variables.

If you use KDE you can put this file in C<~/.config/plasma-workspace/env/compose.sh>
and that should work. Other desktop environments will be different. Look up
how to set environment variables in yours or use the system-wide option above.

=head2 ibus
X<|Reference,ibus>

If you have problems entering high codepoint symbols such as B<üêß> using the
C<xim> input module, you can instead use ibus. You will have to install the ibus
package for your distribution. Then you will have to set it to start on load of your
Desktop environment. The command that needs to be run is:

=for code :lang<shell>
ibus-daemon --xim --verbose --daemonize --replace

Setting C<--xim> should also allow programs not using ibus to still use the xim
input method and be backward compatible.

=head1 XKB (Linux)
X<|Reference,Xkb>

The X Window System receives keyboard events using the XKB extension, which makes it possible to read the output of various kinds of keyboards, provided that there's a configuration file available.

XKB provides the concept of I<multi-layout> or I<shift levels>.
For example the symbol C<a> is the output of the key marked as "A" at level 1; the symbol C<A> belongs to the level 2 layout, which is normally reached using the shift key.
There are more levels available; one can configure a certain key, let's say the right alt key (or AltGr), as a switch to a third level. The combination of the level-3 modifier and the shift key would switch to a fourth layout: level 4.
XKB provides for the possibility to add a level 5 switch key which, used in combination with the shift key, would switch to a level 6 layout.

For an in-depth explanation see L<I<this page>|https://www.x.org/wiki/XKB/> .

The advantage of this method is that input of characters usually unreachable on a normal keyboard is as easy as pressing the combination of the shift plus another key to output an uppercase letter.

=head2 Single-user configuration

For a personal configuration it's enough to create a .xkb file and a symbol file in a C<symbols> subdirectory.
The .xkb file can be created with this command:

=for code :lang<shell>
setxkbmap -print > raku.xkb

Here's an example of such a file:

=for code :lang<text>
xkb_keymap {
  xkb_keycodes  { include "evdev+aliases(qwerty)" };
  xkb_types     { include "complete" };
  xkb_compat    { include "complete" };
  xkb_symbols   { include "pc+raku(raku)+inet(evdev)+level3(ralt_switch)+compose(caps)" };
};

This file declares the keycodes generated by the keyboard and the symbols produced on the screen.

In this case there's a PC-type keyboard whose configuration is in the file C<symbols/raku>, which may contain several variants among which the chosen is the one named C<raku>. The L<I<evdev generic input event interface>|https://en.wikipedia.org/wiki/Evdev> manages the event collection. This configuration uses the right Alt key as a third level switch and the Caps Lock as the Compose key.

Once chosen the base directory for the configuration files (it might be C<$HOME/.config/xkb> for example) and put the raku.xkb in it, one has to create a I<symbols> directory and put a key layout file in it.
Here's an example of such a file, named C<raku>:

=begin code :lang<text>
default  partial alphanumeric_keys modifier_keys
xkb_symbols "basic" {

    name[Group1]= "English (US)";

    key <TLDE> {  [     grave,  asciitilde  ]  };
    key <AE01> {  [    1,  exclam     ]  };
    key <AE02> {  [    2,  at    ]  };
    key <AE03> {  [    3,  numbersign  ]  };
    key <AE04> {  [    4,  dollar    ]  };
    key <AE05> {  [    5,  percent    ]  };
    key <AE06> {  [    6,  asciicircum  ]  };
    key <AE07> {  [    7,  ampersand  ]  };
    key <AE08> {  [    8,  asterisk  ]  };
    key <AE09> {  [    9,  parenleft  ]  };
    key <AE10> {  [    0,  parenright  ]  };
    key <AE11> {  [     minus,  underscore  ]  };
    key <AE12> {  [     equal,  plus    ]  };

    key <AD01> {  [    q,  Q     ]  };
    key <AD02> {  [    w,  W    ]  };
    key <AD03> {  [    e,  E    ]  };
    key <AD04> {  [    r,  R    ]  };
    key <AD05> {  [    t,  T    ]  };
    key <AD06> {  [    y,  Y    ]  };
    key <AD07> {  [    u,  U    ]  };
    key <AD08> {  [    i,  I    ]  };
    key <AD09> {  [    o,  O    ]  };
    key <AD10> {  [    p,  P    ]  };
    key <AD11> {  [ bracketleft,  braceleft  ]  };
    key <AD12> {  [ bracketright,  braceright  ]  };

    key <AC01> {  [    a,  A     ]  };
    key <AC02> {  [    s,  S    ]  };
    key <AC03> {  [    d,  D    ]  };
    key <AC04> {  [    f,  F    ]  };
    key <AC05> {  [    g,  G    ]  };
    key <AC06> {  [    h,  H    ]  };
    key <AC07> {  [    j,  J    ]  };
    key <AC08> {  [    k,  K    ]  };
    key <AC09> {  [    l,  L    ]  };
    key <AC10> {  [ semicolon,  colon    ]  };
    key <AC11> {  [ apostrophe,  quotedbl  ]  };

    key <AB01> {  [    z,  Z     ]  };
    key <AB02> {  [    x,  X    ]  };
    key <AB03> {  [    c,  C    ]  };
    key <AB04> {  [    v,  V    ]  };
    key <AB05> {  [    b,  B    ]  };
    key <AB06> {  [    n,  N    ]  };
    key <AB07> {  [    m,  M    ]  };
    key <AB08> {  [     comma,  less    ]  };
    key <AB09> {  [    period,  greater    ]  };
    key <AB10> {  [     slash,  question  ]  };

    key <BKSL> {  [ backslash,         bar  ]  };
};

partial alphanumeric_keys
xkb_symbols "raku" {

   include "raku(basic)"
   name[Group1]= "English (raku operators, with AltGr)";

   key <TLDE> { [     grave, asciitilde, dead_grave, leftsinglequotemark   ] }; //‚Äò
   key <AE01> { [         1,     exclam,      U00B9                        ] }; //¬π
   key <AE02> { [         2,         at,      U00B2                        ] }; //¬≤
   key <AE03> { [         3, numbersign,      U00B3,      U2026            ] }; //¬≥‚Ä¶
   key <AE04> { [         4,     dollar,      U2074                        ] }; //‚Å¥
   key <AE05> { [         5,    percent,      U2075                        ] }; //‚Åµ
   key <AE06> { [         6,asciicircum,      U2076                        ] }; //‚Å∂
   key <AE07> { [         7,  ampersand,      U2077                        ] }; //‚Å∑
   key <AE08> { [         8,   asterisk,      U2078,      multiply         ] }; //‚Å∏√ó
   key <AE09> { [         9,  parenleft,      U2079                        ] }; //‚Åπ
   key <AE10> { [         0, parenright,      U2070                        ] }; //‚Å∞
   key <AE11> { [     minus, underscore,      U2212,      U207B            ] }; //‚Åª‚àí
   key <AE12> { [     equal,       plus,      U2261,      U207A            ] }; //‚â°‚Å∫
   key <BKSL> { [ backslash,        bar,      U2262,      U221E            ] }; //‚â¢‚àû
   key <AD03> { [         e,          E,   EuroSign,      U1D452           ] }; //‚Ç¨ùëí
   key <AD05> { [         t,          T,      U03C4,      U2296            ] }; //œÑ‚äñ
   key <AD07> { [         u,          U,      U222A,      U2229            ] }; //‚à™‚à©
   key <AD09> { [         o,          O,      U2218                        ] }; //‚àò
   key <AD10> { [         p,          P,      U03C0                        ] }; //œÄ
   key <AD11> { [ bracketleft,  braceleft,    U2260,      U201E            ] }; //‚â†‚Äû
   key <AD12> { [ bracketright, braceright,   U2245,      U201A            ] }; //‚âÖ‚Äö
   key <AC01> { [         a,          A,      U2208,      U2209            ] }; //‚àà‚àâ
   key <AC02> { [         s,          S,      U220B,      U220C            ] }; //‚àã‚àå
   key <AC09> { [         l,          L,      UFF62,      UFF63            ] }; //ÔΩ¢ÔΩ£
   key <AC10> { [ semicolon,      colon,      U201C,      U201D            ] }; //‚Äú‚Äù
   key <AC11> { [apostrophe,   quotedbl,  rightsinglequotemark             ] }; //‚Äô
   key <AB02> { [         x,          X,      U2284,      U2285            ] }; //‚äÑ ‚äÖ
   key <AB03> { [         c,          C,      U2283,      U2283            ] }; //‚äÇ ‚äÉ
   key <AB05> { [         b,          B,      U228E,      U228D            ] }; //‚äé‚äç
   key <AB06> { [         n,          N,      U269B                        ] }; //‚öõ
   key <AB08> { [     comma,       less,   guillemotleft, U2264            ] }; //¬´‚â§
   key <AB09> { [    period,    greater,  guillemotright, U2265            ] }; //¬ª‚â•
   key <AB10> { [     slash,   question,   division,      U2216            ] }; //√∑‚àñ

   include "level3(ralt_switch)"
};
=end code

This file contains two layouts: the first is the basic layout of a US keyboard with just two shift levels, the second one includes the first and adds several Unicode symbols to some of the keys using two additional shift levels.
The format of this file is documented L<I<here>|https://www.x.org/releases/X11R7.5/doc/input/XKB-Enhancing.html>.

For a different keyboard one needs to change the first layout, marked C<basic>, with the one pertaining to the specific national layout. Usually these layouts are located in the C</usr/share/X11/xkb/symbols> directory. After that one has to modify the second layout to conform to the specific language key layout.

If one's base directory is $HOME/.config/xkb, this command will load the new configuration:

=for code :lang<shell>
xkbcomp -I$HOME/.config/xkb $HOME/.config/xkb/raku.xkb $DISPLAY

(There might be some warnings for symbols not defined)

While this is a non-invasive method, one has to load manually the configuration file whenever is needed.

=head2 System-wide configuration

The advantage of this method is that since it modifies the system files, the user can choose the new layout using the usual interface provided by their desktop manager and make it permanent.

The drawbacks are that one has to have root access to the system and that a system upgrade might overwrite one's layout file.

To modify the system-wide configuration one has to locate the specific file describing their language mapping and add the C<raku> part shown in the previous section.

In order for the new layout to show in the system menus one has to add a specific description in the C<evdev> rule file, usually in C</usr/share/X11/xkb/rules/evdev.xml>. Locate the section corresponding the one's language keyboard layout. For example the C<us> layout starts like this:

=for code :lang<xml>
  [‚Ä¶]
  <layoutList>
    <layout>
      <configItem>
        <name>us</name>
        <!-- Keyboard indicator for English layouts -->
        <shortDescription>en</shortDescription>
        <description>English (US)</description>
        <languageList>
          <iso639Id>eng</iso639Id>
        </languageList>
      </configItem>
      <variantList>
        <variant>
          <configItem>
          [‚Ä¶]

One has to add the newly defined variant:

=for code :lang<xml>
        <variant>
          <configItem>
            <name>raku</name>
            <description>raku (Raku operators, with AltGr)</description>
            <languageList>
              <iso639Id>eng</iso639Id>
            </languageList>
          </configItem>
        </variant>

After logging out and in again, the new variant should appear in the list of the layouts and variants.
Alternatively one can now load the layout with this command:

=for code :lang<shell>
setxkbmap -layout us -variant raku

This actually reloads the C<raku> variant of the C<us> keyboard, but unfortunately disables other keyboard layouts in case of multi-keyboard use.

=head3 KDE

If you are using KDE, open the start menu and type in ‚ÄúAutostart‚Äù and click B<Autostart>
which should be the first result. In the settings window that opens, click
B<Add program>, type in C<ibus-daemon> and click OK. Then go into the Application
tab of the window that pops up. In the C<Command> field, enter in the full
ibus-daemon command as shown above, with the C<--desktop> option set to
C<--desktop=plasma>. Click OK. It should now launch automatically when you
log in again.

=head3 How to enter Unicode characters using a two-key combination

Using the XCompose input method it is possible to enter Unicode characters using simple two-key combinations.
Here's an example of a configuration which would enable entering all the Unicode characters used by Raku.
This example uses both Super keys as C<dead keys>. For example, to enter the C<œÄ> symbol one has to press and
release the right C<Super> (or "Windows") key, then press and release the C<p> key.

=for code :lang<shell>
<Super_R> <less>               : "¬´" guillemotleft
<Super_R> <greater>            : "¬ª" guillemotright
<Super_R> <minus>              : "‚Åª"   U207B
<Super_R> <0>                  : "‚Å∞"   U2070
<Super_R> <1>                  : "¬π"   U00B9
<Super_R> <2>                  : "¬≤"   U00B2
<Super_R> <3>                  : "¬≥"   U00B3
<Super_R> <4>                  : "‚Å¥"   U2074
<Super_R> <5>                  : "‚Åµ"   U2075
<Super_R> <6>                  : "‚Å∂"   U2076
<Super_R> <7>                  : "‚Å∑"   U2077
<Super_R> <8>                  : "‚Å∏"   U2078
<Super_R> <9>                  : "‚Åπ"   U2079
<Super_R> <asterisk>           : "√ó"   U00D7
<Super_R> <slash>              : "√∑"   U00F7
<Super_R> <E>                  : "ùëí"   U1D452
<Super_R> <p>                  : "œÄ"   U03C0
<Super_R> <t>                  : "œÑ"   U03C4
<Super_R> <grave>              : "‚Äò"   U2018
<Super_R> <apostrophe>         : "‚Äô"   U2019
<Super_R> <comma>              : "‚Äö"   U201A
<Super_R> <colon>              : "‚Äú"   U201C
<Super_R> <quotedbl>           : "‚Äù"   U201D
<Super_R> <L>                  : "‚Äû"   U201E
<Super_R> <period>             : "‚Ä¶"   U2026
<Super_R> <bracketleft>        : "‚â°"   U2261
<Super_R> <bracketright>       : "‚â¢"   U2262
<Super_L> <8>                  : "‚àû"   U221E
<Super_L> <O>                  : "‚àÖ"   U2205
<Super_L> <e>                  : "‚àà"   U2208
<Super_L> <E>                  : "‚àâ"   U2209
<Super_L> <3>                  : "‚àã"   U220B
<Super_L> <numbersign>         : "‚àå"   U220C
<Super_L> <minus>              : "‚àí"   U2212
<Super_L> <slash>              : "‚àñ"   U2216
<Super_L> <o>                  : "‚àò"   U2218
<Super_L> <U>                  : "‚à©"   U2229
<Super_L> <u>                  : "‚à™"   U222A
<Super_L> <asciitilde>         : "‚âÖ"   U2245
<Super_L> <equal>              : "‚â†"   U2260
<Super_L> <less>               : "‚â§"   U2264
<Super_L> <greater>            : "‚â•"   U2265
<Super_L> <c>                  : "‚äÇ"   U2283
<Super_L> <C>                  : "‚äÉ"   U2283
<Super_L> <v>                  : "‚äÑ"   U2284
<Super_L> <V>                  : "‚äÖ"   U2285
<Super_R> <d>                  : "‚äÜ"   U2286
<Super_R> <D>                  : "‚äá"   U2287
<Super_R> <f>                  : "‚äà"   U2288
<Super_R> <F>                  : "‚äâ"   U2289
<Super_R> <U>                  : "‚äç"   U228D
<Super_R> <u>                  : "‚äé"   U228E
<Super_L> <t>                  : "‚äñ"   U2296
<Super_L> <L>                  : "ÔΩ¢"   UFF62
<Super_L> <l>                  : "ÔΩ£"   UFF63

One can add these lines to their ~/.XCompose file. To activate the changes one needs to exit their X session
and login back again.
Note that since Ubuntu Gnome uses one C<Super> key for its own purposes, one might want to substitute one or
both the Super_* keys with, for example, Meta_R.

=head1 WinCompose (Windows)
X<|Reference,WinCompose>

L<WinCompose|https://github.com/samhocevar/wincompose> adds
L<compose key|https://en.wikipedia.org/wiki/Compose_key> functionality to Windows.
It can be installed either via the L<WinCompose releases|https://github.com/samhocevar/wincompose/releases>
page on GitHub, or with the L<Chocolatey package manager|https://chocolatey.org/packages/wincompose>.

Once the program is installed and running, right click the tray icon and
select C<Options ‚Üí Composing ‚Üí Behavior ‚Üí Compose Key> to set your desired key.

WinCompose has multiple sources to choose from in C<Options ‚Üí Composing ‚Üí Sequences>.
It is recommended to enable C<XCompose> and disable C<Xorg>, as there are a handful
of operators which C<Xorg> does not provide sequences for, and C<Xorg> also has
sequences which conflict with operator sequences present in C<XCompose>.
Sequences can be viewed by right clicking the tray icon and selecting C<Show Sequences>.
If you wish to add your own sequences, you can do so by either adding/modifying
C<.XCompose> in C<%USERPROFILE%>, or editing user-defined sequences in the options menu.

=head1 Terminals, shells, and editors:

=head2 XTerm

Unicode support is enabled in XTerm primarily by setting its C<utf8> and
C<utf8Fonts> options to C<1>, along with its C<locale> option to C<UTF-8>, in
C<~/.Xdefaults>. Here is a sample configuration that supports displaying enough
of unicode to program in Raku:

    =begin code :lang<.Xdefaults>
    XTerm*faceName:           xft:Noto Mono:style=Regular
    XTerm*faceNameDoublesize: xft:Noto Emoji:style=Regular
    XTerm*faceSize:           10
    XTerm*locale:             UTF-8
    XTerm*titleModes:         16
    XTerm*utf8:               1
    XTerm*utf8Fonts:          1
    XTerm*utf8Title:          true
    =end code

=head2 URxvt

Similarly to XTerm, unicode support is enabled in URxvt primarily by setting
its C<locale> option to C<en_US.UTF-8> in C<~/.Xdefaults>. Here is a sample
configuration that supports displaying enough of unicode to program in Raku:

    =begin code :lang<.Xdefaults>
    URxvt*font:              xft:Noto Mono:pixelsize=14:style=Regular,\
                             xft:Noto Emoji:pixelsize=14:style=Regular
    URxvt*letterSpace:       -1
    URxvt*locale:            en_US.UTF-8
    URxvt*skipBuiltInGlyphs: true
    =end code

=head2 Unix shell

At the bash shell, one enters unicode characters by using entering
C<Ctrl-Shift-u>, then the unicode code point value followed by enter.  For
instance, to enter the character for the element-of operator (‚àà) use the
following key combination (whitespace has been added for clarity):

    =begin code :lang<shell>
    Ctrl-Shift-u 2208 Enter
    =end code

This also the method one would use to enter unicode characters into the
C<raku> REPL, if one has started the REPL inside a Unix shell.

=head2 Screen

L<GNU Screen|https://www.gnu.org/software/screen/> does sport a B<digraph>
command but with a rather limited digraph table. Thanks to B<bindkey> and
B<exec> an external program can be used to insert characters to the current
screen window.

    =begin code :lang<screen>
    bindkey ^K exec .! digraphs
    =end code

This will bind control-k to the shell command digraphs. You can use
L<digraphs|https://github.com/gfldex/digraphs> if you prefer a Raku friendly
digraph table over L<RFC 1345|https://tools.ietf.org/html/rfc1345> or change it
to your needs.

=head2 Vim
X<|Reference,Vim>

In L<Vim|https://www.vim.org/>, unicode characters are entered (in
insert-mode) by pressing first C<Ctrl-V> (also denoted C<^V>), then C<u> and
then the hexadecimal value of the unicode character to be entered.  For
example, the Greek letter Œª (lambda) is entered via the key combination:

    =begin code :lang<vim>
    ^Vu03BB
    =end code

You can also use C<Ctrl-K>/C<^K> along with a digraph to type in some
characters.  So an alternative to the above using digraphs looks like this:

    =begin code :lang<vim>
    ^Kl*
    =end code

The list of digraphs Vim provides is documented
L<here|http://vimdoc.sourceforge.net/htmldoc/digraph.html>; you can add
your own with the C<:digraph> command.

Further information about entering special characters in Vim can be found on
the Vim Wikia page about L<entering special characters|http://vim.wikia.com/wiki/Entering_special_characters>.

=head3 vim-raku

The L<vim-raku|https://github.com/Raku/vim-raku> plugin for Vim can be
configured to optionally replace ASCII based ops with their Unicode based
equivalents. This will convert the ASCII based ops on the fly while typing
them.

=head2 Emacs
X<|Reference,Emacs>

In L<Emacs|https://www.gnu.org/software/emacs/>, unicode characters are
entered by first entering the chord C<C-x 8 RET> at which point the
text C<Unicode (name or hex):> appears in the minibuffer.  One then enters
the unicode code point hexadecimal number followed by the enter key.  The
unicode character will now appear in the document.  Thus, to enter the Greek
letter Œª (lambda), one uses the following key combination:

    =begin code :lang<emacs>
    C-x 8 RET 3bb RET
    =end code

Further information about unicode and its entry into Emacs can be found on
the L<Unicode Encoding Emacs wiki page|https://www.emacswiki.org/emacs/UnicodeEncoding>.

You can also use L<RFC 1345|https://tools.ietf.org/html/rfc1345> character
mnemonics by typing:

    =begin code :lang<emacs>
    C-x RET C-\ rfc1345 RET
    =end code

Or C<C-u C-\ rfc1345 RET>.

To type special characters, type C<&> followed by a mnemonic.
Emacs will show the possible characters in the echo area.
For example, Greek letter Œª (lambda) can be entered by typing:

    =begin code :lang<emacs>
    &l*
    =end code

You can use C<C-\> to toggle
L<input method|https://www.gnu.org/software/emacs/manual/html_node/emacs/Select-Input-Method.html>.

Another L<input method|https://www.emacswiki.org/emacs/InputMethods>
you can use to insert special characters is
L<TeX|https://www.emacswiki.org/emacs/TeXInputMethod>.
Select it by typing C<C-u C-\ TeX RET>. You can enter a special character
by using a prefix such as C<\>. For example, to enter Œª, type:

    =begin code :lang<tex>
    \lambda
    =end code

To view characters and sequences provided by an input method,
run the C<describe-input-method> command:

    =begin code :lang<tex>
    C-h I TeX
    =end code

=head1 Some characters useful in Raku

=head2 L<Smart quotes|https://en.wikipedia.org/wiki/Quotation_mark#Curved_quotes_and_Unicode>

These characters are used in different languages as quotation marks. In Raku
they are used as L<quoting characters|/language/quoting>

Constructs such as these are now possible:

    say ÔΩ¢What?!ÔΩ£;
    say ‚ÄùWhoa!‚Äú;
    say ‚ÄûThis works too!‚Äù;
    say ‚ÄûThere are just too many ways‚Äú;
    say ‚Äúhere: ‚Äúno problem‚Äù at all!‚Äù; # You can nest them!

This is very useful in shell:

    =begin code :lang<shell>
    raku -e 'say ‚Äòhello world‚Äô'
    =end code

since you can just copy and paste some piece of code and not worry about quotes.

=head2 L<Guillemets|https://en.wikipedia.org/wiki/Guillemet>

These characters are used in French and German as quotation marks. In Raku
they are used as L<interpolation word quotes|/language/quoting#Word_quoting_with_interpolation_and_quote_protection:_qqww>,
L<hyper operators|/language/operators#Hyper_operators> and as an angle bracket
alternative in POD6.

=begin table
    symbol   unicode code point   ascii equivalent
    ------   ------------------   ----------------
    ¬´        U+00AB               <<
    ¬ª        U+00BB               >>
=end table

Thus constructs such as these are now possible:

    say (1, 2) ¬ª+¬´ (3, 4);     # OUTPUT: ¬´(4 6)‚ê§¬ª - element-wise add
    [1, 2, 3] ¬ª+=¬ª 42;         # add 42 to each element of @array
    say ¬´moo¬ª;                 # OUTPUT: ¬´moo‚ê§¬ª

    my $baa = "foo bar";
    say ¬´$baa $baa ber¬ª.raku;  # OUTPUT: ¬´("foo", "bar", "foo", "bar", "ber")‚ê§¬ª

=head2 Set/bag operators

The L<set/bag operators|/language/setbagmix#Operators_with_set_semantics> all
have set-theory-related symbols, the unicode code points and their ascii
equivalents are listed below.  To compose such a character, it is merely
necessary to enter the character composition chord (e.g. C<Ctrl-V u> in Vim;
C<Ctrl-Shift-u> in Bash) then the unicode code point hexadecimal number.

=begin table
    operator   unicode code point   ascii equivalent
    --------   ------------------   ----------------
    ‚àà          U+2208               (elem)
    ‚àâ          U+2209               !(elem)
    ‚àã          U+220B               (cont)
    ‚àå          U+220C               !(cont)
    ‚â°          U+2261               (==)
    ‚â¢          U+2262               !(==)
    ‚äÜ          U+2286               (<=)
    ‚äà          U+2288               !(<=)
    ‚äÇ          U+2282               (<)
    ‚äÑ          U+2284               !(<)
    ‚äá          U+2287               (>=)
    ‚äâ          U+2289               !(>=)
    ‚äÉ          U+2283               (>)
    ‚äÖ          U+2285               !(>)
    ‚à™          U+222A               (|)
    ‚à©          U+2229               (&)
    ‚àñ          U+2216               (-)
    ‚äñ          U+2296               (^)
    ‚äç          U+228D               (.)
    ‚äé          U+228E               (+)
=end table

=head2 Mathematical symbols

Wikipedia contains a full list of L<mathematical operators and symbols in unicode|https://en.wikipedia.org/wiki/Mathematical_operators_and_symbols_in_Unicode>
as well as links to their mathematical meaning.

=head2 Greek characters

Greek characters may be used as variable names.  For a list of Greek and
Coptic characters and their unicode code points see the L<Greek in Unicode Wikipedia article|https://en.wikipedia.org/wiki/Greek_alphabet#Greek_in_Unicode>.

For example, to assign the value 3 to œÄ, enter the following in Vim
(whitespace added to the compose sequences for clarity):

    =begin code :allow<B> :lang<vim>
    my $B<Ctrl-V u 03C0> = 3;  # same as: my $œÄ = 3;
    say $B<Ctrl-V u 03C0>;     # 3    same as: say $œÄ;
    =end code

=head2 Superscripts and subscripts

A limited set of
L<superscripts and subscripts|https://en.wikipedia.org/wiki/Superscripts_and_Subscripts>
can be created directly in unicode by using the C<U+207x>, C<U+208x> and
(less often) the C<U+209x> ranges.  However, to produce a value squared (to
the power of 2) or cubed (to the power of 3), one needs to use C<U+00B2> and
C<U+00B3> since these are defined in the
L<Latin1 supplement Unicode block|https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)>.

Thus, to write the L<Taylor series|https://en.wikipedia.org/wiki/Taylor_series>
expansion around zero of the function C<exp(x)> one would input into e.g.
vim the following:

    =begin code :allow<B> :lang<vim>
    exp(x) = 1 + x + xB<Ctrl-V u 00B2>/2! + xB<Ctrl-V u 00B3>/3!
    + ... + xB<Ctrl-V u 207F>/n!
    # which would appear as
    exp(x) = 1 + x + x¬≤/2! + x¬≥/3! + ... + x‚Åø/n!
    =end code

Or to specify the elements in a list from C<1> up to C<k>:

    =begin code :allow<B> :lang<vim>
    AB<Ctrl-V u 2081>, AB<Ctrl-V u 2082>, ..., AB<Ctrl-V u 2096>
    # which would appear as
    A‚ÇÅ, A‚ÇÇ, ..., A‚Çñ
    =end code

=end pod
