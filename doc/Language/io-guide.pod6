=begin pod :tag<perl6>

=TITLE Input/Output The Definitive Guide

=SUBTITLE Correctly use Perl 6 IO

=head1 The Basics

The vast majority of IO work is done using L<IO::Path>. If you're reading or
writing to a file, this is the class you want to use. It hides away
file handle (or "file descriptor") details so you mostly don't have to think about
them.

Behind the scenes, L<IO::Path> uses the L<IO::Handle> class.

When working with other processes, e.g. via L<Proc> or L<Proc::Async>
types, you'll work with L<IO::Pipe>, a subclass of L<IO::Handle>.

Additionally, you have L<IO::CatHandle> and <IO::Spec> (and its
subclasses, which you'll rarely, if ever, use directly). These classes give you
advanced features, such as operating on multiple files with one handle; and
access to low-level file and directory manipulations.

L<IO::Socket> and its subclasses are also involved with input and output, but
this guide doesn't cover them.

=head1 Navigating Paths

=head2 What's an IO::Path Anyway?

To represent file or directory paths, use the L<IO::Path> type.
The simplest way to obtain an object of that type is to coerce a L<Str> by
calling the L«C<.IO>|/routine/IO» method on it:

    say 'my-file.txt'.IO; # OUTPUT: «"my-file.txt".IO␤»

It may seem like something is missing here—there's no volume or absolute
path involved—but that information is actually present in the object. You can
see it by using the L«C<.perl>|/routine/perl» method:

    say 'my-file.txt'.IO.perl;
    # OUTPUT: «IO::Path.new("my-file.txt", :SPEC(IO::Spec::Unix), :CWD("/home/camelia"))␤»

The two extra attributes—C<SPEC> and C<CWD>—specify what type of operating
system semantics the path should use as well as the "current working directory"
for the path.

This means that regardless of how you made one, an L<IO::Path> object
always refers to an absolute path. This is why its
L«C<.absolute>|/routine/absolute» and L«C<.relative>|/routine/relative»
methods return L<Str> objects and they are the correct way to stringify a path.

However, don't be in a rush to stringify paths. Pass paths around as
L<IO::Path|/type/IO::Path> objects. All routines that operate on paths
can handle IO objects, too.

=head2 Working with Files

=head3 Writing into files

=head4 Writing new content

Now, let's make some files and do some reading and writing. The
L«C<spurt>|/routine/spurt» and L«C<slurp>|/routine/slurp» routines read and
write data all at once. Unless you're working with files that
are too big to store entirely in memory, use these routines for reading and writing.

=for code :skip-test

    "my-file.txt".IO.spurt: "I ♥ Perl 6!";

The code above creates a file named C<my-file.txt> in the current directory
and then writes C<I ♥ Perl 6!> into it. You can verify the results with a text
editor.

Now, you may be wondering if we overlooked handling encoding or error
conditions. We didn't. The string will be encoded in C<utf-8> by default and
errors will be handled via the L<Failure> mechanism, meaning any L<Exceptions|/type/Exception> will get thrown.

=head4 Appending content

To add additional content to our file, the L«C<spurt> documentation|/routine/spurt» mentions the C<:append>
argument. However, for finer control, let's work with the L<IO::Handle> class:

    my $fh = 'my-file.txt'.IO.open: :a;
    $fh.print: "I count: ";
    $fh.print: "$_ " for ^10;
    $fh.close;

The L«C<.open>|/routine/open» method call opens our L<IO::Path> and returns
an L<IO::Handle>. We pass C<:a> as an argument, to indicate we want to open
the file for writing in append mode.

We then use the L«C<.print>|/routine/print»
method to print ten lines of
text. Once again, the L<Failure> mechanism takes care of the error
checking for us. If the L«C<.open>|/routine/open» fails, it returns
a L<Failure>, which will throw when we attempt to call the
L«C<.print>|/routine/print» method.

Finally, we close the L<IO::Handle> by calling the L«C<.close>
documentation|/routine/close» method. It's important that you do this,
especially if you're working with many open files, since Perl 6 doesn't use
reference counting to close file handles once the scope they're defined in is
gone. Instead, file handles are closed by Perl 6 only during garbage collection.
If garbage collection doesn't get around to closing your handles before your
system's open file limitations are reached, your program may fail.

=head3 Reading from files

=head1 The Wrong Way To Do Things

This section describes how NOT to do Perl 6 IO.

=head2 Leave $*SPEC Alone

Unless you're writing your own IO framework,
you almost never need to use L«C<$*SPEC>|/language/variables#Dynamic_variables»
directly. L«C<$*SPEC>|/language/variables#Dynamic_variables» provides low-level
stuff and its use will not only make your code harder to read, you'll likely
introduce security issues (e.g. null characters)!

The L«C<IO::Path>|/type/IO::Path» type is the workhorse of the Perl 6 world. It
caters to all the path manipulation needs and provides shortcut routines
that let you avoid dealing with file handles. Use that instead of the
L«C<$*SPEC>|/language/variables#Dynamic_variables» stuff.

Tip: you can join path parts with C</> and feed them to
L«C<IO::Path>|/type/IO::Path»'s routines; they'll still do The Right Thing™
regardless of the operating system.

=for code :skip-test
# WRONG!! TOO MUCH WORK!
my $fh = open $*SPEC.catpath: '', 'foo/bar', $file;
my $data = $fh.slurp;
$fh.close;

# RIGHT! Use IO::Path to do all the dirty work
my $data = 'foo/bar'.IO.add($file).slurp;

=head2 Stringifying IO::Path

Don't use the C<.Str> method to stringify L«C<IO::Path>|/type/IO::Path» objects,
unless you just want to display them for information purposes.
The C<.Str> method returns whatever the basic path string the
L«C<IO::Path>|/type/IO::Path» was instantiated with. It doesn't consider the
value of L«C<$.CWD> attribute|/type/IO::Path#attribute_CWD». For example, this
code is broken:

=for code :skip-test
# WRONG!! .Str DOES NOT USE $.CWD!
my $path = 'foo'.IO;
chdir 'bar';
run <tar -cvvf archive.tar>, ~$path;

The L«C<chdir>|/routine/chdir» call changed the value of the current directory,
but the C<$path> we created is relative to the directory before that change.

However, the L«C<IO::Path>|/type/IO::Path» object does know what directory
it's relative to. We just need to use L«C<.absolute>|/routine/absolute» or
L«C<.relative>|/routine/relative» to stringify the object. Both routines return
a L«C<Str>|/type/Str» object; they only differ in whether the result is an
absolute or relative path. So, we can fix our code like this:

=for code :skip-test
# RIGHT!! .absolute does consider the value of $.CWD!
my $path = 'foo'.IO;
chdir 'bar';
run <tar -cvvf archive.tar>, $path.absolute;
# Also good:
run <tar -cvvf archive.tar>, $path.relative;

=head2 Be mindful of $*CWD

While usually out of view, every L«C<IO::Path>|/type/IO::Path» object by
default uses the current value of
L«C<$*CWD>|/language/variables#Dynamic_variables» to set its
L«C<$.CWD> attribute|/type/IO::Path#attribute_CWD». This means there are two
things to pay attention to.

=head3 temp the $*CWD

This is wrong:

=for code :skip-test
# WRONG!!
my $*CWD = "foo".IO;

The C<my $*CWD> made L«C<$*CWD>|/language/variables#Dynamic_variables»
undefined. The L«C<.IO>|/routine/IO» coercer
then sets the L«C<$.CWD> attribute|/type/IO::Path#attribute_CWD»
of the path its creating to the stringified version of the undefined C<$*CWD>. The result is an empty string.

The correct way to perform this operation is to use
L«C<temp>|/routine/temp» instead of C<my>. It'll localize the effect of changes
to L«C<$*CWD>|/language/variables#Dynamic_variables», just like C<my> would
but it won't make it undefined; so the L«C<.IO>|/routine/IO» coercer will still
get the correct old value:

=for code :skip-test
temp $*CWD = "foo".IO;

Better yet, if you want to execute some code in localized
L«C<$*CWD>|/language/variables#Dynamic_variables», use the
L«C<indir> routine|/routine/indir» for that purpose.

=end pod

# vim: expandtab shiftwidth=4 ft=perl6
