=begin pod :tag<perl6>

=TITLE Input/Output The Definitive Guide

=SUBTITLE Correctly use Perl 6 IO

=head1 The Basics

The vast majority of IO work is done using L<IO::Path>. If you're reading or
writing to a file, this is the class you want to use. It hides away
file handle (or "file descriptor") details so you mostly don't have to think about
them.

Behind the scenes, L<IO::Path> uses the L<IO::Handle> class.

When working with other processes, e.g. via L<Proc> or L<Proc::Async>
types, you'll work with L<IO::Pipe>, a subclass of L<IO::Handle>.

Additionally, you have L<IO::CatHandle> and <IO::Spec> (and its
subclasses, which you'll rarely, if ever, use directly). These classes give you
advanced features, such as operating on multiple files with one handle; and
access to low-level file and directory manipulations.

L<IO::Socket> and its subclasses are also involved with input and output, but
this guide doesn't cover them.

=head1 Navigating Paths

=head2 What's an IO::Path Anyway?

To represent file or directory paths, use the L<IO::Path> type.
The simplest way to obtain an object of that type is to coerce a L<Str> by
calling the L«C<.IO>|/routine/IO» method on it:

    say 'my-file.txt'.IO; # OUTPUT: «"my-file.txt".IO␤»

It may seem like something is missing here—there's no volume or absolute
path involved—but that information is actually present in the object. You can
see it by using the L«C<.perl>|/routine/perl» method:

    say 'my-file.txt'.IO.perl;
    # OUTPUT: «IO::Path.new("my-file.txt", :SPEC(IO::Spec::Unix), :CWD("/home/camelia"))␤»

The two extra attributes—C<SPEC> and C<CWD>—specify what type of operating
system semantics the path should use as well as the "current working directory"
for the path.

This means that regardless of how you made one, an L<IO::Path> object
always refers to an absolute path. This is why its
L«C<.absolute>|/routine/absolute» and L«C<.relative>|/routine/relative»
methods return L<Str> objects and they are the correct way to stringify a path.

However, don't be in a rush to stringify paths. Pass paths around as
L<IO::Path|/type/IO::Path> objects. All routines that operate on paths
can handle IO objects, too.

=head2 Working with Files

=head3 Writing into files

=head4 Writing new content

Now, let's make some files and do some reading and writing. The
L«C<spurt>|/routine/spurt» and L«C<slurp>|/routine/slurp» routines read and
write data all at once. Unless you're working with files that
are too big to store entirely in memory, use these routines for reading and writing.

=for code :skip-test

    "my-file.txt".IO.spurt: "I ♥ Perl 6!";

The code above creates a file named C<my-file.txt> in the current directory
and then writes C<I ♥ Perl 6!> into it. You can verify the results with a text
editor.

Now, you may be wondering if we overlooked handling encoding or error
conditions. We didn't. The string will be encoded in C<utf-8> by default and
errors will be handled via the L<Failure> mechanism, meaning any L<Exceptions|/type/Exception> will get thrown.

=head4 Appending content

To add additional content to our file, the L«C<spurt> documentation|/routine/spurt» mentions the C<:append>
argument. However, for finer control, let's work with the L<IO::Handle> class:

=for code :skip-test
    my $fh = 'my-file.txt'.IO.open: :a;
    $fh.print: "I count: ";
    $fh.print: "$_ " for ^10;
    $fh.close;

The L«C<.open>|/routine/open» method call opens our L<IO::Path> and returns
an L<IO::Handle>. We pass C<:a> as an argument, to indicate we want to open
the file for writing in append mode.

We then use the L«C<.print>|/routine/print»
method to print ten lines of
text. Once again, the L<Failure> mechanism takes care of the error
checking for us. If the L«C<.open>|/routine/open» fails, it returns
a L<Failure>, which will throw when we attempt to call the
L«C<.print>|/routine/print» method.

Finally, we close the L<IO::Handle> by calling the L«C<.close>
documentation|/routine/close» method. It's important that you do this,
especially if you're working with many open files, since Perl 6 doesn't use
reference counting to close file handles once the scope they're defined in is
gone. Instead, file handles are closed by Perl 6 only during garbage collection.
If garbage collection doesn't get around to closing your handles before your
system's open file limitations are reached, your program may fail.

=head3 Reading from files

=head4 Using IO::Path

We've seen in previous sections that writing stuff to files is a single-line
of code in Perl 6. Reading from them, is similarly easy:

=for code :skip-test
    say 'my-file.txt'.IO.slurp;        # OUTPUT: «I ♥ Perl!␤»
    say 'my-file.txt'.IO.slurp: :bin;  # OUTPUT: «Buf[uint8]:0x<49 20 e2 99 a5 20 50 65 72 6c 21>␤»

The L«C<.slurp>|/routine/slurp» method reads entire contents of the file
and returns them as a single L<Str> object, or as a L<Buf> object, if binary
mode was requested, by specifying C<:bin> named argument.

Since L«slurping|/routine/slurp» loads the entire file into memory, it's not
ideal for working with huge files.

The L<IO::Path> type offers two other handy methods:
L«C<.words>|/type/IO::Path#method_words» and
L«C<.lines>|/type/IO::Path#method_lines» that lazily read the file in smaller
chunks and return L<Seq> objects that (by default) don't keep already-consumed
values around.

Here's an example that finds lines in a text file that mention Perl and prints
them out. Despite the file itself being too large to fit into available
L<RAM|https://en.wikipedia.org/wiki/Random-access_memory>, the program will
not have any issues running, as the contents are processed in small chunks:

=for code :skip-test
    .say for '500-PetaByte-File.txt'.IO.lines.grep: *.contains: 'Perl';

Here's another example that prints the first 100 words from a file, without
loading it entirely:

=for code :skip-test
    .say for '500-PetaByte-File.txt'.IO.words: 100

Note that we did this by passing a limit argument to
L«C<.words>|/type/IO::Path#method_words» instead of, say, using
L<a list indexing operation\/language/operators#index-entry-array_indexing_operator-array_subscript_operator-array_indexing_operator>.
The reason for that is there's still a file handle in use under the hood, and
until you fully consume the returned L<Seq>, the handle will remain open.
If nothing references the L<Seq>, eventually the handle will get closed, during
a garbage collection run, but in large programs that work with a lot of files,
it's best to ensure all the handles get closed right away. So, always ensure
the L<Seq> from L<IO::Path>'s
L«C<.words>|/type/IO::Path#method_words» and
L«C<.lines>|/type/IO::Path#method_lines» methods is
L<fully reified|/language/glossary#index-entry-Reify>; and the limit argument
is there to help you with that.

=head4 Using IO::Handle

Of course, you can read from files using L<IO::Handle> type, which gives you
a lot finer control over what you're doing:

=begin code :skip-test
    given 'some-file.txt'.IO.open {
        say .readchars: 8;  # OUTPUT: «I ♥ Perl␤»
        .seek: 1, SeekFromCurrent;
        say .readchars: 15;  # OUTPUT: «I ♥ Programming␤»
        .close
    }
=end code

The L<IO::Handle> gives you
L«.read|/type/IO::Handle#method_read»,
L«.readchars|/type/IO::Handle#method_readchars»,
L«.get|/type/IO::Handle#routine_get»,
L«.getc|/type/IO::Handle#method_getc»,
L«.words|/type/IO::Handle#routine_words»,
L«.lines|/type/IO::Handle#routine_lines»,
L«.slurp|/type/IO::Handle#routine_slurp»,
L«.comb|/type/IO::Handle#method_comb»,
L«.split|/type/IO::Handle#method_split»,
and L«.Supply|/type/IO::Handle#method_Supply»
methods to read data from it. Plenty of
options; and the catch is you need to close the handle when you're done with it.

Unlike some languages, the handle won't get automatically closed when the
scope it's defined in is left. Instead, it'll remain open until it's garbage
collected. To make the closing business easier, some of the methods let you
specify C<:close> argument, you can also use
L«C<will leave> trait|/language/phasers#index-entry-will_trait», or the
C<does auto-close> trait provided by
L«C<Trait::IO>|https://modules.perl6.org/dist/Trait::IO» module.

=head1 The Wrong Way To Do Things

This section describes how NOT to do Perl 6 IO.

=head2 Leave $*SPEC Alone

Unless you're writing your own IO framework,
you almost never need to use L«C<$*SPEC>|/language/variables#Dynamic_variables»
directly. L«C<$*SPEC>|/language/variables#Dynamic_variables» provides low-level
stuff and its use will not only make your code harder to read, you'll likely
introduce security issues (e.g. null characters)!

The L«C<IO::Path>|/type/IO::Path» type is the workhorse of the Perl 6 world. It
caters to all the path manipulation needs and provides shortcut routines
that let you avoid dealing with file handles. Use that instead of the
L«C<$*SPEC>|/language/variables#Dynamic_variables» stuff.

Tip: you can join path parts with C</> and feed them to
L«C<IO::Path>|/type/IO::Path»'s routines; they'll still do The Right Thing™
regardless of the operating system.

=for code :skip-test
# WRONG!! TOO MUCH WORK!
my $fh = open $*SPEC.catpath: '', 'foo/bar', $file;
my $data = $fh.slurp;
$fh.close;

# RIGHT! Use IO::Path to do all the dirty work
my $data = 'foo/bar'.IO.add($file).slurp;

=head2 Stringifying IO::Path

Don't use the C<.Str> method to stringify L«C<IO::Path>|/type/IO::Path» objects,
unless you just want to display them for information purposes.
The C<.Str> method returns whatever the basic path string the
L«C<IO::Path>|/type/IO::Path» was instantiated with. It doesn't consider the
value of L«C<$.CWD> attribute|/type/IO::Path#attribute_CWD». For example, this
code is broken:

=for code :skip-test
# WRONG!! .Str DOES NOT USE $.CWD!
my $path = 'foo'.IO;
chdir 'bar';
run <tar -cvvf archive.tar>, ~$path;

The L«C<chdir>|/routine/chdir» call changed the value of the current directory,
but the C<$path> we created is relative to the directory before that change.

However, the L«C<IO::Path>|/type/IO::Path» object does know what directory
it's relative to. We just need to use L«C<.absolute>|/routine/absolute» or
L«C<.relative>|/routine/relative» to stringify the object. Both routines return
a L«C<Str>|/type/Str» object; they only differ in whether the result is an
absolute or relative path. So, we can fix our code like this:

=for code :skip-test
# RIGHT!! .absolute does consider the value of $.CWD!
my $path = 'foo'.IO;
chdir 'bar';
run <tar -cvvf archive.tar>, $path.absolute;
# Also good:
run <tar -cvvf archive.tar>, $path.relative;

=head2 Be mindful of $*CWD

While usually out of view, every L«C<IO::Path>|/type/IO::Path» object by
default uses the current value of
L«C<$*CWD>|/language/variables#Dynamic_variables» to set its
L«C<$.CWD> attribute|/type/IO::Path#attribute_CWD». This means there are two
things to pay attention to.

=head3 temp the $*CWD

This is wrong:

=for code :skip-test
# WRONG!!
my $*CWD = "foo".IO;

The C<my $*CWD> made L«C<$*CWD>|/language/variables#Dynamic_variables»
undefined. The L«C<.IO>|/routine/IO» coercer
then sets the L«C<$.CWD> attribute|/type/IO::Path#attribute_CWD»
of the path its creating to the stringified version of the undefined C<$*CWD>. The result is an empty string.

The correct way to perform this operation is to use
L«C<temp>|/routine/temp» instead of C<my>. It'll localize the effect of changes
to L«C<$*CWD>|/language/variables#Dynamic_variables», just like C<my> would
but it won't make it undefined; so the L«C<.IO>|/routine/IO» coercer will still
get the correct old value:

=for code :skip-test
temp $*CWD = "foo".IO;

Better yet, if you want to execute some code in localized
L«C<$*CWD>|/language/variables#Dynamic_variables», use the
L«C<indir> routine|/routine/indir» for that purpose.

=end pod

# vim: expandtab shiftwidth=4 ft=perl6
