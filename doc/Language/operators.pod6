=begin pod

=TITLE Operators

=SUBTITLE Common Perl 6 infixes, prefixes, postfixes, and more!

=head1 Operator Precedence

In an expression like C<1 + 2 * 3>, the C<2 * 3> is evaluated first
because the infix C<*> has tighter B<precedence> than the C<+>.

The following table summarizes the precedence levels in Perl 6, from
tightest to loosest:

=begin table

    A  Level             Examples
    =  =====             ========
    N  Terms             42 3.14 "eek" qq["foo"] $x :!verbose @$array
    L  Method postfix    .meth .+ .? .* .() .[] .{} .<> .«» .:: .= .^ .:
    N  Autoincrement     ++ --
    R  Exponentiation    **
    L  Symbolic unary    ! + - ~ ? | || +^ ~^ ?^ ^
    L  Multiplicative    * / % %% +& +< +> ~& ~< ~> ?& div mod gcd lcm
    L  Additive          + - +| +^ ~| ~^ ?| ?^
    L  Replication       x xx
    X  Concatenation     ~
    X  Junctive and      &
    X  Junctive or       | ^
    L  Named unary       temp let
    N  Structural infix  but does <=> leg cmp .. ..^ ^.. ^..^
    C  Chaining infix    != == < <= > >= eq ne lt le gt ge ~~ === eqv !eqv =~=
    X  Tight and         &&
    X  Tight or          || ^^ // min max
    R  Conditional       ?? !! ff fff
    R  Item assignment   = => += -= **= xx= .=
    L  Loose unary       so not
    X  Comma operator    , :
    X  List infix        Z minmax X X~ X* Xeqv ...
    R  List prefix       print push say die map substr ... [+] [*] any Z=
    X  Loose and         and andthen
    X  Loose or          or xor orelse
    X  Sequencer         <==, ==>, <<==, ==>>
    N  Terminator        ; {...}, unless, extra ), ], }

=end table

Using two C<!> symbols below generically to represent any pair of operators
that have the same precedence, the associativities specified above
for binary operators are interpreted as follows:

=begin table

    A   Assoc     Meaning of $a ! $b ! $c
    =   =====     =======================
    L   left      ($a ! $b) ! $c
    R   right     $a ! ($b ! $c)
    N   non       ILLEGAL
    C   chain     ($a ! $b) and ($b ! $c)
    X   list      infix:<!>($a; $b; $c)

=end table

For unary operators this is interpreted as:

=begin table

    A   Assoc     Meaning of !$a!
    =   =====     =========================
    L   left      (!$a)!
    R   right     !($a!)
    N   non       ILLEGAL

=end table

In the operator descriptions below, a default associativity of I<left>
is assumed.

=head1 Operator classification
X<|prefix operator>
X<|infix operator>
X<|postfix operator>
X<|circumfix operator>
X<|postcircumfix operator>

Operators can occur in several positions relative to a term:

=begin table

    +term           prefix
    term1 + term2   infix
    term++          postfix
    (term)          circumfix
    term1[term2]    postcircumfix

=end table

Each operator is also available as a subroutine.
The name of the routine is formed of
the operator category, then a colon, and a list quote construct with the
symbol(s) that make up the operator:

=begin code :skip-test
infix:<+>(1, 2);                # same as 1 + 2
circumfix:«( )»('a', 'b', 'c'); # same as ('a', 'b', 'c')
=end code

As a special case, a I<listop> (list operator) can stand either as a
term or as a prefix. Subroutine calls are the most common listops. Other
cases include meta-reduced infix operators (C<[+] 1, 2, 3>) and the
L<#prefix ...> etc. stub operators.


Defining custom operators is covered in
L<Defining Operators functions|/language/functions#Defining_Operators>.

=head1 Meta Operators

Meta operators can be parameterized with other operators or subroutines in the
same way as functions can take functions as parameters. To use a subroutine as
a parameter prefix its name with a C<&>. Perl 6 will generate the actual
combined operator in the background, allowing the mechanism to be applied to
user defined operators. There are quite a few Meta operators with different
semantics, as explained in detail as follows.

=head1 Substitution Operators

    my $str = 'match string';
    $str ~~ s/match/replacement/;
    say $str; # replacement string

    say S/match/replacement/ given 'match string'; # replacement string

The lower-case version (X<s///>) substitutes in-place, while the
upper-case version (X<S///>) leaves the original alone and returns
the resultant string.

Both operators work on `$_` variable. Since smartmatch operator aliases
the left hand side to `$_`, you can use lowercase `s///` with it, but
it's a mistake to use it with uppercase `S///`, because you can't
retrieve the modified string. The correct way is to alias the given
string by some other method, such as a `for` loop or, as is shown in the
example above, with a `given` block (in this case, it's a postfix form
of it, without curly braces).

Both operators can take the same adverbs as the
L<.subst method|/routine/subst>, which go between the `s`/`S` and the opening
`/`. Whitespace can be used liberally:

    my $str = 'match string';
    $str ~~ s:g/match/replacement/;
    say S:i :g /match/replacement/ given 'match string';

You can also use a different delimiter:

    my $str = 'foobar';
    $str ~~ s!foo!!;
    say S{foo} = {} given 'foobar';

Non-matching characters can simply replace the original slashes. Matching
characters, like braces, require an extra step where you use an
assignment operator to assign the replacement to the match part.

=head1 Assignment Operators

Infix operators can be combined with the assignment operator to modify a
value and apply the result to a container in one go. Containers will be
autovivified if possible.  Some examples:

    my $a = 32;
    $a += 10;  # 42
    $a -= 2;   # 40

    $a = 3;
    $a min= 5; # still 3
    $a min= 2; # 2

    my $s = 'a';
    $s ~= 'b'; # 'ab'

This behavior is automatically extended to include custom-defined infix operators.

    sub infix:<space-concat> ($a, $b) { $a ~ " " ~ $b };
    my $a = 'word1';
    $a space-concat= 'word2'; # 'word1 word2'

Although not strictly operators, methods can be used in the same fashion.

    my Real $a = 1/2;
    $a = 3.14;
    $a .= round; # 3

=head1 Negated Relational Operators

The result of a relational operator returning C<Bool> can be negated by
prefixing with C<!>. To avoid visual confusion with the C<!!> operator,
you may not modify any operator already beginning with C<!>.

There are shortcuts for C<!==> and C<!eq>, namely C<!=> and C<ne>.

    my $a = True;
    say so $a != True; # False
    my $i = 10;

    my $release = Date.new(:2015year, :12month, :24day);
    my $today = Date.today;
    say so $release !before $today; # False

=head1 Reversed Operators
X<|R,reverse meta operator>

Any infix operator may be called with its two arguments reversed by prefixing
with C<R>. Associativity of operands is reversed as well.

    say 4 R/ 12; # 3
    say [R/] 2, 4, 16; # 2

=head1 X<<<Hyper Operators|hyper,<<;hyper,>>;hyper,«;hyper,»>>>

Hyper operators apply a given operator enclosed by C<«> and C<»> to one or two
lists, returning the resulting list. The pointy part of C<«> or C<»> has to
point to the shorter list. A list with just one element is fine too. If one of
the lists is shorter then the other, the operator will cycle over the shorter
list until all elements of the longer list are processed.

    say (1, 2, 3) »*» 2;          # (2 4 6)
    say (1, 2, 3, 4) »~» <a b>;   # (1a 2b 3a 4b)
    say (1, 2, 3) »+« (4, 5, 6);  # (5 7 9)

Assignment meta operators can be hyped.

    my @a = 1, 2, 3;
    say @a »+=» 1; # [2 3 4]

Hyper forms of unary operators have the pointy bit point to the operator and
the blunt end at the list to be operated on.

    my @wisdom = True, False, True;
    say !« @wisdom; # [False True False]

    my @a = 1, 2, 3;
    @a»++;           # (2, 3, 4)

Hyper operators are defined recursively on nested arrays.

    say -« [[1, 2], 3]; # [[-1 -2] -3]

Methods can be called too, in an out of order, concurrent fashion. The resulting
list is in order. Please note that all hyper operators are candidates for
autothreading and will cause tears if said methods have side effects. The
optimizer has full reign over hyper operators, which is the reason that they
can not be defined by the user.

    class CarefulClass { method take-care {} }
    my CarefulClass @objs;
    my @results = @objs».take-care();

    my @slops; # May Contain Nuts
    @slops».?this-method-may-not-exist();

Hyper operators can work with hashes. The pointy direction indicates if missing
keys are to be ignored in the resulting hash. The enclosed operator operates on
all values that have keys in both hashes.

=begin table
%foo «+» %bar;       intersection of keys

%foo »+« %bar;       union of keys

%outer »+» %inner;   only keys of %inner that exist in %outer will occur in the result
=end table

    my %outer = 1, 2, 3 Z=> <a b c>;
    my %inner = 1, 2 Z=> <x z>;
    say %outer «~» %inner; # {"1" => "ax", "2" => "bz"}

Hyper operators can take user defined operators as its operator argument.

    sub pretty-file-site (Int $size --> Str) {
        # rounding version of infix:</>(Int, Int)
        sub infix:<r/>(Int \i1, Int \i2) {
            round(i1 / i2, 0.1)
        }

        # we build a vector of fractions of $size and zip that with the fitting prefix
        for $size «[r/]« (2**60, 2**50, 2**40, 2**30, 2**20, 2**10)
                  Z      <EB     PB     TB     GB     MB     KB> -> [\v,\suffix] {
            # starting with the biggest suffix, we take the first that is 0.5 of that suffix or bigger
            return v ~ ' ' ~ suffix if v > 0.4
        }
        # this be smaller or equal then 0.4 KB
        return $size.Str;
    }

    for 60, 50, 40, 30, 20, 10 -> $test {
        my &a = { (2 ** $test) * (1/4, 1/2, 1, 10, 100).pick * (1..10).pick };
        print pretty-file-site(a.Int) xx 2, ' ';
    }

    # OUTPUT: «10 EB 4 EB 2 PB 5 PB 0.5 PB 4 TB 300 GB 4.5 GB 50 MB 200 MB 9 KB 0.6 MB»

Hyper operators do not descend into child lists. You can chain hyper operators
to destructure a List of Lists.

    my $neighbors = ((-1, 0), (0, -1), (0, 1), (1, 0));
    my $p = (2, 3);
    say $neighbors »>>+<<» ($p, *); # ((1 3) (2 2) (2 4) (3 3))

=head1 Reduction Operators
X<|[] (reduction meta operators)>X<|[+] (reduction meta operators)>

The reduction metaoperator, C<[ ]>, reduces a list with the given infix
operator. It gives the same result as the L<reduce> routine - see there for
details.

    # These two are equivalent:
    say [+] 1, 2, 3;           # 6
    say reduce &[+], 1, 2, 3;  # 6

No whitespace is allowed between the brackets and the operator. To wrap a
function instead of an operator, provide an additional layer of brackets:

    sub plus { $^a + $^b };
    say [[&plus]] 1, 2, 3;  # 6

The argument list is iterated without flattening. This means that you can pass
a nested list to the reducing form of a list infix operator:

    say [X~] (1, 2), <a b>;  # 1, 2 X~ <a b>

By default, only the final result of the reduction is returned. Prefix the
wrapped operator with a C<\>, to return a lazy list of all intermediate values
instead. This is called a "triangular reduce".
If the non-meta part contains a C<\> already,
quote it with C<[]> (e.g. C<[\[\x]]>).

    my @n = [\~] 1..*;
    say @n[^5];  # (1 12 123 1234 12345)

=head1 Cross Operators
X<|X (cross meta operator)>

The cross metaoperator, C<X>, will apply a given infix operator in order of
cross product to all lists, such that the rightmost operator varies most
quickly.

    1..3 X~ <a b>
    # produces <1a, 1b, 2a, 2b, 3a, 3b>

=head1 Zip Operators
X<|Z (zip meta operator)>

The zip metaoperator, (which is not the same thing as L<Z|#infix_Z>), will
apply a given infix operator to pairs taken one left, one right, from its
arguments. The resulting list is returned.

    my @l = <a b c> Z~ 1, 2, 3; # [a1 b2 c3]

If one of the operands runs out of elements prematurely, the zip operator will
stop. An infinite list can be used to repeat elements. A list with a final
element of C<*> will repeat its 2nd last element indefinitely.

    my @l = <a b c d> Z~ ':' xx *; # <a: b: c: d:>
       @l = <a b c d> Z~ 1, 2, *;  # <a1 b2 c2 d2>

If infix operator is not given, C<,> (comma operator) will be used by default:

    my @l = 1 Z 2; # [(1 2)]

=head1 Sequential Operators
X<|S,sequential meta operator>

The sequential metaoperator, C<S>, will suppress any concurrency, or reordering
done by the optimizer. Most simple infix operators are supported.

    say so 1 S& 2 S& 3; # True

=head1 Nesting of Meta Operators

To avoid ambiguity when chaining meta operators use square brackets to help the
compiler to understand you.

    my @a = 1, 2, 3;
    my @b = 5, 6, 7;
    @a X[+=] @b;
    say @a; # [19 20 21]

=head1 Z<>Term Precedence

=head2 term C«< >»

The X<quote-words|qw;quote-words> construct. Breaks up the contents on whitespace, and returns
a L<List|/type/List> of the words. If a word
looks like a number literal or a C<Pair> literal, it is converted to the
appropriate number.

    say <a b c>[1];     # b

=head2 term C«( )»

The X<grouping operator>.

An empty group C<()> creates an L<empty list|/type/List#index-entry-()_empty_list>.
Parentheses around non-empty expressions simply structure the expression, but
not have additional semantics.

In an argument list, putting parenthesis around an argument prevents it from
being interpreted as a named argument.

    multi sub p(:$a!) { say 'named'      }
    multi sub p($a)   { say 'positional' }
    p a => 1;       # named
    p (a => 1);     # positional

=head2 term C«{ }»

Block or L<Hash> constructor.X<|block constructor;hash constructor>

If the contents looks like a list of pairs and does not use L<$_|/syntax/$_> or other
placeholder parameters, returns an itemized L<Hash>.

Otherwise it constructs a L<Block>.

Note that this construct does not re-parse the contents; rather the
contents are always parsed as a statement list (i.e. like a block),
and if the later analysis shows that it needs to be interpreted as a hash,
the block is executed and coerced to L<Hash>.

=head2 circumfix C«[ ]»

The X<L<Array> constructor>. Returns an itemized L<Array> which does not flatten
in list context.

=head1 Method Postfix Precedence

=head2 postcircumfix C«[ ]»

=begin code :skip-test
sub postcircumfix:<[ ]>(@container, **@index,
                        :$k, :$v, :$kv, :$p, :$exists, :$delete)
=end code

Universal interface for positional access to zero or more elements of a
@container, a.k.a. "X<array indexing operator|array indexing operator;array subscript operator>".

    my @alphabet = 'a' .. 'z';
    say @alphabet[0];                   #-> a
    say @alphabet[1];                   #-> b
    say @alphabet[*-1];                 #-> z
    say @alphabet[100]:exists;          #-> False
    say @alphabet[15, 4, 17, 11].join;  #-> perl
    say @alphabet[23 .. *].perl;        #-> ("x", "y", "z")

    @alphabet[1, 2] = "B", "C";
    say @alphabet[0..3].perl            #-> ("a", "B", "C", "d")

See L<Subscripts|/language/subscripts> for a more detailed explanation of this
operator's behavior, and how to implement support for it in custom types.

=head2 postcircumfix C«{ }»

=begin code :skip-test
sub postcircumfix:<{ }>(%container, **@key,
                        :$k, :$v, :$kv, :$p, :$exists, :$delete)
=end code

Universal interface for associative access to zero or more elements of a
%container, a.k.a. "X<hash indexing operator|hash indexing operator;hash subscript operator>".

    my %color = kiwi => "green", banana => "yellow", cherry => "red";
    say %color{"banana"};               #-> yellow
    say %color{"cherry", "kiwi"}.perl;  #-> ("red", "green")
    say %color{"strawberry"}:exists;    #-> False

    %color{"banana", "lime"} = "yellowish", "green";
    %color{"cherry"}:delete;
    say %color;  #-> banana => yellowish, kiwi => green, lime => green

See L«C«postcircumfix < >»|/routine/< >#(Operators)_postcircumfix_<_>» and
L<C<postcircumfix « »>|/routine/« »#(Operators)_postcircumfix_«_»> for convenient
shortcuts, and L<Subscripts|/language/subscripts> for a more detailed
explanation of this operator's behavior, and how to implement support for it
in custom types.

=head2 postcircumfix C«< >»

Shortcut for L<C<postcircumfix { }>|/routine/{ }#(Operators)_postcircumfix_{_}> that quotes
its argument using the same rules as the L«quote-words operator|
/routine/< >#circumfix_<_>» of the same name.

    my %color = kiwi => "green", banana => "yellow", cherry => "red";
    say %color<banana>;             #-> yellow
    say %color<cherry kiwi>.perl;   #-> ("red", "green")
    say %color<strawberry>:exists;  #-> False

This is not a real operator, just syntactic sugar that is turned into the
C<{ }> postcircumfix operator at compile-time.

=head2 postcircumfix C<« »>

Shortcut for L<C<postcircumfix { }>|/routine/{ }#(Operators)_postcircumfix_{_}> that quotes
its argument using the same rules as the L<interpolating quote-words operator|
/routine/« »#circumfix_«_»> of the same name.

    my %color = kiwi => "green", banana => "yellow", cherry => "red";
    my $fruit = "kiwi";
    say %color«cherry $fruit».perl;   #-> ("red", "green")

This is not a real operator, just syntactic sugar that is turned into the
C<{ }> postcircumfix operator at compile-time.

=head2 postcircumfix C«( )»

The X<call operator>. Treats the invocant as a L<Callable> and invokes it,
using the expression between the parentheses as arguments.

Note that an identifier followed by a pair of parentheses is always parsed as a
subroutine call.

If you want your objects to respond to the call operator, you need to
implement a C<method CALL-ME>.

=head2 postfix C«.»

The operator for calling one method, C<$invocant.method>.X<|method call>

Technically this is not an operator, but syntax special-cased in the compiler.

X«|postfix .&»
=head2 postfix C«.&»

The operator to call a subroutine (with at least one positional argument) like
a method. The invocant will be bound to the first positional argument.

Technically this is not an operator, but syntax special-cased in the compiler.

    my sub f($invocant){ dd $invocant; }
    my $i = 42;
    42.&f;
    # OUTPUT«Int $invocant = 42␤»
    42.&(-> $invocant { dd $invocant });
    # OUTPUT«Int $invocant = 42␤»

=head2 postfix C«.=»

A X<mutating method call>. C<$invocant.=method> desugars to
C<$invocant = $invocant.method>, similar to L<C<=>>.

Technically this is not an operator, but syntax special-cased in the compiler.

X«|postfix .^»
=head2 postfix C«.^»

A X<meta-method call>. C<$invocant.^method> calls C<method> on C<$invocant>'s
metaclass. It desugars to C<$invocant.HOW.method($invocant, ...)>. See
L<HOW|/language/mop#index-entry-syntax_HOW-HOW> for more information.

Technically this is not an operator, but syntax special-cased in the compiler.

X«|postfix .?»
=head2 postfix C«.?»

X<Safe call operator>. C<$invocant.?method> calls method C<method> on
C<$invocant> if it has a method of such name. Otherwise it returns L<Nil>.

Technically this is not an operator, but syntax special-cased in the compiler.

X«|postfix .+»
=head2 postfix C«.+»

C<$invocant.+method> calls all methods called C<method> from C<$invocant>,
and returns a L<List> of the results. Dies if no such method was found.

Technically this is not an operator, but syntax special-cased in the compiler.

X«|postfix .*»
=head2 postfix C«.*»

C<$invocant.*method> calls all methods called C<method> from C<$invocant>,
and returns a L<List> of the results. If no such method was found, an empty
L<List> is returned.

Technically this is not an operator, but syntax special-cased in the compiler.

X<|postfix ».>
=head2 postfix C<».> / postfix C«>>.»

X<Hyper method call operator>. Will call a method on all elements of a C<List> out of order and return the list of return values in order.

    my @a = <a b c>;
    my @b = @a».ord;                  # [97, 98, 99]
    sub foo(Str:D $c){ $c.ord * 2 };  # The first parameter of a method is the invocant.
    say @a».&foo;                     # So we can pretend to have a method call with a sub that got a good first positional argument.
    say @a».&{ .ord};                 # Blocks have an implicit positional arguments that lands in $_. The latter can be omitted for method calls.

Take care to avoid a common mistake of expecting side-effects to occur in order. The following
C<say> is B<not> guaranteed to produce the output in order:

    @a».say;  # Could produce a␤b␤c␤ or c␤b␤a␤ or any other order

=head2 postfix C<.postfix> / C<.postcircumfix>
X<|.( )>X<|.[ ]>X<|.{ }>

In most cases, a dot may be placed before a postfix or postcircumfix:

    my @a;
    @a[1, 2, 3];
    @a.[1, 2, 3]; # Same

This can be useful for visual clarity or brevity. For example, if an object's
attribute is a function, putting a pair of parentheses after the attribute name
will become part of the method call. So either two pairs of parentheses must be
used, or a dot has to come before the parentheses to separate it from the method
call.

    class Operation {
        has $.symbol;
        has &.function;
    }
    my $addition = Operation.new(:symbol<+>, :function{ $^a + $^b });
    say $addition.function()(1, 2); # 3
    # OR
    say $addition.function.(1, 2); # 3

If the postfix is an identifier, however, it will be interpreted as a normal
method call.

=begin code :skip-test
1.i # No such method 'i' for invocant of type 'Int'
=end code

Technically this is not an operator, but syntax special-cased in the compiler.
X<|postfix call>

=head2 postfix C«.:<prefix>»

A prefix can be called like a method using colonpair notation. For example:

    my $a = 1;
    say ++$a;     # 2
    say $a.:<++>; # 3

Technically this is not an operator, but syntax special-cased in the compiler.
X<|prefix call>

=head2 postfix C«.::»

A X<class-qualified method call>, used to call a method as defined in a parent
class or role, even after it has been redefined in the child class.

    class Bar {
        method baz { 42 }
    }
    class Foo is Bar {
        method baz { "nope" }
    }
    say Foo.Bar::baz; # 42

=head1 Autoincrement Precedence

=head2 prefix X<C«++»|++>

=begin code :skip-test
multi sub prefix:<++>($x is rw) is assoc<non>
=end code

Increments its argument by one, and returns the updated value.X<|increment operator>

    my $x = 3;
    say ++$x;       # 4
    say $x;         # 4

It works by calling the L<succ> method (for I<successor>) on its argument,
which gives custom types the freedom to implement their own increment
semantics.

=head2 prefix X<C«--»|-->

=begin code :skip-test
multi sub prefix:<-->($x is rw) is assoc<non>
=end code

Decrements its argument by one, and returns the updated value.X<|decrement operator>

    my $x = 3;
    say --$x;       # 2
    say $x;         # 2

It works by calling the L<pred> method (for I<predecessor>) on its argument,
which gives custom types the freedom to implement their own decrement
semantics.


=head2 postfix X<C«++»|++>

=begin code :skip-test
multi sub postfix:<++>($x is rw) is assoc<non>
=end code

Increments its argument by one, and returns the original value.X<|increment operator>

    my $x = 3;
    say $x++;       # 3
    say $x;         # 4

It works by calling the L<succ> method (for I<successor>) on its argument,
which gives custom types the freedom to implement their own increment
semantics.

Note that this does not necessarily return its argument. For example for
undefined values, it returns 0:

    my $x;
    say $x++;       # 0
    say $x;         # 1

Increment on L<Str|/type/Str> will increment the number part of a string and
assign the resulting string to the container. A C<is rw>-container is required.

    my $filename = "somefile-001.txt";
    say $filename++ for 1..3;
    # OUTPUT«somefile-001.txt␤somefile-002.txt␤somefile-003.txt␤»

=head2 postfix C«--»

=begin code :skip-test
multi sub postfix:<-->($x is rw) is assoc<non>
=end code

Decrements its argument by one, and returns the original value.X<|decrement operator>

    my $x = 3;
    say $x--;       # 3
    say $x;         # 2

It works by calling the L<pred> method (for I<predecessor>) on its argument,
which gives custom types the freedom to implement their own decrement
semantics.

Note that this does not necessarily return its argument. For example for
undefined values, it returns 0:

    my $x;
    say $x--;       # 0
    say $x;         # -1

Decrement on L<Str|/type/Str> will decrement the number part of a string and
assign the resulting string to the container. A C<is rw>-container is required.
Crossing 0 is prohibited and throws C<X::AdHoc>.

    my $filename = "somefile-003.txt";
    say $filename-- for 1..3;
    # OUTPUT«somefile-003.txt␤somefile-002.txt␤somefile-001.txt␤»

=head1 Exponentiation Precedence

=head2 infix C«**»

=begin code :skip-test
multi sub infix:<**>(Any, Any) returns Numeric:D is assoc<right>
=end code

The X<exponentiation operator> coerces both arguments to L<Numeric>
and calculates the left-hand-side raised to the power of the right-hand side.

If the right-hand side is a non-negative integer and the left-hand side
is an arbitrary precision type (L<Int>, L<FatRat>), then the calculation
is carried out without loss of precision.

=head1 Symbolic Unary Precedence

=head2 prefix C«?»

=begin code :skip-test
multi sub prefix:<?>(Mu) returns Bool:D
=end code

X<Boolean context operator>.

Coerces the argument to L<Bool> by calling the C<Bool> method on it.
Note that this collapses L<Junction>s.

=head2 prefix C«!»

=begin code :skip-test
multi sub prefix:<!>(Mu) returns Bool:D
=end code

X<Negated boolean context operator>.

Coerces the argument to L<Bool> by calling the C<Bool> method on it,
and returns the negation of the result.
Note that this collapses L<Junction>s.

=head2 prefix C«+»

=begin code :skip-test
multi sub prefix:<+>(Any) returns Numeric:D
=end code

X<Numeric context operator>.

Coerces the argument to L<Numeric> by calling the C<Numeric> method on it.

=head2 prefix C«-»

=begin code :skip-test
multi sub prefix:<->(Any) returns Numeric:D
=end code

X<Negative numeric context operator>.

Coerces the argument to L<Numeric> by calling the C<Numeric> method on it,
and then negates the result.

=head2 prefix C«~»

=begin code :skip-test
multi sub prefix:<~>(Any) returns Str:D
=end code

X<String context operator>.

Coerces the argument to L<Str> by calling the C<Str> method on it.

=head2 prefix C«|»

Flattens objects of type L<Capture>, L<Pair>, L<List> L<Map> and L<Hash>
into an argument list.

Outside of argument lists, it returns a L<Slip|/type/Slip>, which makes it
flatten into the outer list. Inside L<argument list|/language/list#Argument_List_(Capture)_Context> L<C<Positional>s|/type/Positional> are turned
into positional arguments and L<C<Associative>s|/type/Associative> are turned into named arguments.

=head2 prefix C«||»

TODO

=head2 prefix C«+^»

=begin code :skip-test
multi sub prefix:<+^>(Any) returns Int:D
=end code

X<Integer bitwise negation operator>.

Coerces the argument to L<Int> and does a bitwise negation on the result,
assuming L<two's complement|https://en.wikipedia.org/wiki/Two%27s_complement>.

=head2 prefix C«~^»

Coerces the argument to a non-variable-encoding string buffer type (e.g. C<buf8>, C<buf16>, C<buf32>)
and then flips each bit in that buffer.

Please note that this has not yet been implemented.

=head2 prefix C«?^»

=begin code :skip-test
multi sub prefix:<?^>(Mu) returns Bool:D
=end code

X<Boolean bitwise negation operator>.

Coerces the argument to L<Bool> and then does a bit flip, which makes it the
same as C<< prefix:<!> >>.

=head2 prefix C«^»

=begin code :skip-test
multi sub prefix:<^>(Any) returns Range:D
=end code

I<upto> operator.X<|upto operator>

Coerces the argument to L<Numeric>, and generates a range from 0 up to (but
excluding) the argument.

    say ^5;         # 0..^5
    for ^5 { }      # 5 iterations

=head1 Multiplicative Precedence

=head2 infix C«*»

=begin code :skip-test
multi sub infix:<*>(Any, Any) returns Numeric:D
=end code

X<Multiplication operator>.

Coerces both arguments to L<Numeric> and multiplies them. The result
is of the wider type. See L<Numeric> for details.

=head2 infix C«/»

=begin code :skip-test
multi sub infix:</>(Any, Any) returns Numeric:D
=end code

X<Division operator>.

Coerces both argument to L<Numeric> and divides the left through the right
number. Division of L<Int> values returns L<Rat>, otherwise the "wider type"
rule described in L<Numeric> holds.

=head2 infix C«div»

=begin code :skip-test
multi sub infix:<div>(Int:D, Int:D) returns Int:D
=end code

X<Integer division operator>. Rounds down.

=head2 infix C«%»

=begin code :skip-test
multi sub infix:<%>($x, $y) return Numeric:D
=end code

X<Modulo operator>. Coerces to L<Numeric> first.

Generally the following identity holds:

    my ($x, $y) = 1,2;
    $x % $y == $x - floor($x / $y) * $y

=head2 infix C«%%»

=begin code :skip-test
multi sub infix:<%%>($a, $b) returns Bool:D
=end code

X<Divisibility operator>. Returns C<True> if C<$a %  $b == 0>.

=head2 infix C«mod»

=begin code :skip-test
multi sub infix:<mod>(Int:D $a, Int:D $b) returns Int:D
=end code

X<Integer modulo operator>. Returns the remainder of an integer modulo operation.

=head2 infix C«+&»

=begin code :skip-test
multi sub infix:<+&>($a, $b) returns Int:D
=end code

Numeric bitwise I<AND> operator. Coerces both arguments to L<Int> and does a bitwise
I<AND> operation assuming two's complement.X<|Numeric bitwise AND operator>

=head2 infix C«+<»

=begin code :skip-test
multi sub infix:<< +< >>($a, $b) returns Int:D
=end code

Integer bit shift to the left.X<|integer bit shift operator,left>

=head2 infix C«+>»

=begin code :skip-test
multi sub infix:<< +> >>($a, $b) returns Int:D
=end code

Integer bit shift to the right.X<|integer bit shift operator,right>

=head2 infix C«~&»

Coerces each argument to a non-variable-encoding string buffer type (e.g. C<buf8>, C<buf16>, C<buf32>)
and then performs a numeric bitwise AND on corresponding integers of the two buffers, padding the
shorter buffer with zeroes.

=head2 infix C«~<»

Coerces the left argument to a non-variable-encoding string buffer type (e.g. C<buf8>, C<buf16>, C<buf32>)
and then performs a numeric bitwise left shift on the bits of the buffer.

Please note that this has not yet been implemented.

=head2 infix C«~>»

Coerces the left argument to a non-variable-encoding string buffer type (e.g. C<buf8>, C<buf16>, C<buf32>)
and then performs a numeric bitwise right shift on the bits of the buffer.

Please note that this has not yet been implemented.

=head2 infix C«gcd»

=begin code :skip-test
multi sub infix:<gcd>($a, $b) returns Int:D
=end code

Coerces both arguments to L<Int> and returns the greatest common divisor.X<|greatest common divisor operator>

=head2 infix C«lcm»

=begin code :skip-test
multi sub infix:<lcm>($a, $b) returns Int:D
=end code

Coerces both arguments to L<Int> and returns the least common multiple, that is
the smallest integer that is evenly divisible by both arguments.X<|least common multiple operator>

=head1 Additive Precedence

=head2 infix C«+»

=begin code :skip-test
multi sub infix:<+>($a, $b) returns Numeric:D
=end code

X<Addition operator>.

Coerces both arguments to L<Numeric> and adds them.

=head2 infix C«-»

=begin code :skip-test
multi sub infix:<->($a, $b) returns Numeric:D
=end code

X<Subtraction operator>.

Coerces both arguments to L<Numeric> and subtracts the second from the
first.

=head2 infix C«+|»

=begin code :skip-test
multi sub infix:<+|>($a, $b) returns Int:D
=end code

X<Integer bitwise OR operator>.

Coerces both arguments to L<Int> and does a bitwise I<OR> (inclusive OR)
operation.

=head2 infix C«+^»

=begin code :skip-test
multi sub infix:<+^>($a, $b) returns Int:D
=end code

X<Integer bitwise XOR operator>.

Coerces both arguments to L<Int> and does a bitwise I<XOR> (exclusive OR)
operation.

=head2 infix C«~|»

Coerces each argument to a non-variable-encoding string buffer type (e.g. C<buf8>, C<buf16>, C<buf32>)
and then performs a numeric bitwise OR on corresponding integers of the two buffers, padding the
shorter buffer with zeroes.

=head2 infix C«~^»

Coerces each argument to a non-variable-encoding string buffer type (e.g. C<buf8>, C<buf16>, C<buf32>)
and then performs a numeric bitwise XOR on corresponding integers of the two buffers, padding the
shorter buffer with zeroes.

=head2 infix C«?|»

=begin code :skip-test
multi sub infix:<?|>($a, $b) returns Bool:D
=end code

X<Boolean logical OR operator>.

Coerces both arguments to L<Bool> and does a logical I<OR> (inclusive OR)
operation.

=head1 Replication Precedence

=head2 infix C«x»

=begin code :skip-test
sub infix:<x>($a, $b) returns Str:D
=end code

X<String repetition operator>.

Repeats the string C<$a> C<$b> times, if necessary coercing C<$a> to L«C<Str>|/type/Str»
and C<$b> L«C<Int>|/type/Int». Returns an empty string if C<< $b <= 0 >>.

    say 'ab' x 3;           # ababab
    say 42 x 3;             # 424242

    my $a = 'a'.IO; my $b = 3.5;
    say $a x $b;            # aaa

=head2 infix C«xx»

=begin code :skip-test
multi sub infix:<xx>($a, $b) returns List:D
=end code

X<List repetition operator>.

Returns a list of C<$a> repeated and evaluated C<$b> times (C<$b> is coerced
to L<Int>). If C<< $b <= 0 >>, the empty list is returned.

The left-hand side is evaluated for each repetition, so

    say [1, 2] xx 5;
    # OUTPUT«([1 2] [1 2] [1 2] [1 2] [1 2])␤»

returns five distinct arrays (but with the same content each time), and

    rand xx 3

returns three pseudo random numbers that are determined independently.

The right-hand side can be C<*>, in which case a lazy, infinite list
is returned.

=head1 Concatenation

=head2 infix C«~»

=begin code :skip-test
proto sub infix:<~>(Any, Any) returns Str:D
multi sub infix:<~>(Any,   Any)
multi sub infix:<~>(Str:D, Str:D)
=end code

X<String concatenation operator>.

Coerces both arguments to L<Str> and concatenates them.

    say 'ab' ~ 'c';     # abc

=head1 Junctive AND (all) Precedence

=head2 infix C«&»

=begin code :skip-test
multi sub infix:<&>($a, $b) returns Junction:D is assoc<list>
=end code

X<All junction operator>.

Creates an I<all> L<Junction> from its arguments. See L<Junction> for more
details.

=head1 Junctive OR (any) Precedence

=head2 infix C«|»

=begin code :skip-test
multi sub infix:<|>($a, $b) returns Junction:D is assoc<list>
=end code

X<Any junction operator>.

Creates an I<any> L<Junction> from its arguments. See L<Junction> for more
details.

=head2 infix C«^»

=begin code :skip-test
multi sub infix:<^>($a, $b) returns Junction:D is assoc<list>
=end code

X<One junction operator>.

Creates a I<one> L<Junction> from its arguments. See L<Junction> for more
details.

=head1 Named Unary Precedence

=head2 prefix C«temp»

=begin code :skip-test
sub prefix:<temp>(Mu $a is rw)
=end code

"temporizes" the variable passed as the argument. The variable begins
with the same value as it had in the outer scope, but can be assigned
new values in this scope. Upon exiting the scope, the variable will be
restored to its original value.

    my $a = "three";
    say $a; # three
    {
        temp $a;
        say $a; # three
        $a = "four";
        say $a; # four
    }
    say $a; # three

Note that you can also assign immediately as part of the call to temp:

    temp $a = "five";

=head2 prefix C«let»

=begin code :skip-test
sub prefix:<let>(Mu $a is rw)
=end code

Restores the previous value if the block exits unsuccessfully. A
successful exit means the block returned a defined value or a list.

    my $answer = 42;

    {
        let $answer = 84;
        die if not Bool.pick;
        CATCH {
            default { say "it's been reset :(" }
        }
        say "we made it 84 sticks!";
    }

    say $answer;

In the above case, if the C<Bool.pick> returns true, the answer will
stay as 84 because the block returns a defined value (C<say> returns
true). Otherwise the C<die> statement will cause the block to exit
unsuccessfully, resetting the answer to 42.

=comment this is duplicated in variables.pod

=head1 Nonchaining Binary Precedence

=head2 infix C«does»

=begin code :skip-test
sub infix:<does>(Mu $obj, Mu $role) is assoc<non>
=end code

Mixes C<$role> into C<$obj> at run time. Requires C<$obj> to be mutable.

C<$role> doesn't need to a be a role, it can be something that knows how
to act like a role, for example enum values.

If methods of the same name are present already, the last mixed in role takes
precedence.

=head2 infix C«but»

=begin code :skip-test
sub infix:<but>(Mu $obj, Mu  $role) is assoc<non>
sub infix:<but>(Mu $obj, Mu:D $obj) is assoc<non>
=end code

Creates a copy of C<$obj> with C<$role> mixed in. Since C<$obj> is not
modified, C<but> can be used to created immutable values with mixins.

Instead of a role, you can provide an instantiated object. In this case,
the operator will create a role for you automatically. The role will contain
a single method named the same as C<$obj.^name> and that returns C<$obj>:

    say 42 but 'forty two'; # 'forty two'

    my $s = 12 but class Warbles { method hi { 'hello' } }.new;
    say $s.Warbles.hi; # hello
    say $s + 42;       # 54

If methods of the same name are present already, the last mixed in role takes
precedence. A list of methods can be provided in parentheses separated by
comma. In this case conflicts will be reported at runtime.

=head2 infix C«cmp»

=begin code :skip-test
proto sub infix:<cmp>(Any, Any) returns Order:D is assoc<non>
multi sub infix:<cmp>(Any,       Any)
multi sub infix:<cmp>(Real:D,    Real:D)
multi sub infix:<cmp>(Str:D,     Str:D)
multi sub infix:<cmp>(Version:D, Version:D)
=end code

X<Generic, "smart" three-way comparator>.

Compares strings with string semantics, numbers
with number semantics, L<Pair> objects first by key and then by value etc.

if C<$a eqv $b>, then C<$a cmp $b> always returns C<Order::Same>.

    say (a => 3) cmp (a => 4);      # Less
    say 4        cmp 4.0;           # Same
    say 'b'      cmp 'a';           # More

=head2 infix C«leg»

=begin code :skip-test
proto sub infix:<leg>($a, $b) returns Order:D is assoc<non>
multi sub infix:<leg>(Any,   Any)
multi sub infix:<leg>(Str:D, Str:D)
=end code

X<String three-way comparator>. Short for I<less, equal or greater?>.

Coerces both arguments to L<Str>, and then does a lexicographic comparison.

=begin code :skip-test
say 'a' leg 'b';        Less
say 'a' leg 'a';        Same
say 'b' leg 'a';        More
=end code

=head2 infix C«<=>»

=begin code :skip-test
multi sub infix:«<=>»($a, $b) returns Order:D is assoc<non>
=end code

X<Numeric three-way comparator>.X<|spaceship operator>

Coerces both arguments to L<Real>, and then does a numeric comparison.

=head2 infix C«..»

=begin code :skip-test
multi sub infix:<..>($a, $b) returns Range:D is assoc<non>
=end code

X<Range operator>

Constructs a L<Range> from the arguments.

=head2 infix C«..^»

=begin code :skip-test
multi sub infix:<..^>($a, $b) returns Range:D is assoc<non>
=end code

X<Right-open range operator>.

Constructs a L<Range> from the arguments, excluding the end point.

=head2 infix C«^..»

=begin code :skip-test
multi sub infix:<^..>($a, $b) returns Range:D is assoc<non>
=end code

X<Left-open range operator>.

Constructs a L<Range> from the arguments, excluding the start point.

=head2 infix C«^..^»

=begin code :skip-test
multi sub infix:<^..^>($a, $b) returns Range:D is assoc<non>
=end code

X<Open range operator>

Constructs a L<Range> from the arguments, excluding both start and end point.

=head1 Chaining Binary Precedence

=head2 infix C«==»

=begin code :skip-test
proto sub infix:<==>($, $) returns Bool:D is assoc:<chain>
multi sub infix:<==>(Any, Any)
multi sub infix:<==>(Int:D, Int:D)
multi sub infix:<==>(Num:D, Num:D)
multi sub infix:<==>(Rational:D, Rational:D)
multi sub infix:<==>(Real:D, Real:D)
multi sub infix:<==>(Complex:D, Complex:D)
multi sub infix:<==>(Numeric:D, Numeric:D)
=end code

X<Numeric equality operator>.

Coerces both arguments to L<Numeric> if necessary, and returns C<True>
if they are equal.

=head2 infix C«!=»

=begin code :skip-test
proto sub infix:<!=>(Mu, Mu) returns Bool:D is assoc<chain>
=end code

X<Numeric inequality operator>.

Coerces both arguments to L<Numeric> (if necessary), and returns C<True> if they are
distinct.

=head2 infix C«<»

=begin code :skip-test
proto sub infix:«<»(Any, Any) returns Bool:D is assoc<chain>
multi sub infix:«<»(Int:D, Int:D)
multi sub infix:«<»(Num:D, Num:D)
multi sub infix:«<»(Real:D, Real:D)
=end code

X<Numeric less than operator>.

Coerces both arguments to L<Real> (if necessary), and returns C<True> if the first argument
is smaller than the second.

=head2 infix C«<=»

=begin code :skip-test
proto sub infix:«<=»(Any, Any) returns Bool:D is assoc<chain>
multi sub infix:«<=»(Int:D, Int:D)
multi sub infix:«<=»(Num:D, Num:D)
multi sub infix:«<=»(Real:D, Real:D)
=end code


X<Numeric less than or equal to operator>.

Coerces both arguments to L<Real> (if necessary), and returns C<True> if the first argument
is smaller than or equal to the second.


=head2 infix C«>»

=begin code :skip-test
proto sub infix:«>»(Any, Any) returns Bool:D is assoc<chain>
multi sub infix:«>»(Int:D, Int:D)
multi sub infix:«>»(Num:D, Num:D)
multi sub infix:«>»(Real:D, Real:D)
=end code

X<Numeric greater than operator>.

Coerces both arguments to L<Real> (if necessary), and returns C<True> if the first argument
is larger than the second.

=head2 infix C«>=»

=begin code :skip-test
proto sub infix:«>=»(Any, Any) returns Bool:D is assoc<chain>
multi sub infix:«>=»(Int:D, Int:D)
multi sub infix:«>=»(Num:D, Num:D)
multi sub infix:«>=»(Real:D, Real:D)
=end code

X<Numeric greater than or equal to operator>.

Coerces both arguments to L<Real> (if necessary), and returns C<True> if
the first argument is larger than or equal to the second.

=head2 infix C«eq»

=begin code :skip-test
proto sub infix:<eq>(Any, Any) returns Bool:D is assoc<chain>
multi sub infix:<eq>(Any,   Any)
multi sub infix:<eq>(Str:D, Str:D)
=end code

X<String equality operator>.

Coerces both arguments to L<Str> (if necessary), and returns C<True> if both
are equal.

Mnemonic: I<equal>

=head2 infix C«ne»

=begin code :skip-test
proto sub infix:<ne>(Mu, Mu) returns Bool:D is assoc<chain>
multi sub infix:<ne>(Mu,    Mu)
multi sub infix:<ne>(Str:D, Str:D)
=end code

X<String inequality operator>.

Coerces both arguments to L<Str> (if necessary), and returns C<False> if both
are equal.

Mnemonic: I<not equal>

=head2 infix C«gt»

=begin code :skip-test
proto sub infix:<gt>(Mu, Mu) returns Bool:D is assoc<chain>
multi sub infix:<gt>(Mu,    Mu)
multi sub infix:<gt>(Str:D, Str:D)
=end code

X<String greater than operator>.

Coerces both arguments to L<Str> (if necessary), and returns C<True> if
the first is larger than the second, as determined by lexicographic
comparison.

Mnemonic: I<greater than>

=head2 infix C«ge»

=begin code :skip-test
proto sub infix:<ge>(Mu, Mu) returns Bool:D is assoc<chain>
multi sub infix:<ge>(Mu,    Mu)
multi sub infix:<ge>(Str:D, Str:D)
=end code

X<String greater than or equal to operator>.

Coerces both arguments to L<Str> (if necessary), and returns C<True> if
the first is equal to or larger than the second, as determined by lexicographic
comparison.

Mnemonic: I<greater or equal>

=head2 infix C«lt»

=begin code :skip-test
proto sub infix:<lt>(Mu, Mu) returns Bool:D is assoc<chain>
multi sub infix:<lt>(Mu,    Mu)
multi sub infix:<lt>(Str:D, Str:D)
=end code

X<String less than operator>.

Coerces both arguments to L<Str> (if necessary), and returns C<True> if
the first is smaller than the second, as determined by lexicographic
comparison.

Mnemonic: I<less than>

=head2 infix C«le»

=begin code :skip-test
proto sub infix:<le>(Mu, Mu) returns Bool:D is assoc<chain>
multi sub infix:<le>(Mu,    Mu)
multi sub infix:<le>(Str:D, Str:D)
=end code

X<String less than or equal to operator>.

Coerces both arguments to L<Str> (if necessary), and returns C<True> if
the first is equal to or smaller than the second, as determined by lexicographic
comparison.

Mnemonic: I<less or equal>

=head2 infix C«before»

=begin code :skip-test
proto sub infix:<before>(Any, Any) returns Bool:D is assoc<chain>
multi sub infix:<before>(Any,       Any)
multi sub infix:<before>(Real:D,    Real:D)
multi sub infix:<before>(Str:D,     Str:D)
multi sub infix:<before>(Version:D, Version:D)
=end code

Generic ordering, uses the same semantics as L<cmp|#infix cmp>.
Returns C<True> if the first argument is smaller than the second.

=head2 infix C«after»

=begin code :skip-test
proto sub infix:<after>(Any, Any) returns Bool:D is assoc<chain>
multi sub infix:<after>(Any,       Any)
multi sub infix:<after>(Real:D,    Real:D)
multi sub infix:<after>(Str:D,     Str:D)
multi sub infix:<after>(Version:D, Version:D)
=end code

Generic ordering, uses the same semantics as L<cmp|#infix cmp>.
Returns C<True> if the first argument is larger than the second.

=head2 infix C«eqv»

=begin code :skip-test
proto sub infix:<eqv>(Any, Any) returns Bool:D is assoc<chain>
proto sub infix:<eqv>(Any, Any)
=end code

X<Equivalence operator>. Returns C<True> if the two arguments are structurally
the same, i.e. from the same type and (recursively) contain the same values.

    say [1, 2, 3] eqv [1, 2, 3];        # True
    say Any eqv Any;                    # True
    say 1 eqv 2;                        # False
    say 1 eqv 1.0;                      # False

The default C<eqv> operator even works with arbitrary objects. E.g., C<eqv>
will consider two instances of the same object as being structurally
equivalent:

    my class A {
        has $.a;
    }
    say A.new(a => 5) eqv A.new(a => 5);  #=> True

Although the above example works as intended the C<eqv> code has to fall back
to a slower code path in in order to do its job. One way to avoid this is to
implement an appropriate infix C<eqv> operator:

    my class A {
        has $.a;
    }
    multi infix:<eqv>(A $l, A $r) { $l.a eqv $r.a }
    say A.new(a => 5) eqv A.new(a => 5);  #=> True

=head2 infix C«===»

=begin code :skip-test
proto sub infix:<===>(Any, Any) returns Bool:D is assoc<chain>
proto sub infix:<===>(Any, Any)
=end code

X<Value identity operator>. Returns C<True> if both arguments are the same object.

    my class A { };
    my $a = A.new;
    say $a === $a;              # True
    say A.new === A.new;        # False
    say A === A;                # True

For value types, C<===> behaves like C<eqv>:

    say 'a' === 'a';            # True
    say 'a' === 'b';            # False

    # different types
    say 1 === 1.0;              # False

C<===> uses the L<WHICH|/routine/WHICH> method to obtain the object identity, so all value
types must override method C<WHICH>.

=head2 infix C«=:=»

=begin code :skip-test
proto sub infix:<=:=>(Mu \a, Mu \b) returns Bool:D is assoc<chain>
multi sub infix:<=:=>(Mu \a, Mu \b)
=end code

X<Container identity operator>. Returns C<True> if both arguments are bound to the same
container. If it returns C<True>, it generally means that modifying one will
also modify the other.

    my ($a, $b) = (1, 3);
    say $a =:= $b;      # False
    $b = 2;
    say $a;             # 1
    $b := $a;
    say $a =:= $b;      # True
    $a = 5;
    say $b;             # 5

=head2 infix C«~~»

The X<smart-match operator>. Aliases the left-hand side to C<$_>, then evaluates
the right-hand side, and calls C<.ACCEPTS($_)> on it. The semantics are left
to the type of the right-hand side operand.

Here is an excerpt of built-in smart-matching functionality:

=begin table

    Right-hand side     Comparison semantics
    ===============     ====================
    Mu:U                type check
    Str                 string equality
    Numeric             numeric equality
    Regex               regex match
    Callable            boolean result of invocation
    Any:D               object identity

=end table

=head2 infix C<=~=>

=begin code :skip-test
proto sub infix:<=~=>($, $) returns Bool:D is assoc:<chain>
multi sub infix:<=~=>(Any, Any)
multi sub infix:<=~=>(Int:D, Int:D)
multi sub infix:<=~=>(Num:D, Num:D)
multi sub infix:<=~=>(Rational:D, Rational:D)
multi sub infix:<=~=>(Real:D, Real:D)
multi sub infix:<=~=>(Complex:D, Complex:D)
multi sub infix:<=~=>(Numeric:D, Numeric:D)
=end code

The X<approximately-equal operator|infix, ≅>. Calculates the relative difference between
the left-hand and right-hand sides and returns C<True> if the difference is
less than $*TOLERANCE (which defaults to 1e-15). However, if either side is zero
then it checks that the absolute difference between the sides is less than $*TOLERANCE.
Note that this operator is not arithmetically symmetrical (doesn't do ± Δ):

    my $x = 1;
    say ($x + $*TOLERANCE) =~= $x;   # False
    say ($x - $*TOLERANCE) =~= $x;   # True

The tolerance is supposed to be modifiable via an adverb:

=comment RT #128210
=begin code :skip-test
my ($x, $y) = 42, 42.1;
say $x =~= $y :tolerance(.1);
=end code

however, this is not yet implemented. The same effect can be achieved by
assigning to $*TOLERANCE.

    {
        my $*TOLERANCE = .1;
        say 11 =~= 10;               # True
    }

Note that setting $*TOLERANCE = 0 will cause all comparisons to fail.

    {
        my $*TOLERANCE = 0;
        say 1 =~= 1;                 # False
    }

=head1 Tight AND Precedence

=head2 infix C«&&»

Returns the first argument that evaluates to C<False> in boolean context,
or otherwise the last argument.

Note that this short-circuits, i.e. if one of the arguments evaluates to a
false value, the arguments to the right of are never evaluated.

    sub a { 1 }
    sub b { 0 }
    sub c { die "never called" };
    say a() && b() && c();      # 0

=head1 Tight OR Precedence

=head2 infix C«||»

Returns the first argument that evaluates to C<True> in boolean context,
or otherwise the last argument.

Note that this short-circuits, i.e. if one of the arguments evaluates to a
true value, the arguments to the right of are never evaluated.

    sub a { 0 }
    sub b { 1 }
    sub c { die "never called" };
    say a() || b() || c();      # 1

=head2 infix C«^^»

X<Short-circuit exclusive-or>. Returns the true argument if there
is one (and only one).  Returns the last argument if all arguments are false.
Returns C<Nil> otherwise (when more than one argument is true).

This operator short-circuits in the sense that it does not evaluate
any arguments after a 2nd true result.

    say 0 ^^ 42;                # 42
    say '' ^^ 0;                # 0
    say 0 ^^ 42 ^^ 1 ^^ die "never called";  # (empty line)

Note that the semantics of this operator may not be what you assume: infix C«^^»
flips to first true value it finds, and then flips to Nil I<forever> after the
second, no matter how many more true values there are. (In other words, it has
"find the one true value" semantics, not "boolean parity" semantics.)

=head2 infix C«//»

X<Defined-or operator>. Returns the first defined operand, or else the last
operand. Short-circuits.

    say Any // 0 // 42;         # 0

=head2 infix C«min»

Returns the smallest of the arguments, as determined by L<cmp> semantics.

    my $foo = 42;
    $foo min= 0  # read as: $foo decreases to 0

=head2 infix C«max»

Returns the largest of the arguments, as determined by L<cmp> semantics.

    my $foo = -42;
    $foo max= 0  # read as: $foo increases to 0

=head1 Conditional Operator Precedence

=head2 infix C<?? !!>

X<Ternary operator>, X<conditional operator>.

C<$condition ?? $true !! $false> evaluates and returns the expression from the
C<$true> branch if C<$condition> is a true value. Otherwise it evaluates and
returns the C<$false> branch.

=head2 infix C«ff»

=begin code :skip-test
sub infix:<ff>(Mu $a, Mu $b)
=end code

X<Flipflop operator>.

Compares both arguments to C<$_> (that is, C<$_ ~~ $a> and C<$_ ~~
$b>). Evaluates to C<False> until the left-hand smartmatch is C<True>, at which
point it evaluates to C<True> until the right-hand smartmatch is C<True>.

In effect, the left-hand argument is the "start" condition, and the right-hand
is the "stop" condition. This construct is typically used to pick up only a
certain section of lines. For example:

=begin code :allow<B V>
my $excerpt = q:to/END/;
Here's some unimportant text.
V<=>begin code
    This code block is what we're after.
    We'll use 'ff' to get it.
V<=>end code
More unimportant text.
END

my @codelines = gather for $excerpt.lines {
    take $_ if B<"=begin code" ff "=end code">
}

# this will print four lines, starting with "=begin code" and ending with
# "=end code"
say @codelines.join("\n");
=end code

After matching the start condition, the operator will then match the same C<$_>
to the stop condition, and act accordingly if successful. In this example, only
the first element is printed:

    for <AB C D B E F> {
        say $_ if /A/ ff /B/;  # prints only "AB"
    }

If you only want to test against a start condition, and have no stop condition,
C<*> can be used as the "stop" condition.

    for <A B C D E> {
        say $_ if /C/ ff *; # prints C, D, and E
    }

For the sed-like version, which does I<not> try C<$_> on the stop condition
after succeeding on the start condition, see L<C<fff>>.

This operator cannot be overloaded, as it is handled specially by the compiler.

=head2 infix C«^ff»

=begin code :skip-test
sub infix:<^ff>(Mu $a, Mu $b)
=end code

Works like L<C<ff>>, except it does not return C<True> for items matching the
start condition (including items also matching the stop condition).

A comparison:

    my @list = <A B C>;
    say $_ if /A/ ff /C/ for @list;  # prints A, B, and C
    say $_ if /A/ ^ff /C/ for @list; # prints B and C

The sed-like version can be found in L<C<^fff>|/routine/^fff>.

This operator cannot be overloaded, as it is handled specially by the compiler.

=head2 infix C«ff^»

=begin code :skip-test
sub infix:<ff^>(Mu $a, Mu $b)
=end code

Works like L<C<ff>>, except it does not return C<True> for items matching the
stop condition (including items that first matched the start condition).

    my @list = <A B C>;
    say $_ if /A/ ff /C/ for @list;  # prints A, B, and C
    say $_ if /A/ ff^ /C/ for @list; # prints A and B

The sed-like version can be found in L<C<fff^>>.

This operator cannot be overloaded, as it is handled specially by the compiler.

=head2 infix C«^ff^»

=begin code :skip-test
sub infix:<^ff^>(Mu $a, Mu $b)
=end code

Works like L<C<ff>>, except it does not return C<True> for items matching either
the stop or start condition (or both).

    my @list = <A B C>;
    say $_ if /A/ ff /C/ for @list;  # prints A, B, and C
    say $_ if /A/ ^ff^ /C/ for @list; # prints B

The sed-like version can be found in L<C<^fff^>|/routine/^fff^>.

This operator cannot be overloaded, as it is handled specially by the compiler.

=head2 infix C«fff»

=begin code :skip-test
sub infix:<fff>(Mu $a, Mu $b)
=end code

Performs a sed-like flipflop operation, wherein it returns C<False> until the
left argument smartmatches against C<$_>, and after that returns C<True> until
the right argument smartmatches against C<$_>.

Works similarly to L<C<ff>>, except that it only tries one argument per
invocation. That is, if C<$_> smartmatches the left argument, C<fff> will B<not>
then try to match that same C<$_> against the right argument.

    for <AB C D B E F> {
        say $_ if /A/ fff /B/;  # Prints "AB", "C", "D", and "B"
    }

The non-sed-like flipflop (which after successfully matching the left argument
against C<$_> will try that same C<$_> against the right argument and act
accordingly), see L<C<ff>>.

This operator cannot be overloaded, as it is handled specially by the compiler.

=head2 infix C«^fff»

=begin code :skip-test
sub infix:<^fff>(Mu $a, Mu $b)
=end code

Like L<C<fff>>, except it does not return true for matches to the left argument.

    my @list = <A B C>;
    say $_ if /A/ fff /C/ for @list;  # prints A, B, and C
    say $_ if /A/ ^fff /C/ for @list; # prints B and C

For the non-sed version, see L<C<^ff>|/routine/^ff>.

This operator cannot be overloaded, as it is handled specially by the compiler.

=head2 infix C«fff^»

=begin code :skip-test
sub infix:<fff^>(Mu $a, Mu $b)
=end code

Like L<C<fff>>, except it does not return true for matches to the right argument.

    my @list = <A B C>;
    say $_ if /A/ fff /C/ for @list;  # prints A, B, and C
    say $_ if /A/ fff^ /C/ for @list; # prints A and B

For the non-sed version, see L<C<ff^>>.

This operator cannot be overloaded, as it is handled specially by the compiler.

=head2 infix C«^fff^»

=begin code :skip-test
sub infix:<^fff^>(Mu $a, Mu $b)
=end code

Like L<C<fff>>, except it does not return true for matches to either the left or
right argument.

    my @list = <A B C>;
    say $_ if /A/ fff /C/ for @list;  # prints A, B, and C
    say $_ if /A/ ^fff^ /C/ for @list; # prints B

For the non-sed version, see L<C<^ff^>|/routine/^ff^>.

This operator cannot be overloaded, as it is handled specially by the compiler.

=head1 Item Assignment Precedence

=head2 infix C«=»

=begin code :skip-test
sub infix:<=>(Mu $a is rw, Mu $b)
=end code

X<Item assignment operator>.

Places the value of the right-hand side into the container on the left-hand
side. Its exact semantics are left to the container type on the left-hand side.

(Note that item assignment and list assignment have different precedence
levels, and the syntax of the left-hand side decides whether an equal sign
C<=> is parsed as item assignment or list assignment operator).

=head2 infix C«=>»

=begin code :skip-test
sub infix:«=>»($key, Mu $value) returns Pair:D
=end code

L<Pair> constructor.X<|pair constructor>

Constructs a L<Pair> object with the left-hand side as the key and the
right-hand side as the value.

Note that the C<< => >> operator is syntactically special-cased, in that
it allows unquoted identifier on the left-hand side.

    my $p = a => 1;
    say $p.key;         # a
    say $p.value;       # 1

A L<Pair> within an argument list with an unquoted identifier on the left
is interpreted as a named argument.

See L<the Terms language documentation|/language/terms#Pair> for more ways to
create C<Pair> objects.

=head1 Loose Unary Precedence

=head2 prefix C«not»

=begin code :skip-test
multi sub prefix:<not>(Mu $x) returns Bool:D
=end code

Evaluates its argument in boolean context (and thus collapses L<Junction>s),
and negates the result. Please note that C<not> is easy to misuse, see
L<traps|/language/traps#Loose_boolean_operators>.


=head2 prefix C«so»

=begin code :skip-test
multi sub prefix:<so>(Mu $x) returns Bool:D
=end code

Evaluates its argument in boolean context (and thus collapses L<Junction>s),
and returns the result.

=head1 Comma Operator Precedence

=head2 infix C«,»

=begin code :skip-test
sub infix:<,>(*@a) is assoc<list> returns List:D
=end code

Constructs a L<List> from its arguments. Also used syntactically as the
separator of arguments in calls.

=head2 infix C«:»

Used as an argument separator just like infix C<,> and marks the argument to
its left as the invocant. That turns what would otherwise be a function call
into a method call.

=begin code :skip-test
substr('abc': 1);       # same as 'abc'.substr(1)
=end code

Infix C<:> is only allowed after the first argument of a non-method call. In
other positions it is a syntax error.

=head1 List Infix Precedence

=head2 infix C«Z»

=begin code :skip-test
sub infix:<Z>(**@lists) returns Seq:D is assoc<chain>
=end code

X<Zip operator>.

Interleaves the lists passed to C<Z> like a zipper, stopping as soon as the
first input list is exhausted. The returned C<Seq> contains a nested list with
values for all C<Z> operators in a chain.

    say (1, 2 Z <a b c> Z <+ ->).perl;  #=> ((1, "a", "+"), (2, "b", "-")).Seq
    for <a b c> Z <1 2 3> -> [$l, $r] {
        say "$l:$r"
    }
    OUTPUT«a:1␤b:2␤c:3␤»

The C<Z> operator also exists as a meta operator, in which case the inner
lists are replaced by the value from applying the operator to the
list:

    say 100, 200 Z+ 42, 23;             #=> (142 223)
    say 1..3 Z~ <a b c> Z~ 'x' xx 3;    #=> (1ax 2bx 3cx)

=head2 infix C«X»

=begin code :skip-test
sub infix:<X>(**@lists) returns List:D is assoc<chain>
=end code

Creates a cross product from all the lists, order so that the rightmost
elements vary most rapidly:X<|cross product operator>

    1..3 X <a b c> X 9
    # produces ((1 a 9) (1 b 9) (1 c 9)
    #           (2 a 9) (2 b 9) (2 c 9)
    #           (3 a 9) (3 b 9) (3 c 9))

The C<X> operator also exists as a meta operator, in which case the inner
lists are replaced by the value from applying the operator to the
list:

    1..3 X~ <a b c> X~ 9
    # produces (1a9 1b9 1c9 2a9 2b9 2c9 3a9 3b9 3c9)

=head2 infix C«...»
X<|...,operators>X<|…,operators>X<|lazy list,…>

=begin code :skip-test
multi sub infix:<...>(**@) is assoc<list>
multi sub infix:<...^>(**@) is assoc<list>
=end code

The X<sequence operator> is a generic operator to produce lazy lists.

It can have initial elements and a generator on left-hand side, and an
endpoint on the right-hand side.

The sequence operator invokes the generator with as many arguments as
necessary. The arguments are taken from the initial elements and the already
generated elements.

The default generator is C<*.>L<succ> or C<*.>L<pred>, depending on how
the end points compare:

    say 1 ... 4;        # 1 2 3 4
    say 4 ... 1;        # 4 3 2 1
    say 'a' ... 'e';    # a b c d e
    say 'e' ... 'a';    # e d c b a

An endpoint of C<*> (L<Whatever>) generates an infinite sequence,
with a default generator of *.succ

    say (1 ... *)[^5];  # 1 2 3 4 5


Custom generators are the last argument before the '...' operator.
This one takes two arguments, and generates the Fibonacci numbers

    say (1, 1, -> $a, $b { $a + $b } ... *)[^8];    # 1 1 2 3 5 8 13 21
    # same but shorter
    say (1, 1, *+* ... *)[^8];                      # 1 1 2 3 5 8 13 21

Of course the generator can also take only one argument.

    say 5, { $_ * 2 } ... 40;                       # 5 10 20 40

There must be at least as many initial elements as arguments to the generator.

Without a generator, and more than one initial element, and all initial
elements numeric, the sequence operator tries to deduce the generator. It
knows about arithmetic and geometric sequences.

    say 2, 4, 6 ... 12;     # 2 4 6 8 10 12
    say 1, 2, 4 ... 32;     # 1 2 4 8 16 32

If the endpoint is not C<*>, it is smart-matched against each generated
element, and the sequence is terminated when the smart-match succeeded.
For the C<...> operator, the final element is included, for the C<...^>
operator it is excluded.

This allows you to write

    say 1, 1, *+* ...^ *>= 100;

To generate all Fibonacci numbers up to but excluding 100.

The C<...> operators consider the initial values as "generated elements" as
well, so the are also checked against the endpoint:

    my $end = 4;
    say 1, 2, 4, 8, 16 ... $end;
    # outputs 1 2 4

=head1 List Prefix Precedence

=head2 infix C«=»

X<List assignment operator>. Its exact semantics are left to the container type on the
left-hand side. See L<Array> and L<Hash> for common cases.

The distinction between item assignment and list assignment is determined by
the parser depending on the syntax of the left-hand side.

=head2 infix C«:=»

X<Binding operator>. Whereas C<$x = $y> puts the value in C<$y> into C<$x>, C<$x :=
$y> makes C<$x> and C<$y> the same thing.

    my $a = 42;
    my $b = $a;
    $b++;
    say $a;

This will output 42, because C<$a> and C<$b> both contained the number
C<42>, but the L<containers|/language/containers#Binding> were
different.

    my $a = 42;
    my $b := $a;
    $b++;
    say $a;

This will output 43, since C<$b> and C<$a> both represented the same
object.

=head2 infix C«::=»

X<Read-only binding operator>. See L<C<infix :=>|:=>.

=head2 listop C«...»

X<|stub operator>
The I<yada, yada, yada> operator or I<stub> operator. If it is the only
statement in a routine or type, it marks that routine or type as a stub
(which is significant in the context of pre-declaring types and composing
roles).

If the C<...> statement is executed, it calls L<fail|/routine/fail>, with the default
message C<stub code executed>.

=head2 listop C«!!!»

X<Fatal stub operator>.

If it is the only
statement in a routine or type, it marks that routine or type as a stub
(which is significant in the context of pre-declaring types and composing
roles).

If the C<!!!> statement is executed, it calls L<die|/routine/die>, with the default
message C<stub code executed>.

=head2 listop C«???»

X<Admonitory stub operator>.

If it is the only
statement in a routine or type, it marks that routine or type as a stub
(which is significant in the context of pre-declaring types and composing
roles).

If the C<???> statement is executed, it calls L<warn|/routine/warn>, with the default
message C<stub code executed>.

=head2 Reduction operators

Any infix operator (except for non-associating operators) can be
surrounded by square brackets in term position to create a list operator
that reduces using that operation.

    say [+] 1, 2, 3;      # 1 + 2 + 3 = 6
    my @a = (5, 6);
    say [*] @a;           # 5 * 6 = 30

Reduction operators have the same associativity as the operators they are based on.

=begin code

say [-] 4, 3, 2;      # 4-3-2 = (4-3)-2 = -1
say [**] 4, 3, 2;     # 4**3**2 = 4**(3**2) = 262144

=end code

=head1 Loose AND precedence

=head2 infix C«and»

Same as L<#infix &&>, except with looser precedence.

Returns the first operand that evaluates to C<False> in boolean context, or
otherwise the last operand, it short-circuits. Please note that C<and> is easy
to misuse, see L<traps|/language/traps#Loose_boolean_operators>.

=head2 infix C«andthen»

Returns L«C<Empty>|/type/Slip#index-entry-Empty-Empty» upon encountering
the first undefined argument, otherwise the last argument.
Short-circuits.  The result of the left side is bound to $_ for the
right side, or passed as arguments if the right side is a
L«C<Callable>|/type/Callable».

=head1 Loose OR Precedence

=head2 infix C«or»

Same as C<infix ||>, except with looser precedence.

Returns the first argument that evaluates to C<True> in boolean context,
or otherwise the last argument, it short-circuits. Please note that C<or> is easy
to misuse, see L<traps|/language/traps#Loose_boolean_operators>.


=head2 infix C«orelse»

Similar to C<infix //>. Returns the first defined argument, or else the
last argument. Short-circuits. The result of the left side is bound to $_ for the
right side, or passed as arguments if the right side is a
L«C<Callable>|/type/Callable».

=head1 Sequencer Precedence

=head2 infix C«==>»

This X<feed> operator takes the result from the left and passes it to the
next (right) routine as the last parameter.

The precedence is very loose so you will need to use parentheses to
assign the result or you can even just use another feed operator! In the
case of routines/methods that take a single argument or where the first argument
is a block, it is often required that you call with parentheses (though this
is not required for the very last routine/method).

    # Traditional structure, read bottom-to-top
    my @result =
        sort               # (4) Sort, result is <Earth People>
        grep { /<[PE]>/ }, # (3) Look for P or E
        map { .tc },       # (2) Capitalize the words
        <people of earth>; # (1) Start with the input

    # Feed (left-to-right) with parentheses, read top-to-bottom
    my @result = (
        <people of earth>  # (1) Start with the input
        ==> map({ .tc })   # (2) Capitalize the words
        ==> grep /<[PE]>/  # (3) Look for P or E
        ==> sort           # (4) Sort, result is <Earth People>
    );

    # For illustration, method chaining equivalent, read top-to-bottom
    my @result =
        <people of earth>  # (1) Start with the input
        .map({ .tc })      # (2) Capitalize the words
        .grep(/<[PE]>/)    # (3) Look for P or E
        .sort;             # (4) Sort, result is <Earth People>

    # To assign without the need of parentheses use another feed operator
    my @result =
        <people of earth>
        ==> map({ .tc })
        ==> grep /<[PE]>/
        ==> sort()
        ==> @result;

    # It can be useful to capture a partial result, however, unlike
    # the leftward feed operator, it does require parentheses or a semicolon
    my @result =
        <people of earth>
        ==> map({ .tc })
        ==> my @caps; @caps # also could wrap in parentheses instead
        ==> grep /<[PE]>/
        ==> sort()
        ==> @result;

The feed operator lets you construct method-chaining-like patterns out of
routines and the results of methods on unrelated data.  In method-chaining,
you are restricted to the methods available on the data or the result of
previous method call.  With feed operators, that restriction is gone.
The resulting code could also be seen to be more readable than a series of
method calls broken over multiple lines.

Note: In the future, this operator will see some change as it gains the
ability to run list operations in parallel. It will enforce that the
B<left> operand is enclosable as a closure (that can be cloned and run in
a subthread).

=head2 infix C«<==»

This X<leftward feed> operator takes the result from the right and passes
it to the previous (left) routine as the last parameter. This
elucidates the right-to-left dataflow for a series of list manipulating
functions.

    # Traditional structure, read bottom-to-top
    my @result =
        sort                   # (4) Sort, result is <Earth People>
        grep { /<[PE]>/ },     # (3) Look for P or E
        map { .tc },           # (2) Capitalize the words
        <people of earth>;     # (1) Start with the input

    # Feed (right-to-left) with parentheses, read bottom-to-top
    my @result = (
        sort()                 # (4) Sort, result is <Earth People>
        <== grep({ /<[PE]>/ }) # (3) Look for P or E
        <== map({ .tc })       # (2) Capitalize the words
        <== <people of earth>  # (1) Start with the input
    );

    # To assign without parentheses, use another feed operator
    my @result
        <== sort()             # (4) Sort, result is <Earth People>
        <== grep({ /<[PE]>/ }) # (3) Look for P or E
        <== map({ .tc })       # (2) Capitalize the words
        <== <people of earth>; # (1) Start with the input

    # It can be useful to capture a partial result
    my @result
        <== sort()
        <== grep({ /<[PE]>/ })
        <== my @caps # unlike ==>, there is no need for additional statement
        <== map({ .tc })
        <== <people of earth>;

Unlike the rightward feed operator, the result is not closely mappable
to method-chaining.  However, compared to the traditional structure above
where each argument is separated by a line, the resulting code is more
demonstrative than commas.  The leftward feed operator also allows you
to "break into" the statement and capture an intermediary result which
can be extremely useful for debugging or to take that result and create
another variation on the final result.

Note: In the future, this operator will see some change as it gains the
ability to run list operations in parallel. It will enforce that the
B<right> operand is enclosable as a closure (that can be cloned and run in
a subthread).

=end pod

# vim: expandtab shiftwidth=4 ft=perl6
