=begin pod :kind("Language") :subkind("Language") :category("fundamental")

=TITLE Subscripts

=SUBTITLE Accessing data structure elements by index or key

One often needs to refer to a specific element (or slice of elements) from a
collection or data structure. Borrowing from mathematical notation where the
components of a vector I<v> would be referred to as I<v₁, v₂, v₃>, this concept
is called "subscripting" (or "indexing") in Raku.

=head1 Basics

Raku provides two universal subscripting interfaces:

=begin table
         elements are           interface      supported by
         identified by          name
    ===  ==================     =============  ============================
    [ ]  zero-based indices     Positional     Array, List, Buf, Match, ...
    { }  string or object keys  Associative    Hash, Bag, Mix, Match, ...
=end table

=head2 B<Positional> subscripting

B<Positional> subscripting(via L<C<postcircumfix [
]>|/language/operators#postcircumfix_[_]>) addresses elements of an ordered
collection by their position. Index 0 refers to the first element, index 1 to
the second, and so on:

    my @chores = "buy groceries", "feed dog", "wash car";
    say @chores[0];  # OUTPUT: «buy groceries␤»
    say @chores[1];  # OUTPUT: «feed dog␤»
    say @chores[2];  # OUTPUT: «wash car␤»

Note that Rakudo's implementation of subscripting allows only 63 bits on
64 bit builds. See
L<Stack Overflow|https://stackoverflow.com/questions/61031107/do-array-indices-need-to-be-native-ints/61031617#61031617>.
If larger subscripts are required, one may use L<Array::Sparse|https://modules.raku.org/dist/Array::Sparse>
or alternatively, use a C<Hash> with C<Associative> subscripting (see below).

=head2 B<Associative> subscripting

B<Associative> subscripting (via L<C<postcircumfix { }>|
/language/operators#postcircumfix_{_}>), does not require the collection to
keep its elements in any particular order - instead, it uses a unique key to
address each value. The nature of the keys depends on the collection in
question: For example a standard L<Hash|/type/Hash> uses string keys, whereas
a L<Mix|/type/Mix> allows arbitrary objects as keys, etc.:

    my %grade = Zoe => "C", Ben => "B+";
    say %grade{"Zoe"};  # OUTPUT: «C␤»
    say %grade{"Ben"};  # OUTPUT: «B+␤»

    my $stats = ( Date.today => 4.18, Date.new(2015,  4,  5) => 17.253 ).Mix;
    say $stats{ Date.new(2015, 4, 4) + 1 };  # OUTPUT: «17.253␤»

For passing single-word string keys to C<{ }>, you can also use the
L<angle bracketed word quoting constructs|/language/quoting#Word_quoting:_qw>
as if they were postcircumfix operators:

    my %grade = Zoe => "C", Ben => "B+";
    say %grade<Zoe>;    # OUTPUT: «C␤»
    say %grade<Ben>;    # OUTPUT: «B+␤»

This is really just syntactic sugar that gets turned into the corresponding
C<{ }> form at compile-time:

    =begin code :preamble<my %hash;my $var>
    %hash<foo bar>;       # same as %hash{ <foo bar> }
    %hash«foo "$var"»;    # same as %hash{ «foo "$var"» }
    %hash<<foo "$var">>;  # same as %hash{ <<foo "$var">> }
    =end code

You may have noted above that we avoided having to quote C<Zoe> by using
the C«=>» operator, but that same operator did not just put invisible
quotes around C<Date.new(2015,  4,  5)>, and we were able to find the
same element using C<$stats{ Date.new(2015, 4, 4) + 1 }>.  This is because
C«=>» only puts invisible quotes around single words, and by "word" we
mean an identifier/name.  The C«=>» operator is there to prevent us from
accidentally calling functions or using constants with that name.

Hash subscripts do not do the same thing as C«=>».  The default C<Hash>
has been made to behave the way new users have come to expect
from using other languages, and for general ease of use.  On a
default C<Hash>, subscripts coerce keys into strings, as long as
those keys produce something C<Cool>.  You can use C<.raku> on a
collection to be sure whether the keys are strings or objects:

    ( 1  => 1 ).raku.say;            # OUTPUT: «1 => 1␤»
    my %h; %h{1}   = 1; say %h.raku; # OUTPUT: «{ "1" => 1 }␤»
    ( 1/2 => 1 ).raku.say;           # OUTPUT: «0.5 => 1␤»
    my %h; %h{1/2} = 1; say %h.raku; # OUTPUT: «{ "0.5" => 1 }␤»
    ( pi => 1 ).raku.say;            # OUTPUT: «:pi(1)␤»
    my %h; %h{pi}  = 1; say %h.raku; # OUTPUT: «{ "3.14159265358979" => 1 }␤»

While the invisible quotes around single names is built into C«=>»,
string conversion is not built into the curly braces: it is a behavior
of the default C<Hash>.  Not all types of hashes or collections
do so:

=for code
my %h := MixHash.new;
%h{pi} = 1; %h.raku.say;         # OUTPUT: «(3.14159265358979e0=>1).MixHash␤»

(Any name that C«=>» would convert to a string can also be used to build
a pair using "adverbial notation" and will appear that way when viewed
through C<.raku>, which is why we see C<:pi(1)> above.)


=head2 Applying subscripts

Subscripts can be applied to any expression that returns a subscriptable
object, not just to variables:

    say "__Hello__".match(/__(.*)__/)[0];   # OUTPUT: «｢Hello｣␤»
    say "__Hello__".match(/__(.*)__/).[0];  # same, in method notation

Positional and associative subscripting are not mutually exclusive - for
example, L<Match|/type/Match> objects support both (each accessing a different
set of data). Also, to make list processing more convenient, class
L<Any|/type/Any> provides a fallback implementation for positional subscripts
which simply treats the invocant as a list of one element. (But there's no such
fallback for associative subscripts, so they throw a runtime error when applied
to an object that does not implement support for them.)

    =begin code
    say 42[0];    # OUTPUT: «42␤»
    say 42<foo>;  # ERROR: Type Int does not support associative indexing.
    =end code

=head1 Nonexistent elements

What happens when a I<nonexistent> element is addressed by a subscript is up to
the collection type in question. Standard L<Array|/type/Array> and
L<Hash|/type/Hash> collections return the type object of their L<value type
constraint|/routine/of> (which, by default, is L<Any|/type/Any>) unless the collection
has been declared with the L<C<is default>|/type/Variable#trait_is_default>
trait in which case the returned value will be whatever the programmer declared
it to be:

    # no default values specified
    my @array1;     say @array1[10];                   # OUTPUT: «(Any)␤»
    my Int @array2; say @array2[10];                   # OUTPUT: «(Int)␤»

    my %hash1;      say %hash1<foo>;                   # OUTPUT: «(Any)␤»
    my Int %hash2;  say %hash2<foo>;                   # OUTPUT: «(Int)␤»

    # default values specified
    my @array3 is default('--');     say @array3[10];  # OUTPUT: «--␤»
    my Int @array4 is default(17);   say @array4[10];  # OUTPUT: «17␤»

    my %hash3 is default('Empty');   say %hash3<foo>;  # OUTPUT: «Empty␤»
    my Int %hash4 is default(4711);  say %hash4<foo>;  # OUTPUT: «4711␤»

However, other types of collections may react differently to subscripts that
address nonexistent elements:

    say (0, 10, 20)[3];           # OUTPUT: «Nil␤»
    say bag(<a a b b b>)<c>;      # OUTPUT: «0␤»
    say array[uint8].new(1, 2)[2] # OUTPUT: «0␤»

To silently skip nonexistent elements in a subscripting operation, see
L<#Truncating slices> and the L<#:v> adverb.

=head1 From the end

Positional indices are counted from the start of the collection, but there's
also a notation for addressing elements by their position relative to the end:
C<*-1> refers to the last element, C<*-2> to the second-to-last element, and so
on. From version 6.d, C<*-0> refers to the element just beyond the last one

    my @alphabet = 'A' .. 'Z';
    say @alphabet[*-1];  # OUTPUT: «Z␤»
    say @alphabet[*-2];  # OUTPUT: «Y␤»
    say @alphabet[*-3];  # OUTPUT: «X␤»
    @alphabet[*-0] = 'þ';
    say @alphabet;
    #  OUTPUT: «[A B C D E F G H I J K L M N O P Q R S T U V W X Y Z þ]␤»

B<Note>: The asterisk, which is actually a L<C<Whatever>|/type/Whatever>, is
important. Passing a bare negative integer (e.g. C<@alphabet[-1]>) like you
would do in many other programming languages, throws an error in Raku.

What actually happens here, is that an expression like C<*-1> declares a code
object via L<Whatever|/type/Whatever>-currying - and the C<[ ]> subscript reacts
to being given a code object as an index, by calling it with the length of the
collection as argument and using the result value as the actual index. In other
words, C<@alphabet[*-1]> becomes C<@alphabet[@alphabet.elems - 1]>.

This means that you can use arbitrary expressions which depend on the size of
the collection:

=begin code :preamble<my @array; my $size;my $i;>
say @array[* div 2];  # select the middlemost element
say @array[$i % *];   # wrap around a given index ("modular arithmetic")
say @array[ -> $size { $i % $size } ];  # same as previous
=end code

=head1 Slices

When multiple elements of a collection need to be accessed, there's a shortcut
to doing multiple separate subscripting operations: Simply specify a I<list> of
indices/keys in the subscript, to get back a I<list> of elements - also called
a "slice" - in the same order.

For positional slices, you can mix normal indices with
L<from-the-end|#From the end> ones:

    my @alphabet = 'a' .. 'z';
    say @alphabet[15, 4, *-9, 11].raku;  # OUTPUT: «("p", "e", "r", "l")␤»

In the C<*-number> construct above, C<*> indicates the end of the
array as explained above in the L<From the end|#From the end>
section. So if you want to take the last N elements of the array, you
will have to create a L<Range|/type/Range> that includes it.

     (5802..5830).map( {.chr} )[*-10..*-5] # OUTPUT:  «(ᚽ ᚾ ᚿ ᛀ ᛁ ᛂ)␤»

Using C<*> as the last element of the range will, effectively, return
the last elements of the collection.

For associative slices, the angle brackets form often comes in handy:

    my %color = kiwi => "green", banana => "yellow", cherry => "red";
    say %color{"cherry", "kiwi"};  # OUTPUT: «(red green)␤»
    say %color<cherry kiwi>;       # OUTPUT: «(red green)␤»
    say %color{*};                 # OUTPUT: «(red yellow green)␤»

Be aware that slices are controlled by the I<type> of what is passed to
(L<one dimension of|#Multiple dimensions>) the subscript, not its length.
In particular the I<type> can be any of the following:

=item a lazy Iterable, that L<truncates|#Truncating slices> in [ ]

=item accordingly, an infinite Range will truncate, but a finite one produces a normal slice

=item '*' (whatever-star), that returns the full slice (as if all keys/indices were specified)

=item any other object, that provides a single-element access rather than a slice

=item Callable,  whatever is returned by the callable (this can lead to recursion)

=item empty, the full slice known as L<Zen slice|#Zen slices>

=item any iterable different from the above ones, normal slice

The notable difference between C<*> and Zen slice (empty) is that the
L<Whatever|/type/Whatever> star will cause full
L<reification|/language/glossary#index-entry-Reify> or itemization, while Zen
slice won't. Both versions also
L<de-cont|https://perl6advent.wordpress.com/2017/12/02/perl-6-sigils-variables-and-containers/#decont>.

So even a one-element list returns a slice, whereas a bare scalar value doesn't:

    =begin code :preamble<my @alphabet = 'a' .. 'z'>
    say @alphabet[2,];        # OUTPUT: «(c)␤»
    say @alphabet[2,].^name;  # OUTPUT: «List␤»

    say @alphabet[2];         # OUTPUT: «c␤»
    say @alphabet[2].^name;   # OUTPUT: «Str␤»
    =end code

(The angle bracket form for associative subscripts works out because
L<word quoting|/language/quoting#Word_quoting:_qw> conveniently returns a
L<Str|/type/Str> in case of a single word, but a L<List|/type/List> in case
of multiple words.)

In fact, the list structure of (L<the current dimension of|#Multiple
dimensions>) the subscript is preserved across the slice operation
(but the kind of Iterable is not – the result is always just lists.)

    =begin code :preamble<my @alphabet = 'a' .. 'z'>
    say @alphabet[0, (1..2, (3,))];       # OUTPUT: «(a ((b c) (d)))␤»
    say @alphabet[0, (1..2, [3,])];       # OUTPUT: «(a ((b c) (d)))␤»
    say @alphabet[flat 0, (1..2, (3,))];  # OUTPUT: «(a b c d)␤»
    say flat @alphabet[0, (1..2, (3,))];  # OUTPUT: «(a b c d)␤»
    =end code

=head2 Truncating slices

Referring to nonexistent elements in a slice subscript causes the output C<List>
to contain undefined values (or L<whatever else| #Nonexistent elements> the
collection in question chooses to return for nonexistent elements):

    =begin code
    my  @letters = <a b c d e f>;
    say @letters[3..7];  # OUTPUT: «(d e f (Any) (Any))␤»
    =end code

This behavior, while at first glance may seem unintuitive, is desirable in
instances when you want to assign a value at an index in which a value does
not currently exist.

    =begin code
    my  @letters;
    say @letters; # OUTPUT: «[]␤»

    @letters[^10] = 'a'..'z';
    say @letters; # OUTPUT: «[a b c d e f g h i j]␤»
    =end code

If you want the resulting slice to only include existing elements, you can
silently skip the non-existent elements using the L<#:v> adverb.

    =begin code
    my  @letters = <a b c d e f>;
    say @letters[3..7]:v;  # OUTPUT: «(d e f)␤»
    =end code

The behavior when indexing a collection via L<lazy|/language/list#Lazy_lists>
subscripts is different than when indexing with their eager counterparts.
When accessing via a lazy subscript, the resulting slice will be truncated.

    =begin code :preamble<my @letters>
    say @letters[lazy 3..7]; # OUTPUT: «(d e f)␤»
    say @letters[     3..*]; # OUTPUT: «(d e f)␤»
    =end code

This behavior exists as a precaution to prevent runaway generation of massive,
potentially infinite C<Lists> and the out-of-memory issues that occur as a
result.

X<|Zen slices>
=head2 Zen slices

If you put the subscript operator behind an object without specifying any
indices/keys at all, it simply returns the subscripted object itself. Since it
is empty but returns everything, it is known as a I<Zen slice>.

Zen slicing is different from passing a C<Whatever>-star (which, like a normal
slice, always returns a List of elements no matter the type of the original
object) or an empty list (which returns an empty slice):

    my %bag := (orange => 1, apple => 3).Bag;
    say %bag<>;    # OUTPUT: «Bag(apple(3) orange)␤»
    say %bag{};    # OUTPUT: «Bag(apple(3) orange)␤»
    say %bag{*};   # OUTPUT: «(1 3)␤»
    say %bag{()};  # OUTPUT: «()␤»

Zen slicing does not L<reify|/language/glossary#index-entry-Reify> or
L<cache|/routine/cache> (not even C<Seq>s) and merely returns the invocant. It
is usually used to
L<interpolate|/language/quoting#Interpolation:_qq> entire arrays / hashes into
strings or to L<decont|/language/glossary#index-entry-decont>.

    my @words = "cruel", "world";
    say "Hello, @words[]!";  # OUTPUT: «Hello, cruel world!␤»

    my $list = <a b c>;
    .say for $list;   # OUTPUT: «(a b c)␤»
    .say for $list<>; # OUTPUT: «a␤b␤c␤»
    .say for $list[]; # OUTPUT: «a␤b␤c␤»

    my @fib = 1,1, * + * … *;
    say @fib[];                 # OUTPUT: «[...]␤»

=head1 Multiple dimensions

Dimensions in subscripts are separated by a semicolon, allowing to mix lists of
elements and dimensions.

    my @twodim = (<a b c>, (1, 2, 3));
    say @twodim;
    # OUTPUT: «[(a b c) (1 2 3)]␤»

    say @twodim[0,1;1]; # 2nd element of both lists
    # OUTPUT: «(b 2)␤»

    my %pantheon = %('Baldr' => 'consort' => 'Nanna' ,
                     'Bragi' => 'consort' => 'Iðunn' ,
                     'Nótt'  => 'consort' => 'Dellingr' );
    say %pantheon{'Bragi','Nótt';'consort'}; # 'consort' value for both keys
    # OUTPUT: «(Iðunn Dellingr)␤»

X<|flattening ;>

Multidimensional subscripts can be used to flatten nested lists when combined
with L<Whatever|/type/Whatever>.

    my @toomany = [[<a b>], [1, 2]];
    say @toomany;
    # OUTPUT: «[[a b] [1 2]]␤»

    say @toomany[*;*];
    # OUTPUT: «(a b 1 2)␤»

You can use as many I<flattening semicolons> as you want; there will be, at
most, as many nesting levels flattened as the number of semicolons:

    say [[1,2,[3,4]],[4,5]][*;*];     # OUTPUT: «(1 2 [3 4] 4 5)␤»
    say [[1,2,[3,4]],[4,5]][*;*;*;*]; # OUTPUT: «(1 2 3 4 4 5)␤»

In the first example, with one C<Whatever> less than the number of levels, the
deepest one will not be flattened; in the second case it is, since it's greater
than the number of levels.

You can use L<Whatever|/type/Whatever> to select ranges or "rows" in
multidimensional subscripts.

    my @a = [[1,2], [3,4]];
    say @a[*;1]; # 2nd element of each sub list
    # OUTPUT: «(2 4)␤»
    my @a = (<1 c 6>, <2 a 4>, <5 b 3>);
    say @a.sort( { $_[1] } ); # sort by 2nd column
    # OUTPUT: «((2 a 4) (5 b 3) (1 c 6))␤»

=head1 Modifying elements

=comment TODO

=head1 Autovivification

Subscripts participate in "autovivification", i.e. the process by which arrays
and hashes automatically spring into existence when needed, so that you can
build nested data structures without having to pre-declare the collection type
at each level:

=begin code
my $beatles;

$beatles{"White Album"}[0] = "Back in the U.S.S.R.";  # autovivification!

say $beatles.raku;  # OUTPUT: «${"White Album" => $["Back in the U.S.S.R."]}␤»
=end code

C<$beatles> started out undefined, but became a L<Hash|/type/Hash> object
because it was subscripted with C<{ }> in the assignment. Similarly,
C<$beatles{"White Album"}> became an L<Array|/type/Array> object due to being
subscripted with C<[ ]> in the assignment.

Note that the subscripting itself does not cause autovivification: It only
happens when the result of the subscripting chain is I<assigned> to (or
otherwise mutated).

=comment TODO: Add expanded documentation on autovivification (which affects
               more than just subscripts, i.e. also routines like C<push>), at
               /language/datastructures.html, and link to it from here.


=head1 Binding

A subscripting expression may also be used as the left-hand-side of a binding
statement. If supported by the subscripted collection's type, this replaces
whatever value container would be naturally found at that "slot" of the
collection, with the specified container.

The built-in L<Array|/type/Array> and L<Hash|/type/Hash> types support this in
order to allow building complex linked data structures:

    my @a = 10, 11, 12, 13;
    my $x = 1;

    @a[2] := $x;  # Bound! (@a[2] and $x refer to the same container now.)

    $x++; @a[2]++;

    say @a;  # OUTPUT: «[10 11 3 13]␤»
    say $x;  # OUTPUT: «3␤»

This can be specially useful when lazy data structures are part of a bigger one.

=begin code
my @fib = 1,1, * + * … ∞;
my @lucas = 1,3, * + * … ∞;
my %sequences;
%sequences<f> := @fib;
%sequences<l> := @lucas;
for %sequences.keys -> $s {
    for ^10 -> $n {
        say %sequences{$s}[100+$n*10]/%sequences{$s}[101+$n*10];
    }
}
# OUTPUT: 0.6180339887498949 times 20.
=end code

In this case, hash keys are bound to lazily generated sequences. The fact that
they are bound means that whatever state has been computed is shared by the hash
value and the sequence it's bound to, making computations of subsequent elements
faster.

=comment TODO: Add expanded documentation on building complex data structures
               at /language/datastructures.html, and link to it from here.

See L<#method BIND-POS> and L<#method BIND-KEY> for the underlying mechanism.


=head1 Adverbs

The return value and possible side-effect of a subscripting operation can be
controlled using adverbs; these are defined on the relevant subscript
L<operators|/language/operators#Method_postfix_precedence>.

Beware of the relatively loose precedence of operator adverbs, which may
require you to add parentheses in compound expressions:

=for code :skip-test<illustrates error>
if $foo || %hash<key>:exists { ... }    # WRONG, tries to adverb the || op
=for code :preamble<my $foo; my %hash;>
if $foo || (%hash<key>:exists) { ... }  # correct
if $foo or %hash<key>:exists { ... }    # also correct

The supported adverbs are:

X<|:exists (subscript adverb)>
=head2 C<:exists>

Returns whether or not the requested element exists, instead of returning the
element's actual value. This can be used to distinguish between elements with
an undefined value, and elements that aren't part of the collection at all:

    my @foo = Any, 10;
    say @foo[0].defined;    # OUTPUT: «False␤»
    say @foo[0]:exists;     # OUTPUT: «True␤»
    say @foo[2]:exists;     # OUTPUT: «False␤»
    say @foo[0, 2]:exists;  # OUTPUT: «(True False)␤»

    my %fruit = apple => Any, orange => 10;
    say %fruit<apple>.defined;       # OUTPUT: «False␤»
    say %fruit<apple>:exists;        # OUTPUT: «True␤»
    say %fruit<banana>:exists;       # OUTPUT: «False␤»
    say %fruit<apple banana>:exists; # OUTPUT: «(True False)␤»

May also be negated to test for non-existence:

    =begin code :preamble<my %fruit = :apple(Any), :orange(10)>
    say %fruit<apple banana>:!exists; # OUTPUT: «(False True)␤»
    =end code

To check if I<all> elements of a slice exist, use an L<all|/routine/all>
junction:

    =begin code :preamble<my %fruit;>
    if all %fruit<apple orange banana>:exists { ... }
    =end code

It can be used on multi-dimensional arrays and hashes:

    my @multi-dim = 1, [2, 3, [4, 5]];
    say @multi-dim[1;2;0]:exists;                # OUTPUT: «True␤»
    say @multi-dim[1;2;5]:exists;                # OUTPUT: «False␤»

    my %multi-dim = 1 => { foo => { 3 => 42 } };
    say %multi-dim{1;'foo';3}:exists;            # OUTPUT: «True␤»
    say %multi-dim{1;'bar';3}:exists;            # OUTPUT: «False␤»


C<:exists> can be combined with the L<#:delete> and L<#:p>/L<#:kv> adverbs - in
which case the behavior is determined by those adverbs, except that any returned
element I<value> is replaced with the corresponding L<Bool|/type/Bool>
indicating element I<existence>.

See L<#method EXISTS-POS> and L<#method EXISTS-KEY> for the underlying
mechanism.

X<|:delete (subscript adverb)>
=head2 C<:delete>

Delete the element from the collection or, if supported by the collection,
creates a hole at the given index, in addition to returning its value.

    my @tens = 0, 10, 20, 30;
    say @tens[3]:delete;     # OUTPUT: «30␤»
    say @tens;               # OUTPUT: «[0 10 20]␤»

    my %fruit = apple => 5, orange => 10, banana => 4, peach => 17;
    say %fruit<apple>:delete;         # OUTPUT: «5␤»
    say %fruit<peach orange>:delete;  # OUTPUT: «(17 10)␤»
    say %fruit;                       # OUTPUT: «{banana => 4}␤»

Note that assigning C<Nil> will revert the container at the given index to its
default value. It will not create a hole. The created holes can be tested for
with C<:exists> but iteration will not skip them and produce undefined values
instead.

    my @a = 1, 2, 3;
    @a[1]:delete;
    say @a[1]:exists;
    # OUTPUT: «False␤»
    .say for @a;
    # OUTPUT: «1␤(Any)␤3␤»

With the negated form of the adverb, the element is not actually deleted. This
means you can pass a flag to make it conditional:

=begin code :preamble<my %fruit = :10apple; my $flag = True>
say %fruit<apple> :delete($flag);  # deletes the element only if $flag is
                                   # true, but always returns the value.
=end code

Can be combined with the L<#:exists> and L<#:p>/L<#:kv>/L<#:k>/L<#:v> adverbs -
in which case the return value will be determined by those adverbs, but the
element will at the same time also be deleted.

See L<#method DELETE-POS> and L<#method DELETE-KEY> for the underlying
mechanism.

You can use also these adverbs on associative type objects, but it will
actually do nothing; it will also return C<Nil>

=for code
say Hash<foo>:delete; # OUTPUT: «Nil␤»

The adverb can be used on lazy arrays too:

=for code
my @lazy-array = lazy 1, 11, 121 ... 10**100;
@lazy-array[2**24]:delete;

X<|:p (subscript adverb)>
=head2 C<:p>

Return both the index/key and the value of the element, in the form of a
L<Pair|/type/Pair>, and silently skip nonexistent elements:

    my  @tens = 0, 10, 20, 30;
    say @tens[1]:p;        # OUTPUT: «1 => 10␤»
    say @tens[0, 4, 2]:p;  # OUTPUT: «(0 => 0 2 => 20)␤»

    my  %month = Jan => 1, Feb => 2, Mar => 3;
    say %month<Feb>:p;          # OUTPUT: «Feb => 2␤»
    say %month<Jan Foo Mar>:p;  # OUTPUT: «(Jan => 1 Mar => 3)␤»

If you I<don't> want to skip nonexistent elements, use the negated form:

    =begin code :preamble<my %month = :1Jan, :2Feb, :3Mar>
    say %month<Jan Foo Mar>:!p;  # OUTPUT: «(Jan => 1 Foo => (Any) Mar => 3)␤»
    =end code

Can be combined with the L<#:exists> and L<#:delete> adverbs.

See also the L<pairs|/routine/pairs> routine.

X<|:kv (subscript adverb)>
=head2 C<:kv>

Return both the index/key and the value of the element, in the form of a
L<List|/type/List>, and silently skip nonexistent elements. When used on a
L<slice|#Slices>, the return value is a single flat list of interleaved keys
and values:

    my  @tens = 0, 10, 20, 30;
    say @tens[1]:kv;        # OUTPUT: «(1 10)␤»
    say @tens[0, 4, 2]:kv;  # OUTPUT: «(0 0 2 20)␤»

    my  %month = Jan => 1, Feb => 2, Mar => 3;
    say %month<Feb>:kv;          # OUTPUT: «(Feb 2)␤»
    say %month<Jan Foo Mar>:kv;  # OUTPUT: «(Jan 1 Mar 3)␤»

If you I<don't> want to skip nonexistent elements, use the negated form:

    =begin code :preamble<my %month = :1Jan, :2Feb, :3Mar>
    say %month<Jan Foo Mar>:!kv;  # OUTPUT: «(Jan 1 Foo (Any) Mar 3)␤»
    =end code

This adverb is commonly used to iterate over slices:

    =begin code :preamble<my %month>
    for %month<Feb Mar>:kv -> $month, $i {
        say "$month had {Date.new(2015, $i, 1).days-in-month} days in 2015"
    }
    =end code

Can be combined with the L<#:exists> and L<#:delete> adverbs.

See also the L<kv|/routine/kv> routine.

X<|:k (subscript adverb)>
=head2 C<:k>

Return only the index/key of the element, rather than its value, and silently
skip nonexistent elements:

    my @tens = 0, 10, 20, 30;
    say @tens[1]:k;        # OUTPUT: «1␤»
    say @tens[0, 4, 2]:k;  # OUTPUT: «(0 2)␤»

    my %month = Jan => 1, Feb => 2, Mar => 3;
    say %month<Feb>:k;          # OUTPUT: «Feb␤»
    say %month<Jan Foo Mar>:k;  # OUTPUT: «(Jan Mar)␤»

If you I<don't> want to skip nonexistent elements, use the negated form:

    =begin code :preamble<my %month = :1Jan, :2Feb, :3Mar>
    say %month<Jan Foo Mar>:!k;  # OUTPUT: «(Jan Foo Mar)␤»
    =end code

See also the L<keys|/routine/keys> routine.

X<|:v (subscript adverb)>
=head2 C<:v>

Return the bare value of the element (rather than potentially returning a
mutable value container), and silently skip nonexistent elements:

    =begin code
    my @tens = 0, 10, 20, 30;
    say @tens[1]:v;        # OUTPUT: «10␤»
    say @tens[0, 4, 2]:v;  # OUTPUT: «(0, 20)␤»
    @tens[3] = 31;         # OK
    @tens[3]:v = 31;       # ERROR, Cannot modify an immutable Int (31)

    my %month = Jan => 1, Feb => 2, Mar => 3;
    say %month<Feb>:v;          # OUTPUT: «2␤»
    say %month<Jan Foo Mar>:v;  # OUTPUT: «(1 3)␤»
    =end code

If you I<don't> want to skip nonexistent elements, use the negated form:

    =begin code :preamble<my %month = :1Jan, :2Feb, :3Mar>
    say %month<Jan Foo Mar>:!v;  # OUTPUT: «(1 (Any) 3)␤»
    =end code

See also the L<values|/routine/values> routine.

=head1 Custom types

The subscripting interfaces described on this page are not meant to be
exclusive to Raku's built-in collection types - you can (and should)
reuse them for any custom type that wants to provide access to data by
index or key.

You don't have to manually overload the L<C<postcircumfix [ ]>|
/routine/[ ]#postcircumfix_[_]> and L<C<postcircumfix { }>|
/routine/{ }#postcircumfix_{_}> operators and re-implement all their magic,
to achieve that - instead, you can rely on the fact that their standard
implementation dispatches to a well-defined set of low-level methods behind
the scenes. For example:

=table
    when you write:    this gets called behind the scenes:
    ===============    ==============================================
    %foo<aa>           %foo.AT-KEY("aa")
    %foo<aa>:delete    %foo.DELETE-KEY("aa")
    @foo[3, 4, 5]      @foo.AT-POS(3), @foo.AT-POS(4), @foo.AT-POS(5)
    @foo[*-1]          @foo.AT-POS(@foo.elems - 1)

So in order to make subscripting work, you only have to implement or
delegate those low-level methods (L<detailed below
|#Methods_to_implement_for_positional_subscripting>) for your custom type.

If you do, you should also let your type compose the L<C<Positional>|
/type/Positional> or L<C<Associative>|/type/Associative> role,
respectively. This doesn't add any functionality per se, but announces (and
may be used to check) that the type implements the corresponding
subscripting interface.

=head2 Custom type example

Imagine a C<HTTP::Header> type which, despite being a custom class with special
behavior, can be indexed like a hash:

    =begin code
    my $request = HTTP::Request.new(GET => "raku.org");
    say $request.header.^name;  # OUTPUT: «HTTP::Header␤»

    $request.header<Accept> = "text/plain";
    $request.header{'Accept-' X~ <Charset Encoding Language>} = <utf-8 gzip en>;
    $request.header.push('Accept-Language' => "fr");  # like .push on a Hash

    say $request.header<Accept-Language>.raku;  # OUTPUT: «["en", "fr"]␤»

    my $rawheader = $request.header.Str;  # stringify according to HTTP spec
    =end code

A simple way to implement this class would be to give it an attribute of type
L<Hash|/type/Hash>, and delegate all subscripting and iterating related
functionality to that attribute (using a custom type constraint to make sure
users don't insert anything invalid into it):

    =begin code
    class HTTP::Header does Associative {
        subset StrOrArrayOfStr where Str | ( Array & {.all ~~ Str} );

        has %!fields of StrOrArrayOfStr
                     handles <AT-KEY EXISTS-KEY DELETE-KEY push
                              iterator list kv keys values>;

        method Str { #`[not shown, for brevity] }
    }
    =end code

However, HTTP header field names are supposed to be case-insensitive (and
preferred in camel-case). We can accommodate this by taking the C<*-KEY>
and C<push> methods out of the C<handles> list, and implementing them
separately like this:

    =begin code :skip-test<continued example>
    method AT-KEY     ($key) is rw { %!fields{normalize-key $key}        }
    method EXISTS-KEY ($key)       { %!fields{normalize-key $key}:exists }
    method DELETE-KEY ($key)       { %!fields{normalize-key $key}:delete }
    method push(*@_) { #`[not shown, for brevity] }

    sub normalize-key ($key) { $key.subst(/\w+/, *.tc, :g) }
    =end code

Note that subscripting C<%!fields> returns an appropriate rw container, which
our C<AT-KEY> can simply pass on.

However, we may prefer to be less strict about user input and instead take
care of sanitizing the field values ourselves. In that case, we can remove
the C<StrOrArrayOfStr> type constraint on C<%!fields>, and replace our
C<AT-KEY> implementation with one that returns a custom C<Proxy> container
which takes care of sanitizing values on assignment:

    =begin code :skip-test<continued example>
    multi method AT-KEY (::?CLASS:D: $key) is rw {
        my $element := %!fields{normalize-key $key};

        Proxy.new(
            FETCH => method () { $element },

            STORE => method ($value) {
                $element = do given $value».split(/',' \s+/).flat {
                    when 1  { .[0] }    # a single value is stored as a string
                    default { .Array }  # multiple values are stored as an array
                }
            }
        );
    }
    =end code

Note that declaring the method as C<multi> and restricting it to C<:D> (defined
invocants) makes sure that the undefined case is passed through to the default
implementation provided by C<Any> (which is involved in auto-vivification).

=head2 Methods to implement for positional subscripting

In order to make index-based subscripting via L<C<postcircumfix [ ]>|
/routine/[ ]#postcircumfix_[_]> work for your custom type, you should
implement at least C<elems>, C<AT-POS> and C<EXISTS-POS> - and optionally
others as detailed below.

=head3 method elems

    multi method elems(::?CLASS:D:)

Expected to return a number indicating how many subscriptable elements
there are in the object. May be called by users directly, and is also
called by L<C<postcircumfix [ ]>|/routine/[ ]#postcircumfix_[_]> when
indexing elements from the end, as in C<@foo[*-1]>.

If not implemented, your type will inherit the default implementation from
C<Any> that always returns C<1> for defined invocants - which is most likely not
what you want. So if the number of elements cannot be known for your positional
type, add an implementation that L<fail|/routine/fail>s or L<die|/routine/die>s,
to avoid silently doing the wrong thing.

=head3 method AT-POS

=comment When modifying this section, please also adapt the AT-KEY
         section accordingly as they are very similar.

    multi method AT-POS (::?CLASS:D: $index)

=comment TODO: Cover the case of multi-dim indices (also for all the other
               methods below), after jnthn's ongoing refactor is finished.

Expected to return the element at position C<$index>. This is what
L<C<postcircumfix [ ]>|/routine/[ ]#postcircumfix_[_]> normally calls.

If you want an element to be mutable (like they are for the built-in
L<Array|/type/Array> type), you'll have to make sure to return it in the form of
an item container that evaluates to the element's value when read, and updates
it when assigned to. Remember to use C<return-rw> or the C<is rw> routine trait
to make that work; see the L<example
|/language/subscripts#Custom_type_example>.

=head3 method EXISTS-POS

=comment When modifying this section, please also adapt the EXISTS-KEY
         section accordingly as they are very similar.

    multi method EXISTS-POS (::?CLASS:D: $index)

Expected to return a Bool indicating whether or not there is an element at
position C<$index>. This is what L<C<postcircumfix [ ]>|
/routine/[ ]#postcircumfix_[_]> calls when invoked like C<@foo[42]:exists>.

What "existence" of an element means, is up to your type.

If you don't implement this, your type will inherit the default implementation
from C<Any>, which returns True for 0 and False for any other index - which is
probably not what you want. So if checking for element existence cannot be done
for your type, add an implementation that L<fail|/routine/fail>s or
L<die|/routine/die>s, to avoid silently doing the wrong thing.

=head3 method DELETE-POS

=comment When modifying this section, please also adapt the DELETE-KEY
         section accordingly as they are very similar.

    multi method DELETE-POS (::?CLASS:D: $index)

Expected to delete the element at position C<$index>, and return the value
it had. This is what L<C<postcircumfix [ ]>|/routine/[ ]#postcircumfix_[_]>
calls when invoked like C<@foo[42]:delete>.

What "deleting" an element means, is up to your type.

Implementing this method is optional; if you don't, users trying to delete
elements from an object of this type will get an appropriate error message.

=head3 method ASSIGN-POS

=comment When modifying this section, please also adapt the ASSIGN-KEY
         section accordingly as they are very similar.

    multi method ASSIGN-POS (::?CLASS:D: $index, $new)

Expected to set the element at position C<$index> to the value C<$new>.
Implementing this is entirely optional; if you don't, C<self.AT-POS($index)
= $new> is used instead, and if you do, you should make sure it has the
same effect.

This is meant as an opt-in performance optimization, so that simple
assignments like C<@numbers[5] = "five"> can operate without having to call
C<AT-POS> (which would have to create and return a potentially expensive
container object).

Note that implementing C<ASSIGN-POS> does I<not> relieve you from making
C<AT-POS> an C<rw> method though, because less trivial
assignments/modifications such as C<@numbers[5]++> will still use
C<AT-POS>.

=head3 method BIND-POS

=comment When modifying this section, please also adapt the BIND-KEY
         section accordingly as they are very similar.

    multi method BIND-POS (::?CLASS:D: $index, \new)

Expected to bind the value or container C<new> to the slot at position
C<$index>, replacing any container that would be naturally found there.
This is what is called when you write:

    =begin code :preamble<my @numbers;>
    my $x = 10;
    @numbers[5] := $x;
    =end code

The generic L<Array|/type/Array> class supports this in order to allow building
complex linked data structures, but for more domain-specific types it may not
make sense, so don't feel compelled to implement it. If you don't, users will
get an appropriate error message when they try to bind to a positional slot of
an object of this type.

=head3 method STORE

=comment When modifying this section, please also adapt the STORE
         section in Associative accordingly as they are very similar.

    method STORE (::?CLASS:D: \values, :$INITIALIZE)

This method should only be supplied if you want to support this syntax:

=for code :preamble<role Foo {}>
my @a is Foo = 1,2,3;

Which is used for binding your implementation of the C<Positional> role.

C<STORE> should accept the values to (re-)initialize the object with.  The
optional named parameter will contain a C<True> value when the method is called
on the object for the first time. It should return the invocant.

=begin code
role Logger { method log( Str $msg) {…}}

class ConsoLogger does Logger { method log ( Str $msg ) { "❢ $msg".say }}

class DNA {
    has $.chain;
    has Logger $!logger;

    submethod BUILD( :$chain, :$logger = ConsoLogger.new() ) {}

    method STORE (Str $chain where {
            /^^ <[ACGT]>+ $$ / and
            .chars %% 3
        },
        :$INITIALIZE --> DNA) {

        if ($INITIALIZE) {
            $!logger = ConsoLogger.new();
            $!logger.log( "Initialized" );
        }

        $!chain  := $chain;
        $!logger.log("Change value to $chain" );
        self
    }

    method Str(::?CLASS:D:) { return $!chain.comb.rotor(3).map( *.join("")).join("|") }
};

my @string is DNA = 'GAATCC';    # OUTPUT: «❢ Initialized␤❢ Change value to GAATCC␤»
say ~@string;                    # OUTPUT: «GAA|TCC␤»
@string = 'ACGTCG';              # OUTPUT: «❢ Change value to ACGTCG␤»
say  ~@string;                   # OUTPUT: «ACG|TCG␤»
=end code

This code takes into account the value of C<$INITIALIZE>, which is set to
C<True> only if we are assigning a value to a variable declared using the C<is>
syntax for the first time; for instance, as in this case, we might need to
initialize any injected dependency. The C<STORE> method should set the C<self>
variable and return it in all cases, including when the variable has already
been initialized; however, only in the first case we need to initialize the
logger we are using in this example.

The presence of the C<INITIALIZE> flag can be also used to create immutable
data structures:

=begin code
class A {
    has @.foo handles <Str gist raku>;
    multi method STORE(*@!foo, :$INITIALIZE!) { }
    multi method STORE(|) { die "Immutable" }
}

my @a is A = 1,2,3,4;
say @a;        # OUTPUT: «[1,2,3,4]␤»
@a = 4,5,6,7;  # dies: Immutable
=end code

=head2 Methods to implement for associative subscripting

In order to make key-based subscripting via L<C<postcircumfix { }>|
/routine/{ }#postcircumfix_{_}> work for your custom type, you should
implement at least C<AT-KEY> and C<EXISTS-KEY> - and optionally
others as detailed below.

=head3 method AT-KEY

=comment When modifying this section, please also adapt the AT-POS
         section accordingly as they are very similar.

    multi method AT-KEY (::?CLASS:D: $key)

Expected to return the element associated with C<$key>. This is what
L<C<postcircumfix { }>|/routine/{ }#postcircumfix_{_}> normally calls.

If you want an element to be mutable (like they are for the built-in
L<Hash|/type/Hash> type), you'll have to make sure to return it in the form of
an item container that evaluates to the element's value when read, and updates
it when assigned to. Remember to use C<return-rw> or the C<is rw> routine trait
to make that work; see the L<example
|/language/subscripts#Custom_type_example>.

On the other hand if you want your collection to be read-only, feel free
to return non-container values directly.

=head3 method EXISTS-KEY

=comment When modifying this section, please also adapt the EXISTS-POS
         section accordingly as they are very similar.

    multi method EXISTS-KEY (::?CLASS:D: $key)

Expected to return a Bool indicating whether or not there is an element
associated with C<$key>. This is what L<C<postcircumfix { }>
|/routine/{ }#postcircumfix_{_}> calls when invoked like
C<<%foo<aa>:exists>>.

What "existence" of an element means, is up to your type.

If you don't implement this, your type will inherit the default implementation
from C<Any>, which always returns False - which is probably not what you want.
So if checking for element existence cannot be done for your type, add an
implementation that L<fail|/routine/fail>s or L<die|/routine/die>s, to avoid
silently doing the wrong thing.

=head3 method DELETE-KEY

=comment When modifying this section, please also adapt the DELETE-POS
         section accordingly as they are very similar.

    multi method DELETE-KEY (::?CLASS:D: $key)

Expected to delete the element associated with C<$key>, and return the
value it had. This is what L<C<postcircumfix { }>
|/routine/{ }#postcircumfix_{_}> calls when invoked like
C<<%foo<aa>:delete>>.

What "deleting" an element means, is up to your type - though it should
usually cause C<EXISTS-KEY> to become C<False> for that key.

Implementing this method is optional; if you don't, users trying to delete
elements from an object of this type will get an appropriate error message.

=head3 method ASSIGN-KEY

=comment When modifying this section, please also adapt the ASSIGN-POS
         section accordingly as they are very similar.

    multi method ASSIGN-KEY (::?CLASS:D: $key, $new)

Expected to set the element associated with C<$key> to the value C<$new>.
Implementing this is entirely optional; if you don't, C<self.AT-KEY($key) =
$new> is used instead, and if you do, you should make sure it has the same
effect.

This is meant as an opt-in performance optimization, so that simple
assignments C<<%age<Claire> = 29>> can operate without having to call
C<AT-KEY> (which would have to create and return a potentially expensive
container object).

Note that implementing C<ASSIGN-KEY> does I<not> relieve you from making
C<AT-KEY> an C<rw> method though, because less trivial
assignments/modifications such as C<<%age<Claire>++>> will still use
C<AT-KEY>.

=head3 method BIND-KEY

=comment When modifying this section, please also adapt the BIND-POS
         section accordingly as they are very similar.

    multi method BIND-KEY (::?CLASS:D: $key, \new)

Expected to bind the value or container C<new> to the slot associated with
C<$key>, replacing any container that would be naturally found there.
This is what is called when you write:

    =begin code :preamble<my %age;>
    my $x = 10;
    %age<Claire> := $x;
    =end code

The generic L<Hash|/type/Hash> class supports this in order to allow building
complex linked data structures, but for more domain-specific types it may not
make sense, so don't feel compelled to implement it. If you don't, users will
get an appropriate error message when they try to bind to an associative slot of
an object of this type.

=head3 method STORE

=comment When modifying this section, please also adapt the STORE
         section in Positional accordingly as they are very similar.

    method STORE (::?CLASS:D: \values, :$INITIALIZE)

This method should only be supplied if you want to support the:

=for code :preamble<role Foo {}>
my %h is Foo = a => 42, b => 666;

syntax for binding your implementation of the C<Associative> role.

Should accept the values to (re-)initialize the object with, which either
could consist of C<Pair>s, or separate key/value pairs.  The optional
named parameter will contain a C<True> value when the method is called on
the object for the first time.  Should return the invocant.

=end pod

# vim: expandtab softtabstop=4 shiftwidth=4 ft=perl6
